#!/usr/bin/env node

/**
 * Inject version information into the build
 * This script generates a version file that can be imported at runtime
 *
 * In Docker builds, version.json is generated with git info.
 * This script reads that file and generates the appropriate exports.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Read package.json to get version
const packagePath = path.join(__dirname, '..', 'package.json');
const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));

// Try to read version.json (generated during Docker build)
let gitInfo = { commit: 'dev', ref: 'local', buildTime: new Date().toISOString(), commitsAhead: 0 };
const versionJsonPath = path.join(__dirname, '..', 'version.json');
if (fs.existsSync(versionJsonPath)) {
  try {
    gitInfo = JSON.parse(fs.readFileSync(versionJsonPath, 'utf8'));
  } catch {
    // Ignore errors, use defaults
  }
}

// Create version info object
const versionInfo = {
  version: packageData.version,
  name: packageData.name,
  commit: gitInfo.commit,
  ref: gitInfo.ref,
  buildTime: gitInfo.buildTime,
  commitsAhead: gitInfo.commitsAhead || 0,
  nodeVersion: process.version
};

// Generate version file content with all exports
const versionFileContent = `/**
 * Auto-generated version information
 * DO NOT EDIT - This file is automatically generated during build
 */

export const VERSION_INFO = ${JSON.stringify(versionInfo, null, 2)};

export const VERSION = '${versionInfo.version}';
export const PACKAGE_NAME = '${versionInfo.name}';
export const BUILD_TIME = '${versionInfo.buildTime}';
export const GIT_COMMIT = '${versionInfo.commit}';
export const GIT_REF = '${versionInfo.ref}';
export const COMMITS_AHEAD = ${versionInfo.commitsAhead};

/**
 * Get a formatted version string for display
 * Examples:
 * - Production (on tag): "1.0.0"
 * - Development: "1.0.0-rc.1 (e5f1b19)"
 */
export function getDisplayVersion() {
  // If ref is a tag or commit is dev/unknown, just show version
  if (
    GIT_REF.startsWith('v') ||
    GIT_COMMIT === 'dev' ||
    GIT_COMMIT === 'unknown'
  ) {
    return VERSION;
  }
  // Otherwise show version with commit
  return \`\${VERSION} (\${GIT_COMMIT.substring(0, 7)})\`;
}

/**
 * Check if this is a development build
 */
export function isDevBuild() {
  return (
    BUILD_TIME === 'development' ||
    GIT_REF === 'develop' ||
    GIT_REF.includes('dev') ||
    GIT_REF === 'local'
  );
}
`;

// Ensure dist/src directory exists
const distSrcPath = path.join(__dirname, '..', 'dist', 'src');
if (!fs.existsSync(distSrcPath)) {
  fs.mkdirSync(distSrcPath, { recursive: true });
}

// Write version file
const versionFilePath = path.join(distSrcPath, 'version.js');
fs.writeFileSync(versionFilePath, versionFileContent);

// Also create a TypeScript declaration file
const versionDtsContent = `/**
 * Auto-generated version information type definitions
 */

export interface VersionInfo {
  version: string;
  name: string;
  commit: string;
  ref: string;
  buildTime: string;
  commitsAhead: number;
  nodeVersion: string;
}

export declare const VERSION_INFO: VersionInfo;
export declare const VERSION: string;
export declare const PACKAGE_NAME: string;
export declare const BUILD_TIME: string;
export declare const GIT_COMMIT: string;
export declare const GIT_REF: string;
export declare const COMMITS_AHEAD: number;
export declare function getDisplayVersion(): string;
export declare function isDevBuild(): boolean;
`;

const versionDtsPath = path.join(distSrcPath, 'version.d.ts');
fs.writeFileSync(versionDtsPath, versionDtsContent);

console.log(`âœ… Version ${packageData.version} injected into build`);
console.log(`   - Version file: ${versionFilePath}`);
console.log(`   - Build time: ${versionInfo.buildTime}`);
console.log(`   - Git commit: ${versionInfo.commit}`);
console.log(`   - Git ref: ${versionInfo.ref}`);
