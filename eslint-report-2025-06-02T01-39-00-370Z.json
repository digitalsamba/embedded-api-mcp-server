{
  "timestamp": "2025-06-02T01:39:00.371Z",
  "summary": {
    "totalFiles": 42,
    "totalErrors": 36,
    "totalWarnings": 124,
    "filesWithErrors": 14,
    "filesWithWarnings": 23
  },
  "errorsByRule": {
    "@typescript-eslint/no-unused-vars": {
      "count": 36,
      "filesAffected": 14,
      "examples": [
        {
          "file": "src/digital-samba-api.ts",
          "line": 690,
          "column": 17,
          "message": "'matches' is assigned a value but never used."
        },
        {
          "file": "src/index.ts",
          "line": 13,
          "column": 9,
          "message": "'_originalConsole' is assigned a value but never used."
        },
        {
          "file": "src/index.ts",
          "line": 47,
          "column": 10,
          "message": "'createConnectionManager' is defined but never used."
        }
      ]
    }
  },
  "warningsByRule": {
    "@typescript-eslint/no-explicit-any": {
      "count": 124,
      "filesAffected": 23,
      "examples": [
        {
          "file": "src/digital-samba-api-enhanced.ts",
          "line": 150,
          "column": 57,
          "message": "Unexpected any. Specify a different type."
        },
        {
          "file": "src/digital-samba-api.ts",
          "line": 91,
          "column": 18,
          "message": "Unexpected any. Specify a different type."
        },
        {
          "file": "src/digital-samba-api.ts",
          "line": 126,
          "column": 18,
          "message": "Unexpected any. Specify a different type."
        }
      ]
    }
  },
  "detailedResults": [
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/analytics.ts",
      "messages": [],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/auth.ts",
      "messages": [],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/cache.ts",
      "messages": [],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/circuit-breaker.ts",
      "messages": [],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/connection-manager.ts",
      "messages": [],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/digital-samba-api-circuit-breaker.ts",
      "messages": [],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/digital-samba-api-enhanced.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 150,
          "column": 57,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 150,
          "endColumn": 60,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  5003,
                  5006
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  5003,
                  5006
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 1,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Enhanced Digital Samba API Client Module - Integration File\n * \n * This file extends the base digital-samba-api.ts to integrate the new\n * token-manager, connection-manager, and resource-optimizer features.\n * It enhances the existing API client with improved connection handling,\n * automatic token refresh, and optimized resource usage for high-traffic\n * scenarios.\n * \n * @module digital-samba-api-enhanced\n * @author Digital Samba Team\n * @version 0.1.0\n */\n\n// External dependencies\nimport type { RequestInit } from 'node-fetch';\n\n// Local modules\nimport { DigitalSambaApiClient } from './digital-samba-api.js';\nimport { ConnectionManager } from './connection-manager.js';\nimport { TokenManager } from './token-manager.js';\nimport { ResourceOptimizer } from './resource-optimizer.js';\nimport { MemoryCache } from './cache.js';\nimport logger from './logger.js';\n\n/**\n * Enhanced API client options\n */\nexport interface EnhancedApiClientOptions {\n  /** API base URL */\n  apiUrl?: string;\n  \n  /** API key for authentication */\n  apiKey?: string;\n  \n  /** Whether to enable connection management */\n  enableConnectionManagement?: boolean;\n  \n  /** Whether to enable token management */\n  enableTokenManagement?: boolean;\n  \n  /** Whether to enable resource optimization */\n  enableResourceOptimization?: boolean;\n  \n  /** Connection pool size */\n  connectionPoolSize?: number;\n  \n  /** Cache instance */\n  cache?: MemoryCache;\n}\n\n/**\n * Enhanced Digital Samba API Client\n * \n * This class extends the base DigitalSambaApiClient with improved connection handling,\n * automatic token refresh, and optimized resource usage for high-traffic scenarios.\n */\nexport class EnhancedDigitalSambaApiClient extends DigitalSambaApiClient {\n  private connectionManager?: ConnectionManager;\n  private tokenManagers: Map<string, TokenManager> = new Map();\n  private resourceOptimizer?: ResourceOptimizer;\n  private readonly enabledFeatures: {\n    connectionManagement: boolean;\n    tokenManagement: boolean;\n    resourceOptimization: boolean;\n  };\n  \n  /**\n   * Creates an instance of the Enhanced Digital Samba API Client\n   * \n   * @constructor\n   * @param {string} [apiKey] - Optional API key for direct authentication\n   * @param {string} [apiBaseUrl='https://api.digitalsamba.com/api/v1'] - Base URL for the Digital Samba API\n   * @param {MemoryCache} [cache] - Optional cache instance\n   * @param {EnhancedApiClientOptions} [options] - Additional options\n   */\n  constructor(\n    apiKey?: string, \n    apiBaseUrl: string = 'https://api.digitalsamba.com/api/v1',\n    cache?: MemoryCache,\n    options: EnhancedApiClientOptions = {}\n  ) {\n    super(apiKey, apiBaseUrl, cache);\n    \n    // Set enabled features\n    this.enabledFeatures = {\n      connectionManagement: options.enableConnectionManagement !== false,\n      tokenManagement: options.enableTokenManagement !== false,\n      resourceOptimization: options.enableResourceOptimization !== false\n    };\n    \n    // Initialize connection manager if enabled\n    if (this.enabledFeatures.connectionManagement) {\n      this.connectionManager = new ConnectionManager({\n        apiUrl: apiBaseUrl,\n        poolSize: options.connectionPoolSize || 5\n      });\n      \n      // Set up connection event handlers\n      this.setupConnectionEventHandlers();\n      \n      logger.info('Enhanced API client initialized with connection management', {\n        poolSize: options.connectionPoolSize || 5\n      });\n    }\n    \n    // Initialize resource optimizer if enabled\n    if (this.enabledFeatures.resourceOptimization) {\n      this.resourceOptimizer = new ResourceOptimizer();\n      \n      logger.info('Enhanced API client initialized with resource optimization');\n    }\n    \n    logger.info('Enhanced Digital Samba API Client initialized', {\n      enabledFeatures: this.enabledFeatures\n    });\n  }\n  \n  /**\n   * Set up connection event handlers\n   */\n  private setupConnectionEventHandlers(): void {\n    if (!this.connectionManager) return;\n    \n    // Connection error handler\n    this.connectionManager.on('connection:error', ({ connectionId, error }) => {\n      logger.warn(`Connection error on ${connectionId}: ${error}`);\n    });\n    \n    // Reconnect events\n    this.connectionManager.on('reconnect:scheduled', ({ attempt, delayMs }) => {\n      logger.info(`Reconnect scheduled (attempt ${attempt}), delay: ${delayMs}ms`);\n    });\n    \n    this.connectionManager.on('reconnect:success', ({ successCount, totalConnections }) => {\n      logger.info(`Reconnect successful, ${successCount}/${totalConnections} connections restored`);\n    });\n    \n    this.connectionManager.on('reconnect:failed', ({ attempts, max }) => {\n      logger.error(`Reconnect failed after ${attempts}/${max} attempts`);\n    });\n  }\n  \n  /**\n   * Override the request method to use the connection manager\n   * @param endpoint API endpoint\n   * @param options Request options\n   * @returns Promise resolving to the response data\n   */\n  protected async request<T>(endpoint: string, options: any = {}): Promise<T> {\n    // Use connection manager if enabled\n    if (this.enabledFeatures.connectionManagement && this.connectionManager) {\n      const url = endpoint.startsWith('http') ? endpoint : `${this.apiBaseUrl}${endpoint}`;\n      \n      // Get API key\n      const apiKey = this.getApiKey();\n      \n      // Set authorization header\n      const headers = {\n        'Authorization': `Bearer ${apiKey}`,\n        'Content-Type': 'application/json',\n        ...options.headers\n      };\n      \n      // Execute request through connection manager\n      // Create options compatible with node-fetch\n      const fetchOptions: RequestInit = {\n        method: options.method,\n        headers: headers as Record<string, string>,\n        body: options.body as string | undefined,\n        signal: options.signal,\n        redirect: options.redirect\n      };\n      \n      // Execute request through connection manager\n      const response = await this.connectionManager.fetch(url, fetchOptions);\n      \n      // Handle response\n      if (!response.ok) {\n        const errorText = await response.text();\n        \n        logger.error(`API Error Response: ${errorText}`, {\n          status: response.status,\n          statusText: response.statusText\n        });\n        \n        // Parse error text as JSON if possible\n        let errorData;\n        try {\n          errorData = JSON.parse(errorText);\n        } catch {\n          // Not JSON, use as plain text\n          errorData = { message: errorText };\n        }\n        \n        // Handle specific error types (reusing the parent class logic)\n        throw this.handleErrorResponse(response.status, errorData, errorText, endpoint);\n      }\n      \n      // Return empty object for 204 No Content responses\n      if (response.status === 204) {\n        return {} as T;\n      }\n      \n      // Parse response\n      const responseData = await response.json();\n      \n      // Apply resource optimization if enabled\n      if (this.enabledFeatures.resourceOptimization && this.resourceOptimizer) {\n        return this.resourceOptimizer.compressResponse(responseData) as T;\n      }\n      \n      return responseData as T;\n    } else {\n      // Fall back to parent implementation\n      return super.request<T>(endpoint, options);\n    }\n  }\n  \n  /**\n   * Handle error response - helper method to match parent class behavior\n   */\n  private handleErrorResponse(status: number, errorData: unknown, errorText: string, endpoint: string): Error {\n    // This method simulates the error handling in the parent class\n    // In a real implementation, consider refactoring to avoid duplication\n    \n    const errorMessage = (errorData as { message?: string })?.message || errorText;\n    \n    if (status === 400) {\n      // Validation error\n      return new Error(`Validation error: ${errorMessage}`);\n    } else if (status === 401 || status === 403) {\n      // Authentication error\n      return new Error(`Authentication error: ${errorMessage}`);\n    } else if (status === 404) {\n      // Not Found error\n      const matches = endpoint.match(/\\/([^/]+)\\/([^/]+)/);\n      const resourceType = matches ? matches[1] : 'resource';\n      const resourceId = matches ? matches[2] : 'unknown';\n      \n      return new Error(`Resource not found: ${resourceType} ${resourceId}`);\n    } else {\n      // Generic API error\n      return new Error(`Digital Samba API error (${status}): ${errorMessage}`);\n    }\n  }\n  \n  /**\n   * Create a token manager for a room\n   * @param roomId Room ID\n   * @param sessionId Session ID\n   * @param tokenOptions Token options\n   * @returns Token manager for the room\n   */\n  public createTokenManager(roomId: string, sessionId: string, tokenOptions: unknown = {}): TokenManager {\n    // Skip if token management is disabled\n    if (!this.enabledFeatures.tokenManagement) {\n      throw new Error('Token management is disabled for this client');\n    }\n    \n    // Check if token manager already exists\n    const existingManager = this.tokenManagers.get(roomId);\n    if (existingManager) {\n      return existingManager;\n    }\n    \n    // Create new token manager\n    const tokenOpts = typeof tokenOptions === 'object' && tokenOptions !== null ? tokenOptions : {};\n    const tokenManager = new TokenManager({\n      roomId,\n      tokenOptions: {\n        ...(tokenOpts as Record<string, unknown>),\n        exp: (tokenOpts as { exp?: string }).exp || '60' // Default to 1 hour\n      },\n      apiUrl: this.apiBaseUrl\n    });\n    \n    // Store token manager\n    this.tokenManagers.set(roomId, tokenManager);\n    \n    logger.info('Created token manager', { roomId, sessionId });\n    \n    return tokenManager;\n  }\n  \n  /**\n   * Get a token manager for a room\n   * @param roomId Room ID\n   * @returns Token manager for the room or undefined if not found\n   */\n  public getTokenManager(roomId: string): TokenManager | undefined {\n    return this.tokenManagers.get(roomId);\n  }\n  \n  /**\n   * Generate a room token with automatic refresh\n   * @param roomId Room ID\n   * @param options Token options\n   * @param sessionId Session ID for token context\n   * @returns Promise resolving to token response\n   */\n  public async generateRoomTokenWithRefresh(roomId: string, options: unknown = {}, sessionId: string): Promise<unknown> {\n    // Skip if token management is disabled\n    if (!this.enabledFeatures.tokenManagement) {\n      // Fall back to standard token generation\n      return this.generateRoomToken(roomId, options);\n    }\n    \n    // Get or create token manager\n    let tokenManager = this.getTokenManager(roomId);\n    if (!tokenManager) {\n      tokenManager = this.createTokenManager(roomId, sessionId, options);\n    }\n    \n    // Generate token\n    const token = await tokenManager.generateToken(sessionId, this.getApiKey());\n    \n    return {\n      token: token.token,\n      link: token.link,\n      expiresAt: token.expiresAt.toISOString()\n    };\n  }\n  \n  /**\n   * Batch API requests of the same type\n   * @param batchId Batch identifier\n   * @param key Request key\n   * @param executor Function to execute the batch\n   * @returns Promise resolving to the result\n   */\n  public batchRequest<T>(batchId: string, key: string, executor: (keys: string[]) => Promise<Map<string, T>>): Promise<T> {\n    // Skip if resource optimization is disabled\n    if (!this.enabledFeatures.resourceOptimization || !this.resourceOptimizer) {\n      throw new Error('Resource optimization is disabled for this client');\n    }\n    \n    return this.resourceOptimizer.batchRequest(batchId, key, executor);\n  }\n  \n  /**\n   * Load data incrementally\n   * @param dataLoader Function to load data\n   * @param pageSize Page size\n   * @param maxPages Maximum number of pages to load\n   * @returns Promise resolving to the loaded data\n   */\n  public loadIncrementally<T>(\n    dataLoader: (page: number, pageSize: number) => Promise<{ data: T[], total: number }>,\n    pageSize: number = 20,\n    maxPages: number = 10\n  ): Promise<T[]> {\n    // Skip if resource optimization is disabled\n    if (!this.enabledFeatures.resourceOptimization || !this.resourceOptimizer) {\n      throw new Error('Resource optimization is disabled for this client');\n    }\n    \n    return this.resourceOptimizer.loadIncrementally(dataLoader, pageSize, maxPages);\n  }\n  \n  /**\n   * Get client health status\n   * @returns Whether the client is healthy\n   */\n  public isHealthy(): boolean {\n    if (this.enabledFeatures.connectionManagement && this.connectionManager) {\n      return this.connectionManager.isHealthy();\n    }\n    \n    // Default to true if connection management is disabled\n    return true;\n  }\n  \n  /**\n   * Get client statistics\n   * @returns Client statistics\n   */\n  public getStats() {\n    const stats: Record<string, unknown> = {};\n    \n    if (this.enabledFeatures.connectionManagement && this.connectionManager) {\n      stats.connectionManager = this.connectionManager.getStats();\n    }\n    \n    if (this.enabledFeatures.tokenManagement) {\n      stats.tokenManagers = {\n        count: this.tokenManagers.size,\n        rooms: Array.from(this.tokenManagers.keys())\n      };\n    }\n    \n    if (this.enabledFeatures.resourceOptimization && this.resourceOptimizer) {\n      stats.resourceOptimizer = this.resourceOptimizer.getStats();\n    }\n    \n    return stats;\n  }\n  \n  /**\n   * Clean up resources\n   */\n  public destroy(): void {\n    // Clean up connection manager\n    if (this.connectionManager) {\n      this.connectionManager.destroy();\n    }\n    \n    // Clean up token managers\n    for (const tokenManager of this.tokenManagers.values()) {\n      tokenManager.destroy();\n    }\n    this.tokenManagers.clear();\n    \n    // Clean up resource optimizer\n    if (this.resourceOptimizer) {\n      this.resourceOptimizer.destroy();\n    }\n    \n    logger.info('Enhanced Digital Samba API Client destroyed');\n  }\n}\n\n/**\n * Create an enhanced API client\n * @param apiKey API key\n * @param apiBaseUrl API base URL\n * @param options Additional options\n * @returns A new enhanced API client instance\n */\nexport function createEnhancedApiClient(\n  apiKey?: string,\n  apiBaseUrl?: string,\n  options: EnhancedApiClientOptions = {}\n): EnhancedDigitalSambaApiClient {\n  return new EnhancedDigitalSambaApiClient(\n    apiKey,\n    apiBaseUrl,\n    options.cache,\n    options\n  );\n}\n\n/**\n * Export default enhanced API client utilities\n */\nexport default {\n  EnhancedDigitalSambaApiClient,\n  createEnhancedApiClient\n};\n",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/digital-samba-api-resilient.ts",
      "messages": [],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/digital-samba-api.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 91,
          "column": 18,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 91,
          "endColumn": 21,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  2477,
                  2480
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  2477,
                  2480
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 126,
          "column": 18,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 126,
          "endColumn": 21,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  3400,
                  3403
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  3400,
                  3403
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 235,
          "column": 18,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 235,
          "endColumn": 21,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  6100,
                  6103
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  6100,
                  6103
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 406,
          "column": 32,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 406,
          "endColumn": 35,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  9566,
                  9569
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  9566,
                  9569
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 413,
          "column": 31,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 413,
          "endColumn": 34,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  9707,
                  9710
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  9707,
                  9710
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'matches' is assigned a value but never used.",
          "line": 690,
          "column": 17,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 690,
          "endColumn": 24
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 736,
          "column": 58,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 736,
          "endColumn": 61,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  21592,
                  21595
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  21592,
                  21595
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 736,
          "column": 85,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 736,
          "endColumn": 88,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  21619,
                  21622
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  21619,
                  21622
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 815,
          "column": 58,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 815,
          "endColumn": 61,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  24367,
                  24370
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  24367,
                  24370
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 816,
          "column": 40,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 816,
          "endColumn": 43,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  24414,
                  24417
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  24414,
                  24417
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 822,
          "column": 60,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 822,
          "endColumn": 63,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  24537,
                  24540
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  24537,
                  24540
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 822,
          "column": 90,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 822,
          "endColumn": 93,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  24567,
                  24570
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  24567,
                  24570
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 823,
          "column": 40,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 823,
          "endColumn": 43,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  24614,
                  24617
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  24614,
                  24617
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 884,
          "column": 87,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 884,
          "endColumn": 90,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  26122,
                  26125
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  26122,
                  26125
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 890,
          "column": 25,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 890,
          "endColumn": 28,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  26279,
                  26282
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  26279,
                  26282
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 1851,
          "column": 72,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 1851,
          "endColumn": 75,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  51391,
                  51394
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  51391,
                  51394
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 1852,
          "column": 40,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 1852,
          "endColumn": 43,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  51438,
                  51441
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  51438,
                  51441
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 2134,
          "column": 30,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 2134,
          "endColumn": 33,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  58732,
                  58735
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  58732,
                  58735
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 2145,
          "column": 40,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 2145,
          "endColumn": 43,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  59095,
                  59098
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  59095,
                  59098
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 2151,
          "column": 76,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 2151,
          "endColumn": 79,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  59269,
                  59272
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  59269,
                  59272
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 2158,
          "column": 40,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 2158,
          "endColumn": 43,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  59517,
                  59520
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  59517,
                  59520
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 2164,
          "column": 70,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 2164,
          "endColumn": 73,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  59705,
                  59708
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  59705,
                  59708
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 2165,
          "column": 40,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 2165,
          "endColumn": 43,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  59752,
                  59755
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  59752,
                  59755
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 2173,
          "column": 30,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 2173,
          "endColumn": 33,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  59958,
                  59961
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  59958,
                  59961
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 2184,
          "column": 40,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 2184,
          "endColumn": 43,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  60321,
                  60324
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  60321,
                  60324
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 2190,
          "column": 92,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 2190,
          "endColumn": 95,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  60521,
                  60524
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  60521,
                  60524
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 2197,
          "column": 40,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 2197,
          "endColumn": 43,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  60769,
                  60772
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  60769,
                  60772
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 1,
      "fatalErrorCount": 0,
      "warningCount": 26,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba API Client Module\n * \n * This module provides a comprehensive client for interacting with the Digital Samba API.\n * It offers interfaces for all API entities and a client class that handles authentication,\n * request processing, and provides methods for all available API endpoints.\n * \n * Key features include:\n * - Authentication using either direct API key or the ApiKeyContext for session-based auth\n * - Comprehensive coverage of all Digital Samba API endpoints\n * - Type-safe interfaces for request and response data\n * - Error handling and logging\n * - Support for pagination, filtering, and other API parameters\n * \n * @module digital-samba-api\n * @author Digital Samba Team\n * @version 0.1.0\n */\n// Local modules\nimport apiKeyContext from './auth.js';\nimport { MemoryCache } from './cache.js';\nimport { \n  ApiRequestError, \n  ApiResponseError, \n  AuthenticationError, \n  ResourceNotFoundError,\n  ValidationError \n} from './errors.js';\nimport logger from './logger.js';\n\n// Base interfaces\nexport interface PaginationParams {\n  limit?: number;\n  offset?: number;\n  order?: 'asc' | 'desc';\n  after?: string;\n}\n\nexport interface DateRangeParams {\n  date_start?: string; // Format: 'YYYY-MM-DD'\n  date_end?: string; // Format: 'YYYY-MM-DD'\n}\n\nexport interface ApiResponse<T> {\n  data: T[];\n  total_count: string | number;\n  // Add these properties for compatibility\n  length: number;\n  map: <U>(callback: (value: T, index: number, array: T[]) => U) => U[];\n}\n\n// Room related interfaces\nexport interface Room {\n  id: string;\n  description?: string;\n  topic?: string;\n  friendly_url?: string;\n  privacy: 'public' | 'private';\n  max_participants?: number;\n  max_broadcasters?: number;\n  is_locked?: boolean;\n  external_id?: string;\n  room_url?: string;\n  created_at: string;\n  updated_at: string;\n  \n  // Settings\n  topbar_enabled?: boolean;\n  toolbar_enabled?: boolean;\n  toolbar_position?: 'left' | 'right' | 'bottom';\n  toolbar_color?: string;\n  primary_color?: string;\n  background_color?: string;\n  palette_mode?: 'light' | 'dark';\n  language?: string;\n  language_selection_enabled?: boolean;\n  \n  // Meeting features\n  audio_on_join_enabled?: boolean;\n  video_on_join_enabled?: boolean;\n  screenshare_enabled?: boolean;\n  participants_list_enabled?: boolean;\n  chat_enabled?: boolean;\n  private_chat_enabled?: boolean;\n  recordings_enabled?: boolean;\n  \n  // Breakout room fields\n  is_breakout?: boolean;\n  parent_id?: string;\n  \n  [key: string]: any; // For additional properties\n}\n\nexport interface RoomCreateSettings {\n  name: string;  // Required field\n  description?: string;\n  friendly_url?: string;\n  privacy?: 'public' | 'private';\n  external_id?: string;\n  max_participants?: number;\n  max_broadcasters?: number;\n  is_locked?: boolean;\n  roles?: string[];\n  default_role?: string;\n  \n  // Settings\n  topbar_enabled?: boolean;\n  toolbar_enabled?: boolean;\n  toolbar_position?: 'left' | 'right' | 'bottom';\n  toolbar_color?: string;\n  primary_color?: string;\n  background_color?: string;\n  palette_mode?: 'light' | 'dark';\n  language?: string;\n  language_selection_enabled?: boolean;\n  \n  // Meeting features\n  audio_on_join_enabled?: boolean;\n  video_on_join_enabled?: boolean;\n  screenshare_enabled?: boolean;\n  participants_list_enabled?: boolean;\n  chat_enabled?: boolean;\n  private_chat_enabled?: boolean;\n  recordings_enabled?: boolean;\n  \n  [key: string]: any; // For additional parameters\n}\n\n// Participant related interfaces\nexport interface Participant {\n  id: string;\n  external_id?: string;\n  session_id: string;\n  room_id: string;\n  room_external_id?: string;\n  room_is_deleted: boolean;\n  name: string;\n  role?: string;\n  friendly_url?: string;\n  join_time: string;\n  leave_time?: string;\n  live: boolean;\n}\n\nexport interface ParticipantDetail extends Participant {\n  device?: string;\n  system?: string;\n  browser?: string;\n  e2ee?: boolean;\n  participation_minutes?: number;\n  public_chat_posts?: number;\n  questions?: number;\n  answers?: number;\n}\n\nexport interface TokenOptions {\n  ud?: string;        // External user identifier\n  u?: string;         // User name\n  role?: string;      // User role\n  initials?: string;  // User initials\n  avatar?: string;    // Avatar URL\n  breakoutId?: string; // Breakout room ID\n  nbf?: string;       // Not before date time\n  exp?: string;       // Token expiration in minutes\n}\n\nexport interface TokenResponse {\n  token: string;\n  link: string;\n}\n\n// Recording related interfaces\nexport interface Recording {\n  id: string;\n  name?: string;\n  status: 'AWAITING_START' | 'IN_PROGRESS' | 'PENDING_CONVERSION' | 'READY';\n  room_id: string;\n  external_room_id?: string;\n  friendly_url?: string;\n  privacy?: 'public' | 'private';\n  session_id?: string;\n  participant_id?: string;\n  participant_name?: string;\n  participant_external_id?: string;\n  duration?: number;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface RecordingDownloadLink {\n  link: string;\n  valid_until: string;\n}\n\n// Session related interfaces\nexport interface Session {\n  id: string;\n  start_time: string;\n  end_time?: string;\n  room_id: string;\n  room_external_id?: string;\n  description?: string;\n  friendly_url?: string;\n  room_is_deleted: boolean;\n  participants_live?: number;\n  participants_total: number;\n  participants_max: number;\n  live: boolean;\n}\n\nexport interface SessionStatistics {\n  room_id: string;\n  room_external_id?: string;\n  room_description?: string;\n  room_friendly_url?: string;\n  room_privacy?: string;\n  room_source?: string;\n  room_max_participants?: number;\n  room_is_deleted: boolean;\n  session_id: string;\n  session_duration: number;\n  session_live: boolean;\n  session_start_time: string;\n  session_end_time?: string;\n  participation_minutes: number;\n  desktop_participation_minutes?: number;\n  mobile_participation_minutes?: number;\n  tablet_participation_minutes?: number;\n  smarttv_participation_minutes?: number;\n  broadcasted_minutes?: number;\n  subscribed_minutes?: number;\n  live_participants: number;\n  active_participants: number;\n  max_concurrent_participants?: number;\n  [key: string]: any; // For additional statistics\n}\n\n// Webhook related interfaces\nexport interface Webhook {\n  id: string;\n  endpoint: string;\n  authorization_header?: string;\n  name?: string;\n  events?: string[];\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface WebhookCreateSettings {\n  endpoint: string;\n  name?: string;\n  authorization_header?: string;\n  events: string[];\n}\n\n// Breakout room related interfaces\nexport interface BreakoutRoom extends Room {\n  is_breakout: true;\n  parent_id: string;\n}\n\nexport interface BreakoutRoomCreateSettings {\n  count: number;\n  name_prefix?: string;\n  auto_assign?: boolean;\n  distribution_method?: 'random' | 'manual';\n}\n\nexport interface BreakoutRoomParticipantAssignment {\n  participant_id: string;\n  breakout_id: string | null;\n}\n\n// Meeting scheduling related interfaces\nexport interface ScheduledMeeting {\n  id: string;\n  title: string;\n  description?: string;\n  room_id: string;\n  start_time: string;\n  end_time: string;\n  timezone: string;\n  host_name: string;\n  host_email?: string;\n  participants: {\n    name: string;\n    email: string;\n    role?: string;\n  }[];\n  recurring?: boolean;\n  recurrence_pattern?: string;\n  status: 'scheduled' | 'started' | 'ended' | 'cancelled';\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface MeetingCreateSettings {\n  title: string;\n  description?: string;\n  room_id?: string;\n  room_settings?: {\n    name?: string;\n    privacy?: 'public' | 'private';\n    max_participants?: number;\n  };\n  start_time: string;\n  end_time: string;\n  timezone: string;\n  host_name: string;\n  host_email?: string;\n  participants?: {\n    name: string;\n    email: string;\n    role?: string;\n  }[];\n  recurring?: boolean;\n  recurrence_pattern?: string;\n  send_invitations?: boolean;\n}\n\nexport interface MeetingUpdateSettings {\n  title?: string;\n  description?: string;\n  start_time?: string;\n  end_time?: string;\n  timezone?: string;\n  host_name?: string;\n  host_email?: string;\n  participants?: {\n    name: string;\n    email: string;\n    role?: string;\n  }[];\n  recurring?: boolean;\n  recurrence_pattern?: string;\n  status?: 'scheduled' | 'cancelled';\n  send_updates?: boolean;\n}\n\nexport interface MeetingParticipantAddOptions {\n  participants: {\n    name: string;\n    email: string;\n    role?: string;\n  }[];\n  send_invitations?: boolean;\n}\n\nexport interface MeetingParticipantRemoveOptions {\n  participant_emails: string[];\n  notify_participants?: boolean;\n}\n\nexport interface MeetingReminderOptions {\n  message?: string;\n}\n\nexport interface MeetingAvailabilityOptions {\n  participants: string[];\n  duration_minutes: number;\n  start_date: string;\n  end_date: string;\n  timezone: string;\n  working_hours_start?: number;\n  working_hours_end?: number;\n  min_options?: number;\n}\n\nexport interface AvailableTimeSlot {\n  start_time: string;\n  end_time: string;\n}\n\n// Poll related interfaces\nexport interface Poll {\n  id: string;\n  question: string;\n  status: string;\n  multiple: boolean;\n  anonymous: boolean;\n  options: PollOption[];\n  created_at: string;\n}\n\nexport interface PollOption {\n  id: string;\n  text: string;\n}\n\nexport interface PollCreateSettings {\n  question: string;\n  multiple?: boolean;\n  anonymous?: boolean;\n  options: { text: string }[];\n}\n\n// Role and permission interfaces\nexport interface Role {\n  id: string;\n  name: string;\n  display_name: string;\n  description?: string;\n  default: boolean;\n  created_at: string;\n  updated_at: string;\n  permissions?: Record<string, any>;\n}\n\nexport interface RoleCreateSettings {\n  name: string;\n  display_name: string;\n  description?: string;\n  permissions: Record<string, any>;\n}\n\n// Library related interfaces\nexport interface Library {\n  id: string;\n  external_id?: string;\n  name: string;\n  created_at: string;\n}\n\nexport interface LibraryFolder {\n  id: string;\n  external_id?: string;\n  description?: string;\n  created_at: string;\n}\n\nexport interface LibraryFile {\n  id: string;\n  folder_id?: string;\n  name: string;\n  type: string;\n  size: number;\n  created_at: string;\n}\n\n/**\n * Digital Samba API Client\n * \n * This class provides a comprehensive interface to the Digital Samba API. It handles\n * authentication, request formation, response parsing, and error handling for all\n * available API endpoints. The client supports both direct API key authentication\n * and session-based authentication through the ApiKeyContext.\n * \n * @class DigitalSambaApiClient\n * @example\n * // Create a client with direct API key\n * const client = new DigitalSambaApiClient('your-api-key');\n * \n * // Create a client that uses the ApiKeyContext\n * const sessionClient = new DigitalSambaApiClient();\n * \n * // List all rooms\n * const rooms = await client.listRooms();\n * \n * // Create a room\n * const room = await client.createRoom({\n *   name: 'New Meeting Room',\n *   privacy: 'public'\n * });\n */\nexport class DigitalSambaApiClient {\n  protected apiBaseUrl: string;\n  protected cache?: MemoryCache;\n  \n  /**\n   * Creates an instance of the Digital Samba API Client\n   * \n   * @constructor\n   * @param {string} [apiKey] - Optional API key for direct authentication. If not provided,\n   *                          the client will use the ApiKeyContext for session-based authentication\n   * @param {string} [apiBaseUrl='https://api.digitalsamba.com/api/v1'] - Base URL for the Digital Samba API\n   * @example\n   * // Create a client with the default API URL\n   * const client = new DigitalSambaApiClient('your-api-key');\n   * \n   * // Create a client with a custom API URL\n   * const customClient = new DigitalSambaApiClient('your-api-key', 'https://custom-api.example.com/v1');\n   */\n  constructor(apiKey?: string, apiBaseUrl: string = 'https://api.digitalsamba.com/api/v1', cache?: MemoryCache) {\n    // Store the API key in ApiKeyContext if provided\n    if (apiKey) {\n      // For direct usage outside of MCP context\n      this._apiKey = apiKey;\n    }\n    this.apiBaseUrl = apiBaseUrl;\n    this.cache = cache;\n  }\n  \n  // Private field for storing API key when used outside MCP context\n  private _apiKey?: string;\n  \n  /**\n   * Get the API key from context or direct value\n   * \n   * This method retrieves the API key using a prioritized approach:\n   * 1. First tries to get the API key from the ApiKeyContext (for session-based auth)\n   * 2. If not found, falls back to using the direct API key if provided during construction\n   * 3. If neither source provides an API key, throws an AuthenticationError\n   *\n   * @protected\n   * @returns {string} The API key to use for authentication\n   * @throws {AuthenticationError} If no API key is available from any source\n   */\n  protected getApiKey(): string {\n    // Try to get API key from context first\n    const contextApiKey = apiKeyContext.getCurrentApiKey();\n    if (contextApiKey) {\n      return contextApiKey;\n    }\n    \n    // Fall back to direct API key if set\n    if (this._apiKey) {\n      return this._apiKey;\n    }\n    \n    // No API key available\n    throw new AuthenticationError('No API key found in context or provided directly. Please include an Authorization header with a Bearer token.');\n  }\n  \n  /**\n   * Make an authenticated request to the Digital Samba API\n   * \n   * This method handles all API requests including authentication, error handling, and response parsing.\n   * It automatically adds the Authorization header with the API key, logs request details (excluding sensitive\n   * information), and processes the response. It also handles special cases like 204 No Content responses and\n   * adds array-like properties to ApiResponse objects for easier consumption.\n   *\n   * @protected\n   * @template T - The expected response type\n   * @param {string} endpoint - The API endpoint path (without the base URL)\n   * @param {RequestInit} [options={}] - Request options, including method, body, and additional headers\n   * @returns {Promise<T>} A promise resolving to the parsed response data\n   * @throws {AuthenticationError} If no API key is available for authentication\n   * @throws {ApiRequestError} If a network error occurs during the request\n   * @throws {ApiResponseError} If the API returns a non-2xx status code\n   * @throws {ValidationError} If the API returns a 400 Bad Request with validation errors\n   * @throws {ResourceNotFoundError} If the API returns a 404 Not Found response\n   * @example\n   * // Example internal usage\n   * const rooms = await this.request<ApiResponse<Room>>('/rooms');\n   */\n  protected async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {\n    // Handle case where endpoint is already a full URL (starts with http:// or https://)\n    const url = endpoint.startsWith('http') ? endpoint : `${this.apiBaseUrl}${endpoint}`;\n    const method = options.method || 'GET';\n    const isCacheable = this.cache && method === 'GET';\n    \n    // Generate a cache key based on endpoint and API key (to avoid cross-client leakage)\n    const cacheNamespace = 'api';\n    const cacheKey = endpoint;\n    \n    // Check cache first for GET requests\n    if (isCacheable) {\n      const cachedResponse = this.cache.get(cacheNamespace, cacheKey);\n      if (cachedResponse) {\n        logger.debug(`Cache hit for ${endpoint}`);\n        \n        // Record cache hit in metrics if available\n        try {\n          const metricsRegistry = await import('./metrics.js').then(m => m.default);\n          metricsRegistry.cacheHitsTotal.inc({ namespace: cacheNamespace });\n        } catch (error) {\n          // Ignore metrics errors - they shouldn't affect normal operation\n        }\n        \n        return cachedResponse.value as T;\n      } else if (this.cache) {\n        // Record cache miss in metrics if available\n        try {\n          const metricsRegistry = await import('./metrics.js').then(m => m.default);\n          metricsRegistry.cacheMissesTotal.inc({ namespace: cacheNamespace });\n        } catch (error) {\n          // Ignore metrics errors\n        }\n      }\n    }\n    \n    // Start timer for metrics\n    const startTime = Date.now();\n    let metricsLabels = { endpoint, method: method.toLowerCase() };\n    \n    try {\n      const apiKey = this.getApiKey();\n      \n      const headers = {\n        'Authorization': `Bearer ${apiKey}`,\n        'Content-Type': 'application/json',\n        ...options.headers\n      };\n      \n      // Log the request details (excluding sensitive info)\n      logger.debug(`Making API request to: ${url}`, {\n        method,\n        headers: { ...headers, Authorization: '[REDACTED]' },\n        cacheStatus: isCacheable ? 'miss' : 'disabled'\n      });\n      \n      // Track API request in metrics\n      try {\n        const metricsRegistry = await import('./metrics.js').then(m => m.default);\n        metricsRegistry.apiRequestsTotal.inc(metricsLabels);\n      } catch (error) {\n        // Ignore metrics errors\n      }\n      \n      let response;\n      try {\n        response = await fetch(url, {\n          ...options,\n          headers\n        });\n      } catch (error) {\n        // Handle network errors\n        logger.error('Network error in API request', {\n          url,\n          method,\n          error: error instanceof Error ? error.message : String(error)\n        });\n        \n        // Track API error in metrics\n        try {\n          const metricsRegistry = await import('./metrics.js').then(m => m.default);\n          metricsRegistry.apiErrorsTotal.inc({\n            ...metricsLabels,\n            error_type: 'network_error'\n          });\n        } catch (metricsError) {\n          // Ignore metrics errors\n        }\n        \n        throw new ApiRequestError(\n          `Network error while connecting to Digital Samba API: ${error instanceof Error ? error.message : String(error)}`,\n          { cause: error instanceof Error ? error : undefined }\n        );\n      }\n      \n      // Log response details\n      logger.debug(`Response status: ${response.status} ${response.statusText}`);\n      \n      // Update metrics labels with status code\n      metricsLabels = { ...metricsLabels, status: response.status.toString() } as typeof metricsLabels;\n      \n      if (!response.ok) {\n        const errorText = await response.text();\n        logger.error(`API Error Response: ${errorText}`, {\n          status: response.status,\n          statusText: response.statusText\n        });\n        \n        // Track API error in metrics\n        try {\n          const metricsRegistry = await import('./metrics.js').then(m => m.default);\n          metricsRegistry.apiErrorsTotal.inc({\n            ...metricsLabels,\n            error_type: `status_${response.status}`\n          });\n        } catch (metricsError) {\n          // Ignore metrics errors\n        }\n        \n        // Parse error text as JSON if possible\n        let errorData;\n        try {\n          errorData = JSON.parse(errorText);\n        } catch {\n          // Not JSON, use as plain text\n          errorData = { message: errorText };\n        }\n        \n        // Handle specific error types based on status code\n        if (response.status === 400) {\n          // Bad Request - typically validation errors\n          const validationErrors = errorData.errors || {};\n          throw new ValidationError(\n            `Validation error: ${errorData.message || errorText}`,\n            { validationErrors: validationErrors }\n          );\n        } else if (response.status === 401 || response.status === 403) {\n          // Authentication or authorization error\n          throw new AuthenticationError(\n            `Authentication error: ${errorData.message || errorText}`\n          );\n        } else if (response.status === 404) {\n          // Not Found error\n          // Try to extract resource type and ID from the endpoint\n          const matches = endpoint.match(/\\/([^/]+)\\/([^/]+)/);\n          // Resource type and ID extraction removed - not used in error message\n          \n          // For backwards compatibility with tests, throw a generic API error\n          throw new ApiResponseError(\n            `Digital Samba API error (${response.status}): ${errorData.message || errorText}`,\n            {\n              statusCode: response.status,\n              apiErrorMessage: errorData.message || errorText\n            }\n          );\n        } else {\n          // Generic API error\n          throw new ApiResponseError(\n            `Digital Samba API error (${response.status}): ${errorData.message || errorText}`,\n            {\n              statusCode: response.status,\n              apiErrorMessage: errorData.message || errorText,\n              apiErrorData: errorData\n            }\n          );\n        }\n      }\n      \n      // Return empty object for 204 No Content responses\n      if (response.status === 204) {\n        // Record request duration in metrics\n        try {\n          const duration = (Date.now() - startTime) / 1000; // Convert to seconds\n          const metricsRegistry = await import('./metrics.js').then(m => m.default);\n          metricsRegistry.apiRequestDuration.observe(metricsLabels, duration);\n        } catch (error) {\n          // Ignore metrics errors\n        }\n        \n        return {} as T;\n      }\n      \n      const responseData = await response.json();\n      \n      // Add array-like properties to ApiResponse objects\n      if (responseData && responseData.data && Array.isArray(responseData.data)) {\n        // Add length property\n        responseData.length = responseData.data.length;\n        \n        // Add map function that forwards to the data array\n        responseData.map = function<U>(callback: (value: any, index: number, array: any[]) => U): U[] {\n          return this.data.map(callback);\n        };\n      }\n      \n      // Record request duration in metrics\n      try {\n        const duration = (Date.now() - startTime) / 1000; // Convert to seconds\n        const metricsRegistry = await import('./metrics.js').then(m => m.default);\n        metricsRegistry.apiRequestDuration.observe(metricsLabels, duration);\n      } catch (error) {\n        // Ignore metrics errors\n      }\n      \n      // Store successful GET responses in cache\n      if (isCacheable) {\n        logger.debug(`Caching response for ${endpoint}`);\n        this.cache!.set(cacheNamespace, cacheKey, responseData);\n        \n        // Update cache metrics\n        try {\n          const metricsRegistry = await import('./metrics.js').then(m => m.default);\n          metricsRegistry.cacheEntriesCount.inc({ namespace: cacheNamespace });\n        } catch (error) {\n          // Ignore metrics errors\n        }\n      }\n      \n      return responseData;\n    } catch (error) {\n      // Record request duration in metrics even for errors\n      try {\n        const duration = (Date.now() - startTime) / 1000; // Convert to seconds\n        const metricsRegistry = await import('./metrics.js').then(m => m.default);\n        metricsRegistry.apiRequestDuration.observe(metricsLabels, duration);\n      } catch (metricsError) {\n        // Ignore metrics errors\n      }\n      \n      // Catch and re-throw errors that aren't already one of our custom types\n      if (!(error instanceof AuthenticationError) && \n          !(error instanceof ApiRequestError) && \n          !(error instanceof ApiResponseError) &&\n          !(error instanceof ValidationError) &&\n          !(error instanceof ResourceNotFoundError)) {\n        \n        logger.error('Unexpected error in API request', {\n          url,\n          method: options.method || 'GET',\n          error: error instanceof Error ? error.message : String(error)\n        });\n        \n        // Track API error in metrics\n        try {\n          const metricsRegistry = await import('./metrics.js').then(m => m.default);\n          metricsRegistry.apiErrorsTotal.inc({\n            ...metricsLabels,\n            error_type: 'unexpected'\n          });\n        } catch (metricsError) {\n          // Ignore metrics errors\n        }\n        \n        throw new ApiRequestError(\n          `Unexpected error in Digital Samba API request: ${error instanceof Error ? error.message : String(error)}`,\n          { cause: error instanceof Error ? error : undefined }\n        );\n      }\n      \n      // Re-throw custom error types\n      throw error;\n    }\n  }\n  \n  // Default Room Settings\n  \n  /**\n   * Get default room settings\n   */\n  async getDefaultRoomSettings(): Promise<Record<string, any>> {\n    return this.request<Record<string, any>>('');\n  }\n  \n  /**\n   * Update default room settings\n   */\n  async updateDefaultRoomSettings(settings: Record<string, any>): Promise<Record<string, any>> {\n    return this.request<Record<string, any>>('', {\n      method: 'PATCH',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  // Rooms\n  \n  /**\n   * List all rooms\n   */\n  async listRooms(params?: PaginationParams): Promise<ApiResponse<Room>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<Room>>(`/rooms${query}`);\n  }\n  \n  /**\n   * Get details for a specific room\n   */\n  async getRoom(roomId: string): Promise<Room> {\n    return this.request<Room>(`/rooms/${roomId}`);\n  }\n  \n  /**\n   * Create a new room\n   */\n  async createRoom(settings: RoomCreateSettings): Promise<Room> {\n    // Make sure name is defined (it's required by the API)\n    const roomSettings = {\n      ...settings,\n      name: settings.name || 'New Meeting Room'\n    };\n\n    return this.request<Room>('/rooms', {\n      method: 'POST',\n      body: JSON.stringify(roomSettings)\n    });\n  }\n  \n  /**\n   * Update an existing room\n   */\n  async updateRoom(roomId: string, settings: Partial<RoomCreateSettings>): Promise<Room> {\n    return this.request<Room>(`/rooms/${roomId}`, {\n      method: 'PATCH',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Delete a room\n   */\n  async deleteRoom(roomId: string, options?: { delete_resources?: boolean }): Promise<any> {\n    // Invalidate cache when deleting resources\n    if (this.cache) {\n      this.cache.invalidateNamespace('api');\n    }\n    \n    return this.request<any>(`/rooms/${roomId}`, {\n      method: 'DELETE',\n      body: options ? JSON.stringify(options) : undefined\n    });\n  }\n  \n  /**\n   * Generate a token for joining a room\n   */\n  async generateRoomToken(roomId: string, options: TokenOptions): Promise<TokenResponse> {\n    return this.request<TokenResponse>(`/rooms/${roomId}/token`, {\n      method: 'POST',\n      body: JSON.stringify(options)\n    });\n  }\n  \n  /**\n   * Delete all resources for a room\n   */\n  async deleteRoomResources(roomId: string): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/resources`, {\n      method: 'DELETE'\n    });\n  }\n  \n  // Live Participants\n  \n  /**\n   * Get rooms with live participants count\n   */\n  async getLiveRooms(params?: PaginationParams): Promise<ApiResponse<{\n    id: string;\n    external_id?: string;\n    start_time: string;\n    session_duration: number;\n    live_participants: number;\n  }>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<{\n      id: string;\n      external_id?: string;\n      start_time: string;\n      session_duration: number;\n      live_participants: number;\n    }>>(`/rooms/live${query}`);\n  }\n  \n  /**\n   * Get rooms with live participants data\n   */\n  async getLiveRoomsWithParticipants(params?: PaginationParams): Promise<ApiResponse<{\n    id: string;\n    external_id?: string;\n    start_time: string;\n    session_duration: number;\n    live_participants: {\n      id: string;\n      external_id?: string;\n      name: string;\n      role: string;\n      join_time: string;\n    }[];\n  }>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<{\n      id: string;\n      external_id?: string;\n      start_time: string;\n      session_duration: number;\n      live_participants: {\n        id: string;\n        external_id?: string;\n        name: string;\n        role: string;\n        join_time: string;\n      }[];\n    }>>(`/rooms/live/participants${query}`);\n  }\n  \n  /**\n   * Get single room with live participants count\n   */\n  async getRoomLiveParticipantsCount(roomId: string): Promise<{\n    id: string;\n    external_id?: string;\n    start_time: string;\n    session_duration: number;\n    live_participants: number;\n  }> {\n    return this.request<{\n      id: string;\n      external_id?: string;\n      start_time: string;\n      session_duration: number;\n      live_participants: number;\n    }>(`/rooms/${roomId}/live`);\n  }\n  \n  /**\n   * Get single room with live participants data\n   */\n  async getRoomLiveParticipantsData(roomId: string): Promise<{\n    id: string;\n    external_id?: string;\n    start_time: string;\n    session_duration: number;\n    live_participants: {\n      id: string;\n      external_id?: string;\n      name: string;\n      role: string;\n      join_time: string;\n    }[];\n  }> {\n    return this.request<{\n      id: string;\n      external_id?: string;\n      start_time: string;\n      session_duration: number;\n      live_participants: {\n        id: string;\n        external_id?: string;\n        name: string;\n        role: string;\n        join_time: string;\n      }[];\n    }>(`/rooms/${roomId}/live/participants`);\n  }\n  \n  // Participants\n  \n  /**\n   * List all participants\n   */\n  async listParticipants(params?: PaginationParams & DateRangeParams & {\n    live?: boolean;\n    room_id?: string;\n    session_id?: string;\n  }): Promise<ApiResponse<Participant>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<Participant>>(`/participants${query}`);\n  }\n  \n  /**\n   * Get details for a specific participant\n   */\n  async getParticipant(participantId: string): Promise<ParticipantDetail> {\n    return this.request<ParticipantDetail>(`/participants/${participantId}`);\n  }\n  \n  /**\n   * List participants in a room\n   */\n  async listRoomParticipants(roomId: string, params?: PaginationParams & DateRangeParams & {\n    live?: boolean;\n    session_id?: string;\n  }): Promise<ApiResponse<Participant>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<Participant>>(`/rooms/${roomId}/participants${query}`);\n  }\n  \n  /**\n   * List participants in a session\n   */\n  async listSessionParticipants(sessionId: string, params?: PaginationParams & DateRangeParams & {\n    live?: boolean;\n  }): Promise<ApiResponse<Participant>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<Participant>>(`/sessions/${sessionId}/participants${query}`);\n  }\n  \n  /**\n   * Phone participants joined\n   */\n  async phoneParticipantsJoined(roomId: string, participants: {\n    call_id: string;\n    name?: string;\n    caller_number?: string;\n    external_id?: string;\n  }[]): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/phone-participants/joined`, {\n      method: 'POST',\n      body: JSON.stringify(participants)\n    });\n  }\n  \n  /**\n   * Phone participants left\n   */\n  async phoneParticipantsLeft(roomId: string, callIds: string[]): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/phone-participants/left`, {\n      method: 'POST',\n      body: JSON.stringify(callIds)\n    });\n  }\n  \n  // Recordings\n  \n  /**\n   * List all recordings\n   */\n  async listRecordings(params?: PaginationParams & {\n    room_id?: string;\n    session_id?: string;\n    status?: 'IN_PROGRESS' | 'PENDING_CONVERSION' | 'READY';\n  }): Promise<ApiResponse<Recording>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<Recording>>(`/recordings${query}`);\n  }\n  \n  /**\n   * List archived recordings\n   */\n  async listArchivedRecordings(params?: PaginationParams & {\n    room_id?: string;\n  }): Promise<ApiResponse<Recording>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<Recording>>(`/recordings/archived${query}`);\n  }\n  \n  /**\n   * Get a specific recording\n   */\n  async getRecording(recordingId: string): Promise<Recording> {\n    return this.request<Recording>(`/recordings/${recordingId}`);\n  }\n  \n  /**\n   * Delete a recording\n   */\n  async deleteRecording(recordingId: string): Promise<void> {\n    await this.request<void>(`/recordings/${recordingId}`, {\n      method: 'DELETE'\n    });\n  }\n  \n  /**\n   * Get a download link for a recording\n   */\n  async getRecordingDownloadLink(recordingId: string, validForMinutes?: number): Promise<RecordingDownloadLink> {\n    const queryParams = new URLSearchParams();\n    if (validForMinutes !== undefined) {\n      queryParams.append('valid_for_minutes', String(validForMinutes));\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<RecordingDownloadLink>(`/recordings/${recordingId}/download${query}`);\n  }\n  \n  /**\n   * Archive a recording\n   */\n  async archiveRecording(recordingId: string): Promise<void> {\n    await this.request<void>(`/recordings/${recordingId}/archive`, {\n      method: 'POST'\n    });\n  }\n  \n  /**\n   * Unarchive a recording\n   */\n  async unarchiveRecording(recordingId: string): Promise<void> {\n    await this.request<void>(`/recordings/${recordingId}/unarchive`, {\n      method: 'POST'\n    });\n  }\n  \n  /**\n   * Start recording in a room\n   */\n  async startRecording(roomId: string): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/recordings/start`, {\n      method: 'POST'\n    });\n  }\n  \n  /**\n   * Stop recording in a room\n   */\n  async stopRecording(roomId: string): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/recordings/stop`, {\n      method: 'POST'\n    });\n  }\n  \n  // Webhooks\n  \n  /**\n   * List available event types for webhooks\n   */\n  async listWebhookEvents(): Promise<string[]> {\n    return this.request<string[]>('/events');\n  }\n  \n  /**\n   * List all webhooks\n   */\n  async listWebhooks(params?: PaginationParams): Promise<ApiResponse<Webhook>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<Webhook>>(`/webhooks${query}`);\n  }\n  \n  /**\n   * Create a new webhook\n   */\n  async createWebhook(settings: WebhookCreateSettings): Promise<Webhook> {\n    return this.request<Webhook>('/webhooks', {\n      method: 'POST',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Get a specific webhook\n   */\n  async getWebhook(webhookId: string): Promise<Webhook> {\n    return this.request<Webhook>(`/webhooks/${webhookId}`);\n  }\n  \n  /**\n   * Update a webhook\n   */\n  async updateWebhook(webhookId: string, settings: Partial<WebhookCreateSettings>): Promise<Webhook> {\n    return this.request<Webhook>(`/webhooks/${webhookId}`, {\n      method: 'PATCH',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Delete a webhook\n   */\n  async deleteWebhook(webhookId: string): Promise<void> {\n    await this.request<void>(`/webhooks/${webhookId}`, {\n      method: 'DELETE'\n    });\n  }\n  \n  // Roles and Permissions\n  \n  /**\n   * List all roles\n   */\n  async listRoles(params?: PaginationParams): Promise<ApiResponse<Role>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<Role>>(`/roles${query}`);\n  }\n  \n  /**\n   * Create a new role\n   */\n  async createRole(settings: RoleCreateSettings): Promise<Role> {\n    return this.request<Role>('/roles', {\n      method: 'POST',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Get a specific role\n   */\n  async getRole(roleId: string): Promise<Role> {\n    return this.request<Role>(`/roles/${roleId}`);\n  }\n  \n  /**\n   * Update a role\n   */\n  async updateRole(roleId: string, settings: Partial<RoleCreateSettings>): Promise<Role> {\n    return this.request<Role>(`/roles/${roleId}`, {\n      method: 'PATCH',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Delete a role\n   */\n  async deleteRole(roleId: string): Promise<void> {\n    await this.request<void>(`/roles/${roleId}`, {\n      method: 'DELETE'\n    });\n  }\n  \n  /**\n   * List all available permissions\n   */\n  async listPermissions(): Promise<string[]> {\n    return this.request<string[]>('/permissions');\n  }\n  \n  // Sessions\n  \n  /**\n   * List all sessions\n   */\n  async listSessions(params?: PaginationParams & DateRangeParams & {\n    live?: boolean;\n    room_id?: string;\n  }): Promise<ApiResponse<Session>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<Session>>(`/sessions${query}`);\n  }\n  \n  /**\n   * List sessions for a specific room\n   */\n  async listRoomSessions(roomId: string, params?: PaginationParams & DateRangeParams & {\n    live?: boolean;\n  }): Promise<ApiResponse<Session>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<Session>>(`/rooms/${roomId}/sessions${query}`);\n  }\n  \n  /**\n   * Get session statistics\n   */\n  async getSessionStatistics(sessionId: string, metrics?: string): Promise<SessionStatistics> {\n    const queryParams = new URLSearchParams();\n    if (metrics) {\n      queryParams.append('metrics', metrics);\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<SessionStatistics>(`/sessions/${sessionId}${query}`);\n  }\n  \n  /**\n   * End a live session\n   */\n  async endSession(sessionId: string): Promise<void> {\n    await this.request<void>(`/sessions/${sessionId}/end`, {\n      method: 'POST'\n    });\n  }\n  \n  /**\n   * Get session summary\n   */\n  async getSessionSummary(sessionId: string): Promise<{\n    job_id: string;\n    status: 'IN_PROGRESS' | 'READY';\n    summary: string;\n  }> {\n    return this.request<{\n      job_id: string;\n      status: 'IN_PROGRESS' | 'READY';\n      summary: string;\n    }>(`/sessions/${sessionId}/summary`);\n  }\n  \n  \n  /**\n   * Delete session data\n   */\n  async deleteSessionData(sessionId: string, dataType: 'chat' | 'questions' | 'summaries' | 'transcripts' | 'polls' | 'recordings' | 'resources'): Promise<void> {\n    await this.request<void>(`/sessions/${sessionId}/${dataType}`, {\n      method: 'DELETE'\n    });\n  }\n  \n  // Chat and Q&A\n  \n  /**\n   * Get chat messages\n   */\n  async getChatMessages(roomId: string, params?: PaginationParams & {\n    session_id?: string;\n  }): Promise<ApiResponse<{\n    id: string;\n    message: string;\n    participant_id: string;\n    external_participant_id?: string;\n    participant_name: string;\n    breakout_id?: string;\n    created_at: string;\n  }>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<{\n      id: string;\n      message: string;\n      participant_id: string;\n      external_participant_id?: string;\n      participant_name: string;\n      breakout_id?: string;\n      created_at: string;\n    }>>(`/rooms/${roomId}/chat${query}`);\n  }\n  \n  /**\n   * Delete chat messages\n   */\n  async deleteChatMessages(roomId: string): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/chat`, {\n      method: 'DELETE'\n    });\n  }\n  \n  /**\n   * Get Q&A\n   */\n  async getQuestionsAndAnswers(roomId: string, params?: PaginationParams & {\n    session_id?: string;\n  }): Promise<ApiResponse<{\n    id: string;\n    question: string;\n    participant_id: string;\n    external_participant_id?: string;\n    participant_name: string;\n    created_at: string;\n    answers: {\n      id: string;\n      answer: string;\n      participant_id: string;\n      external_participant_id?: string;\n      participant_name: string;\n      created_at: string;\n    }[];\n  }>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<{\n      id: string;\n      question: string;\n      participant_id: string;\n      external_participant_id?: string;\n      participant_name: string;\n      created_at: string;\n      answers: {\n        id: string;\n        answer: string;\n        participant_id: string;\n        external_participant_id?: string;\n        participant_name: string;\n        created_at: string;\n      }[];\n    }>>(`/rooms/${roomId}/questions${query}`);\n  }\n  \n  /**\n   * Delete Q&A\n   */\n  async deleteQA(roomId: string): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/questions`, {\n      method: 'DELETE'\n    });\n  }\n  \n  // Polls\n  \n  /**\n   * Get polls\n   */\n  async getPolls(roomId: string, params?: PaginationParams): Promise<Poll[]> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<Poll[]>(`/rooms/${roomId}/polls${query}`);\n  }\n  \n  /**\n   * Create a poll\n   */\n  async createPoll(roomId: string, settings: PollCreateSettings): Promise<Poll> {\n    return this.request<Poll>(`/rooms/${roomId}/polls`, {\n      method: 'POST',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Get a specific poll\n   */\n  async getPoll(roomId: string, pollId: string): Promise<Poll> {\n    return this.request<Poll>(`/rooms/${roomId}/polls/${pollId}`);\n  }\n  \n  /**\n   * Update a poll\n   */\n  async updatePoll(roomId: string, pollId: string, settings: Partial<PollCreateSettings>): Promise<Poll> {\n    return this.request<Poll>(`/rooms/${roomId}/polls/${pollId}`, {\n      method: 'PATCH',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Delete a poll\n   */\n  async deletePoll(roomId: string, pollId: string): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/polls/${pollId}`, {\n      method: 'DELETE'\n    });\n  }\n  \n  /**\n   * Get poll results\n   */\n  async getPollResults(roomId: string, pollId: string, sessionId?: string): Promise<{\n    id: string;\n    session_id: string;\n    question: string;\n    status: string;\n    started: string;\n    ended?: string;\n    votes: number;\n    options: {\n      id: string;\n      text: string;\n      voted: number;\n      voters: {\n        id: string;\n        name: string;\n      }[];\n    }[];\n  }[]> {\n    const queryParams = new URLSearchParams();\n    if (sessionId) {\n      queryParams.append('session_id', sessionId);\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<{\n      id: string;\n      session_id: string;\n      question: string;\n      status: string;\n      started: string;\n      ended?: string;\n      votes: number;\n      options: {\n        id: string;\n        text: string;\n        voted: number;\n        voters: {\n          id: string;\n          name: string;\n        }[];\n      }[];\n    }[]>(`/rooms/${roomId}/polls/${pollId}/results${query}`);\n  }\n  \n  /**\n   * Export polls\n   */\n  async exportPolls(roomId: string, options?: {\n    session_id?: string;\n    format?: 'txt' | 'json';\n  }): Promise<string> {\n    const queryParams = new URLSearchParams();\n    if (options) {\n      Object.entries(options).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    \n    const apiKey = this.getApiKey();\n    const response = await fetch(`${this.apiBaseUrl}/rooms/${roomId}/polls/export${query}`, {\n      headers: {\n        'Authorization': `Bearer ${apiKey}`\n      }\n    });\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Digital Samba API error (${response.status}): ${errorText}`);\n    }\n    \n    return response.text();\n  }\n\n  /**\n   * Export chat messages\n   */\n  async exportChatMessages(roomId: string, options?: {\n    session_id?: string;\n    format?: 'txt' | 'json';\n  }): Promise<string> {\n    const queryParams = new URLSearchParams();\n    if (options) {\n      Object.entries(options).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    \n    const apiKey = this.getApiKey();\n    const response = await fetch(`${this.apiBaseUrl}/rooms/${roomId}/chat/export${query}`, {\n      headers: {\n        'Authorization': `Bearer ${apiKey}`\n      }\n    });\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Digital Samba API error (${response.status}): ${errorText}`);\n    }\n    \n    return response.text();\n  }\n\n  /**\n   * Export Q&A (questions and answers)\n   */\n  async exportQA(roomId: string, options?: {\n    session_id?: string;\n    format?: 'txt' | 'json';\n  }): Promise<string> {\n    const queryParams = new URLSearchParams();\n    if (options) {\n      Object.entries(options).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    \n    const apiKey = this.getApiKey();\n    const response = await fetch(`${this.apiBaseUrl}/rooms/${roomId}/questions/export${query}`, {\n      headers: {\n        'Authorization': `Bearer ${apiKey}`\n      }\n    });\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Digital Samba API error (${response.status}): ${errorText}`);\n    }\n    \n    return response.text();\n  }\n\n  /**\n   * Export session transcripts\n   */\n  async exportTranscripts(sessionId: string, options?: {\n    format?: 'txt' | 'json';\n  }): Promise<string> {\n    const queryParams = new URLSearchParams();\n    if (options) {\n      Object.entries(options).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    \n    const apiKey = this.getApiKey();\n    const response = await fetch(`${this.apiBaseUrl}/sessions/${sessionId}/transcripts/export${query}`, {\n      headers: {\n        'Authorization': `Bearer ${apiKey}`\n      }\n    });\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Digital Samba API error (${response.status}): ${errorText}`);\n    }\n    \n    return response.text();\n  }\n  \n  // Libraries\n  \n  /**\n   * List all libraries\n   */\n  async listLibraries(params?: PaginationParams): Promise<ApiResponse<Library>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<Library>>(`/libraries${query}`);\n  }\n  \n  /**\n   * Create a new library\n   */\n  async createLibrary(settings: {\n    name?: string;\n    external_id: string;\n  }): Promise<Library> {\n    return this.request<Library>('/libraries', {\n      method: 'POST',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Get a specific library\n   */\n  async getLibrary(libraryId: string): Promise<Library> {\n    return this.request<Library>(`/libraries/${libraryId}`);\n  }\n  \n  /**\n   * Update a library\n   */\n  async updateLibrary(libraryId: string, settings: {\n    name?: string;\n    external_id?: string;\n  }): Promise<Library> {\n    return this.request<Library>(`/libraries/${libraryId}`, {\n      method: 'PATCH',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Delete a library\n   */\n  async deleteLibrary(libraryId: string): Promise<void> {\n    await this.request<void>(`/libraries/${libraryId}`, {\n      method: 'DELETE'\n    });\n  }\n  \n  /**\n   * Get library hierarchy\n   */\n  async getLibraryHierarchy(libraryId: string): Promise<Record<string, any>> {\n    return this.request<Record<string, any>>(`/libraries/${libraryId}/hierarchy`);\n  }\n  \n  /**\n   * List library folders\n   */\n  async listLibraryFolders(libraryId: string, params?: PaginationParams): Promise<ApiResponse<LibraryFolder>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<LibraryFolder>>(`/libraries/${libraryId}/folders${query}`);\n  }\n  \n  /**\n   * Create a library folder\n   */\n  async createLibraryFolder(libraryId: string, settings: {\n    name?: string;\n    parent_id?: string;\n  }): Promise<LibraryFolder> {\n    return this.request<LibraryFolder>(`/libraries/${libraryId}/folders`, {\n      method: 'POST',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Get a specific library folder\n   */\n  async getLibraryFolder(libraryId: string, folderId: string): Promise<LibraryFolder> {\n    return this.request<LibraryFolder>(`/libraries/${libraryId}/folders/${folderId}`);\n  }\n  \n  /**\n   * Update a library folder\n   */\n  async updateLibraryFolder(libraryId: string, folderId: string, settings: {\n    name?: string;\n    parent_id?: string;\n  }): Promise<LibraryFolder> {\n    return this.request<LibraryFolder>(`/libraries/${libraryId}/folders/${folderId}`, {\n      method: 'PATCH',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Delete a library folder\n   */\n  async deleteLibraryFolder(libraryId: string, folderId: string): Promise<void> {\n    await this.request<void>(`/libraries/${libraryId}/folders/${folderId}`, {\n      method: 'DELETE'\n    });\n  }\n  \n  /**\n   * List library files\n   */\n  async listLibraryFiles(libraryId: string, params?: PaginationParams): Promise<LibraryFile[]> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<LibraryFile[]>(`/libraries/${libraryId}/files${query}`);\n  }\n  \n  /**\n   * Create a new library file (get upload URL and token)\n   */\n  async createLibraryFile(libraryId: string, settings: {\n    name: string;\n    folder_id?: string;\n  }): Promise<{\n    file_id: string;\n    file_name: string;\n    external_storage_url: string;\n    token: string;\n    expiration_timestamp: number;\n  }> {\n    return this.request<{\n      file_id: string;\n      file_name: string;\n      external_storage_url: string;\n      token: string;\n      expiration_timestamp: number;\n    }>(`/libraries/${libraryId}/files`, {\n      method: 'POST',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Get a specific library file\n   */\n  async getLibraryFile(libraryId: string, fileId: string): Promise<LibraryFile> {\n    return this.request<LibraryFile>(`/libraries/${libraryId}/files/${fileId}`);\n  }\n  \n  /**\n   * Update a library file\n   */\n  async updateLibraryFile(libraryId: string, fileId: string, settings: {\n    name?: string;\n    folder_id?: string;\n  }): Promise<LibraryFile> {\n    return this.request<LibraryFile>(`/libraries/${libraryId}/files/${fileId}`, {\n      method: 'PATCH',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Delete a library file\n   */\n  async deleteLibraryFile(libraryId: string, fileId: string): Promise<void> {\n    await this.request<void>(`/libraries/${libraryId}/files/${fileId}`, {\n      method: 'DELETE'\n    });\n  }\n  \n  /**\n   * Get file links\n   */\n  async getFileLinks(libraryId: string, fileId: string): Promise<{\n    pages: {\n      url: string;\n      thumbnail_url: string;\n    }[];\n  }> {\n    return this.request<{\n      pages: {\n        url: string;\n        thumbnail_url: string;\n      }[];\n    }>(`/libraries/${libraryId}/files/${fileId}/links`);\n  }\n  \n  // Webapps\n  \n  /**\n   * Create a webapp in a library\n   */\n  async createWebapp(libraryId: string, settings: {\n    name: string;\n    folder_id?: string;\n  }): Promise<{\n    file_id: string;\n    file_name: string;\n    external_storage_url: string;\n    token: string;\n    expiration_timestamp: number;\n  }> {\n    return this.request<{\n      file_id: string;\n      file_name: string;\n      external_storage_url: string;\n      token: string;\n      expiration_timestamp: number;\n    }>(`/libraries/${libraryId}/webapps`, {\n      method: 'POST',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  // Whiteboards\n  \n  /**\n   * Create a whiteboard in a library\n   */\n  async createWhiteboard(libraryId: string, settings: {\n    name: string;\n    folder_id?: string;\n  }): Promise<{\n    file_id: string;\n    file_name: string;\n    external_storage_url: string;\n    token: string;\n    expiration_timestamp: number;\n  }> {\n    return this.request<{\n      file_id: string;\n      file_name: string;\n      external_storage_url: string;\n      token: string;\n      expiration_timestamp: number;\n    }>(`/libraries/${libraryId}/whiteboards`, {\n      method: 'POST',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  // Moderation\n  \n  /**\n   * Remove a participant from a room\n   */\n  async removeParticipant(roomId: string, participantId: string): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/participants/${participantId}/remove`, {\n      method: 'POST'\n    });\n  }\n  \n  /**\n   * Set participant mute status\n   */\n  async setParticipantMute(roomId: string, participantId: string, options: {\n    mute: boolean;\n    type?: 'audio' | 'video' | 'all';\n  }): Promise<void> {\n    const { mute, type = 'all' } = options;\n    \n    await this.request<void>(`/rooms/${roomId}/participants/${participantId}/mute`, {\n      method: 'POST',\n      body: JSON.stringify({ mute, type })\n    });\n  }\n  \n  /**\n   * Set participant role\n   */\n  async setParticipantRole(roomId: string, participantId: string, role: string): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/participants/${participantId}/role`, {\n      method: 'POST',\n      body: JSON.stringify({ role })\n    });\n  }\n  \n  /**\n   * Ban a participant from a room\n   */\n  async banParticipant(roomId: string, participantId: string): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/participants/${participantId}/ban`, {\n      method: 'POST'\n    });\n  }\n  \n  /**\n   * Unban a participant from a room\n   */\n  async unbanParticipant(roomId: string, participantId: string): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/participants/${participantId}/unban`, {\n      method: 'POST'\n    });\n  }\n  \n  /**\n   * Get banned participants\n   */\n  async getBannedParticipants(roomId: string): Promise<ApiResponse<{\n    id: string;\n    external_id?: string;\n    name: string;\n    ban_time: string;\n  }>> {\n    return this.request<ApiResponse<{\n      id: string;\n      external_id?: string;\n      name: string;\n      ban_time: string;\n    }>>(`/rooms/${roomId}/banned-participants`);\n  }\n  \n  // Statistics\n  \n  /**\n   * Get team global statistics by period\n   */\n  async getTeamStatistics(params?: DateRangeParams & {\n    metrics?: string;\n  }): Promise<Record<string, any>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<Record<string, any>>(`/statistics${query}`);\n  }\n  \n  /**\n   * Get team global statistics by current period\n   */\n  async getTeamCurrentStatistics(metrics?: string): Promise<Record<string, any>> {\n    const queryParams = new URLSearchParams();\n    if (metrics) {\n      queryParams.append('metrics', metrics);\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<Record<string, any>>(`/statistics/team/current${query}`);\n  }\n  \n  /**\n   * Get team statistics for current period (simplified)\n   */\n  async getSimplifiedTeamCurrentStatistics(): Promise<Record<string, any>> {\n    return this.request<Record<string, any>>('/statistics/current');\n  }\n  \n  /**\n   * Get room statistics by period\n   */\n  async getRoomStatistics(roomId: string, params?: DateRangeParams & {\n    metrics?: string;\n  }): Promise<Record<string, any>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<Record<string, any>>(`/rooms/${roomId}/statistics${query}`);\n  }\n  \n  /**\n   * Get room statistics for current period\n   */\n  async getRoomCurrentStatistics(roomId: string, metrics?: string): Promise<Record<string, any>> {\n    const queryParams = new URLSearchParams();\n    if (metrics) {\n      queryParams.append('metrics', metrics);\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<Record<string, any>>(`/rooms/${roomId}/statistics/current${query}`);\n  }\n  \n  /**\n   * Get participant statistics\n   */\n  async getParticipantStatistics(participantId: string): Promise<ParticipantDetail> {\n    return this.request<ParticipantDetail>(`/participants/${participantId}/statistics`);\n  }\n  \n  \n  // Breakout Rooms\n  \n  /**\n   * List breakout rooms for a parent room\n   */\n  async listBreakoutRooms(roomId: string, params?: PaginationParams): Promise<ApiResponse<BreakoutRoom>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<BreakoutRoom>>(`/rooms/${roomId}/breakout-rooms${query}`);\n  }\n  \n  /**\n   * Get a specific breakout room\n   */\n  async getBreakoutRoom(roomId: string, breakoutRoomId: string): Promise<BreakoutRoom> {\n    return this.request<BreakoutRoom>(`/rooms/${roomId}/breakout-rooms/${breakoutRoomId}`);\n  }\n  \n  /**\n   * Create breakout rooms\n   */\n  async createBreakoutRooms(roomId: string, settings: BreakoutRoomCreateSettings): Promise<ApiResponse<BreakoutRoom>> {\n    return this.request<ApiResponse<BreakoutRoom>>(`/rooms/${roomId}/breakout-rooms`, {\n      method: 'POST',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Delete a breakout room\n   */\n  async deleteBreakoutRoom(roomId: string, breakoutRoomId: string): Promise<void> {\n    // Invalidate cache when deleting resources\n    if (this.cache) {\n      this.cache.invalidateNamespace('api');\n    }\n    \n    await this.request<void>(`/rooms/${roomId}/breakout-rooms/${breakoutRoomId}`, {\n      method: 'DELETE'\n    });\n  }\n  \n  /**\n   * Delete all breakout rooms\n   */\n  async deleteAllBreakoutRooms(roomId: string): Promise<void> {\n    // Invalidate cache when deleting resources\n    if (this.cache) {\n      this.cache.invalidateNamespace('api');\n    }\n    \n    await this.request<void>(`/rooms/${roomId}/breakout-rooms`, {\n      method: 'DELETE'\n    });\n  }\n  \n  /**\n   * List participants in a breakout room\n   */\n  async listBreakoutRoomParticipants(roomId: string, breakoutRoomId: string, params?: PaginationParams): Promise<ApiResponse<Participant>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<Participant>>(`/rooms/${roomId}/breakout-rooms/${breakoutRoomId}/participants${query}`);\n  }\n  \n  /**\n   * Assign participants to breakout rooms\n   */\n  async assignParticipantsToBreakoutRooms(roomId: string, assignments: BreakoutRoomParticipantAssignment[]): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/breakout-rooms/assignments`, {\n      method: 'POST',\n      body: JSON.stringify(assignments)\n    });\n  }\n  \n  /**\n   * Return all participants to the main room\n   */\n  async returnAllParticipantsToMainRoom(roomId: string): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/breakout-rooms/return-all`, {\n      method: 'POST'\n    });\n  }\n  \n  /**\n   * Broadcast message to all breakout rooms\n   */\n  async broadcastToBreakoutRooms(roomId: string, options: { message: string }): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/breakout-rooms/broadcast`, {\n      method: 'POST',\n      body: JSON.stringify(options)\n    });\n  }\n  \n  /**\n   * Open breakout rooms (start breakout sessions)\n   */\n  async openBreakoutRooms(roomId: string): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/breakout-rooms/open`, {\n      method: 'POST'\n    });\n  }\n  \n  /**\n   * Close breakout rooms\n   */\n  async closeBreakoutRooms(roomId: string): Promise<void> {\n    await this.request<void>(`/rooms/${roomId}/breakout-rooms/close`, {\n      method: 'POST'\n    });\n  }\n  \n  // Meeting Scheduling\n  \n  /**\n   * List all scheduled meetings\n   */\n  async listScheduledMeetings(params?: PaginationParams & DateRangeParams): Promise<ApiResponse<ScheduledMeeting>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<ScheduledMeeting>>(`/meetings${query}`);\n  }\n  \n  /**\n   * Get a specific scheduled meeting\n   */\n  async getScheduledMeeting(meetingId: string): Promise<ScheduledMeeting> {\n    return this.request<ScheduledMeeting>(`/meetings/${meetingId}`);\n  }\n  \n  /**\n   * Create a new scheduled meeting\n   */\n  async createScheduledMeeting(settings: MeetingCreateSettings): Promise<ScheduledMeeting> {\n    return this.request<ScheduledMeeting>('/meetings', {\n      method: 'POST',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Update a scheduled meeting\n   */\n  async updateScheduledMeeting(meetingId: string, settings: MeetingUpdateSettings): Promise<ScheduledMeeting> {\n    return this.request<ScheduledMeeting>(`/meetings/${meetingId}`, {\n      method: 'PATCH',\n      body: JSON.stringify(settings)\n    });\n  }\n  \n  /**\n   * Cancel a scheduled meeting\n   */\n  async cancelScheduledMeeting(meetingId: string, options?: { notify_participants?: boolean }): Promise<void> {\n    await this.request<void>(`/meetings/${meetingId}/cancel`, {\n      method: 'POST',\n      body: options ? JSON.stringify(options) : undefined\n    });\n  }\n  \n  /**\n   * Delete a scheduled meeting\n   */\n  async deleteScheduledMeeting(meetingId: string): Promise<void> {\n    await this.request<void>(`/meetings/${meetingId}`, {\n      method: 'DELETE'\n    });\n  }\n  \n  /**\n   * List upcoming meetings\n   */\n  async listUpcomingMeetings(params?: PaginationParams): Promise<ApiResponse<ScheduledMeeting>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<ScheduledMeeting>>(`/meetings/upcoming${query}`);\n  }\n  \n  /**\n   * List meetings for a specific room\n   */\n  async listRoomMeetings(roomId: string, params?: PaginationParams & DateRangeParams): Promise<ApiResponse<ScheduledMeeting>> {\n    const queryParams = new URLSearchParams();\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined) {\n          queryParams.append(key, String(value));\n        }\n      });\n    }\n    \n    const query = queryParams.toString() ? `?${queryParams.toString()}` : '';\n    return this.request<ApiResponse<ScheduledMeeting>>(`/rooms/${roomId}/meetings${query}`);\n  }\n  \n  /**\n   * Add participants to a meeting\n   */\n  async addMeetingParticipants(meetingId: string, options: MeetingParticipantAddOptions): Promise<void> {\n    await this.request<void>(`/meetings/${meetingId}/participants`, {\n      method: 'POST',\n      body: JSON.stringify(options)\n    });\n  }\n  \n  /**\n   * Remove participants from a meeting\n   */\n  async removeMeetingParticipants(meetingId: string, options: MeetingParticipantRemoveOptions): Promise<void> {\n    await this.request<void>(`/meetings/${meetingId}/participants/remove`, {\n      method: 'POST',\n      body: JSON.stringify(options)\n    });\n  }\n  \n  /**\n   * Send meeting reminders\n   */\n  async sendMeetingReminders(meetingId: string, options?: MeetingReminderOptions): Promise<void> {\n    await this.request<void>(`/meetings/${meetingId}/reminders`, {\n      method: 'POST',\n      body: options ? JSON.stringify(options) : undefined\n    });\n  }\n  \n  /**\n   * Find available meeting times\n   */\n  async findAvailableMeetingTimes(options: MeetingAvailabilityOptions): Promise<AvailableTimeSlot[]> {\n    return this.request<AvailableTimeSlot[]>('/meetings/available-times', {\n      method: 'POST',\n      body: JSON.stringify(options)\n    });\n  }\n\n  // Communication Management Methods\n\n  /**\n   * Delete session chats\n   */\n  async deleteSessionChats(sessionId: string): Promise<void> {\n    // Invalidate cache when deleting resources\n    if (this.cache) {\n      this.cache.invalidateNamespace('api');\n    }\n    \n    await this.request<void>(`/sessions/${sessionId}/chats`, {\n      method: 'DELETE'\n    });\n  }\n\n  /**\n   * Delete session Q&A\n   */\n  async deleteSessionQA(sessionId: string): Promise<void> {\n    // Invalidate cache when deleting resources\n    if (this.cache) {\n      this.cache.invalidateNamespace('api');\n    }\n    \n    await this.request<void>(`/sessions/${sessionId}/qa`, {\n      method: 'DELETE'\n    });\n  }\n\n  /**\n   * Delete session summaries\n   */\n  async deleteSessionSummaries(sessionId: string): Promise<void> {\n    // Invalidate cache when deleting resources\n    if (this.cache) {\n      this.cache.invalidateNamespace('api');\n    }\n    \n    await this.request<void>(`/sessions/${sessionId}/summaries`, {\n      method: 'DELETE'\n    });\n  }\n\n  /**\n   * Delete session polls\n   */\n  async deleteSessionPolls(sessionId: string): Promise<void> {\n    // Invalidate cache when deleting resources\n    if (this.cache) {\n      this.cache.invalidateNamespace('api');\n    }\n    \n    await this.request<void>(`/sessions/${sessionId}/polls`, {\n      method: 'DELETE'\n    });\n  }\n\n  /**\n   * Publish poll results\n   */\n  async publishPollResults(pollId: string, sessionId: string): Promise<void> {\n    await this.request<void>(`/sessions/${sessionId}/polls/${pollId}/publish-results`, {\n      method: 'POST'\n    });\n  }\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/errors.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 108,
          "column": 18,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 108,
          "endColumn": 21,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  3365,
                  3368
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  3365,
                  3368
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 123,
          "column": 20,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 123,
          "endColumn": 23,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  3972,
                  3975
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  3972,
                  3975
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 2,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Error Types Module for Digital Samba MCP Server\n * \n * This module defines custom error types used throughout the MCP server implementation.\n * Standardized error handling provides consistent behavior, improves error reporting,\n * and makes debugging easier.\n * \n * @module errors\n * @author Digital Samba Team\n * @version 0.1.0\n */\n\n/**\n * Base error class for all Digital Samba MCP errors\n * \n * This class extends the standard Error to add additional context and typed error handling.\n * It provides a common base class for all custom errors in the system.\n * \n * @class DigitalSambaError\n * @extends Error\n * @example\n * throw new DigitalSambaError('Something went wrong');\n */\nexport class DigitalSambaError extends Error {\n  /**\n   * Create a new DigitalSambaError\n   * \n   * @param {string} message - Error message\n   * @param {Object} [options] - Additional error options\n   * @param {Error} [options.cause] - The error that caused this error\n   */\n  constructor(message: string, _options?: { cause?: Error }) {\n    super(message);\n    this.name = 'DigitalSambaError';\n  }\n}\n\n/**\n * Error thrown when API authentication fails\n * \n * This error is used when the API key is missing, invalid, or unauthorized.\n * \n * @class AuthenticationError\n * @extends DigitalSambaError\n * @example\n * throw new AuthenticationError('API key is missing or invalid');\n */\nexport class AuthenticationError extends DigitalSambaError {\n  /**\n   * Create a new AuthenticationError\n   * \n   * @param {string} message - Error message\n   * @param {Object} [options] - Additional error options\n   * @param {Error} [options.cause] - The error that caused this error\n   */\n  constructor(message: string, _options?: { cause?: Error }) {\n    super(message);\n    this.name = 'AuthenticationError';\n  }\n}\n\n/**\n * Error thrown when an API request fails\n * \n * This error is used for general API request failures, such as network errors,\n * timeouts, or other issues with the HTTP request itself.\n * \n * @class ApiRequestError\n * @extends DigitalSambaError\n * @example\n * throw new ApiRequestError('Failed to connect to the API server', { cause: originalError });\n */\nexport class ApiRequestError extends DigitalSambaError {\n  /**\n   * Create a new ApiRequestError\n   * \n   * @param {string} message - Error message\n   * @param {Object} [options] - Additional error options\n   * @param {Error} [options.cause] - The error that caused this error\n   */\n  constructor(message: string, _options?: { cause?: Error }) {\n    super(message);\n    this.name = 'ApiRequestError';\n  }\n}\n\n/**\n * Error thrown when an API response indicates an error\n * \n * This error represents errors that come from the Digital Samba API itself,\n * such as validation errors, resource not found, etc.\n * \n * @class ApiResponseError\n * @extends DigitalSambaError\n * @property {number} statusCode - HTTP status code from the API response\n * @property {string} apiErrorMessage - Original error message from the API\n * @property {any} apiErrorData - Additional error data from the API (if available)\n * @example\n * throw new ApiResponseError('Room not found', { \n *   statusCode: 404, \n *   apiErrorMessage: 'The requested room does not exist',\n *   apiErrorData: { roomId: '123' }\n * });\n */\nexport class ApiResponseError extends DigitalSambaError {\n  statusCode: number;\n  apiErrorMessage: string;\n  apiErrorData?: any;\n  \n  /**\n   * Create a new ApiResponseError\n   * \n   * @param {string} message - Error message\n   * @param {Object} options - Additional error options\n   * @param {number} options.statusCode - HTTP status code from the API response\n   * @param {string} options.apiErrorMessage - Original error message from the API\n   * @param {any} [options.apiErrorData] - Additional error data from the API (if available)\n   * @param {Error} [options.cause] - The error that caused this error\n   */\n  constructor(message: string, options: { \n    statusCode: number, \n    apiErrorMessage: string, \n    apiErrorData?: any,\n    cause?: Error\n  }) {\n    super(message);\n    this.name = 'ApiResponseError';\n    this.statusCode = options.statusCode;\n    this.apiErrorMessage = options.apiErrorMessage;\n    this.apiErrorData = options.apiErrorData;\n  }\n}\n\n/**\n * Error thrown when a resource is not found\n * \n * This error is a specific type of API response error for 404 Not Found responses.\n * \n * @class ResourceNotFoundError\n * @extends ApiResponseError\n * @example\n * throw new ResourceNotFoundError('Room not found', { resourceId: '123', resourceType: 'room' });\n */\nexport class ResourceNotFoundError extends ApiResponseError {\n  resourceType: string;\n  resourceId: string;\n  \n  /**\n   * Create a new ResourceNotFoundError\n   * \n   * @param {string} message - Error message\n   * @param {Object} options - Additional error options\n   * @param {string} options.resourceId - ID of the resource that was not found\n   * @param {string} options.resourceType - Type of resource (e.g., 'room', 'participant')\n   * @param {Error} [options.cause] - The error that caused this error\n   */\n  constructor(message: string, options: { \n    resourceId: string, \n    resourceType: string,\n    cause?: Error\n  }) {\n    super(message, { \n      statusCode: 404, \n      apiErrorMessage: `${options.resourceType} with ID ${options.resourceId} not found`\n    });\n    this.name = 'ResourceNotFoundError';\n    this.resourceType = options.resourceType;\n    this.resourceId = options.resourceId;\n  }\n}\n\n/**\n * Error thrown when a request is invalid\n * \n * This error is used for validation errors, such as missing required parameters\n * or invalid parameter values.\n * \n * @class ValidationError\n * @extends DigitalSambaError\n * @property {Record<string, string>} validationErrors - Map of field names to error messages\n * @example\n * throw new ValidationError('Invalid request parameters', {\n *   validationErrors: {\n *     'name': 'Name is required',\n *     'email': 'Email is not valid'\n *   }\n * });\n */\nexport class ValidationError extends DigitalSambaError {\n  validationErrors: Record<string, string>;\n  \n  /**\n   * Create a new ValidationError\n   * \n   * @param {string} message - Error message\n   * @param {Object} options - Additional error options\n   * @param {Record<string, string>} options.validationErrors - Map of field names to error messages\n   * @param {Error} [options.cause] - The error that caused this error\n   */\n  constructor(message: string, options: { \n    validationErrors: Record<string, string>,\n    cause?: Error\n  }) {\n    super(message);\n    this.name = 'ValidationError';\n    this.validationErrors = options.validationErrors;\n  }\n}\n\n/**\n * Error thrown when a feature is not implemented\n * \n * This error is used when attempting to use a feature that is not yet implemented.\n * \n * @class NotImplementedError\n * @extends DigitalSambaError\n * @example\n * throw new NotImplementedError('This feature is not yet implemented');\n */\nexport class NotImplementedError extends DigitalSambaError {\n  /**\n   * Create a new NotImplementedError\n   * \n   * @param {string} message - Error message\n   * @param {Object} [options] - Additional error options\n   * @param {Error} [options.cause] - The error that caused this error\n   */\n  constructor(message: string, _options?: { cause?: Error }) {\n    super(message);\n    this.name = 'NotImplementedError';\n  }\n}\n\n/**\n * Error thrown when a configuration value is missing\n * \n * This error is used when a required configuration value is not provided.\n * \n * @class ConfigurationError\n * @extends DigitalSambaError\n * @example\n * throw new ConfigurationError('Missing required configuration value: API_KEY');\n */\nexport class ConfigurationError extends DigitalSambaError {\n  /**\n   * Create a new ConfigurationError\n   * \n   * @param {string} message - Error message\n   * @param {Object} [options] - Additional error options\n   * @param {Error} [options.cause] - The error that caused this error\n   */\n  constructor(message: string, _options?: { cause?: Error }) {\n    super(message);\n    this.name = 'ConfigurationError';\n  }\n}\n\n/**\n * Error thrown when a session operation fails\n * \n * This error is used for session-related operations such as session initialization,\n * session context access, or session termination.\n * \n * @class SessionError\n * @extends DigitalSambaError\n * @example\n * throw new SessionError('Failed to initialize session', { sessionId: '123' });\n */\nexport class SessionError extends DigitalSambaError {\n  sessionId?: string;\n  \n  /**\n   * Create a new SessionError\n   * \n   * @param {string} message - Error message\n   * @param {Object} [options] - Additional error options\n   * @param {string} [options.sessionId] - ID of the session that caused the error\n   * @param {Error} [options.cause] - The error that caused this error\n   */\n  constructor(message: string, options?: { \n    sessionId?: string,\n    cause?: Error\n  }) {\n    super(message);\n    this.name = 'SessionError';\n    this.sessionId = options?.sessionId;\n  }\n}\n\n/**\n * Error thrown when a service is in a degraded state\n * \n * This error is used when a service operation fails due to degraded service health,\n * and no fallback strategies are available or all fallbacks have failed.\n * \n * @class DegradedServiceError\n * @extends DigitalSambaError\n * @property {string} operationName - Name of the operation that failed\n * @property {string} componentStatus - Status of the component that is degraded\n * @property {string[]} attemptedStrategies - List of strategies that were attempted\n * @example\n * throw new DegradedServiceError('Service unavailable', { \n *   operationName: 'listRooms',\n *   componentStatus: 'SEVERELY_DEGRADED',\n *   attemptedStrategies: ['retry', 'cache', 'fallback']\n * });\n */\nexport class DegradedServiceError extends DigitalSambaError {\n  operationName: string;\n  componentStatus?: string;\n  attemptedStrategies: string[];\n  \n  /**\n   * Create a new DegradedServiceError\n   * \n   * @param {string} message - Error message\n   * @param {Object} options - Additional error options\n   * @param {string} options.operationName - Name of the operation that failed\n   * @param {string} [options.componentStatus] - Status of the component that is degraded\n   * @param {string[]} [options.attemptedStrategies] - List of strategies that were attempted\n   * @param {Error} [options.cause] - The error that caused this error\n   */\n  constructor(message: string, options: { \n    operationName: string,\n    componentStatus?: string,\n    attemptedStrategies?: string[],\n    cause?: Error\n  }) {\n    super(message);\n    this.name = 'DegradedServiceError';\n    this.operationName = options.operationName;\n    this.componentStatus = options.componentStatus;\n    this.attemptedStrategies = options.attemptedStrategies || [];\n  }\n}\n",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/graceful-degradation.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 207,
          "column": 49,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 207,
          "endColumn": 52,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  5276,
                  5279
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  5276,
                  5279
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 901,
          "column": 29,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 901,
          "endColumn": 32,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  30250,
                  30253
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  30250,
                  30253
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 906,
          "column": 99,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 906,
          "endColumn": 102,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  30481,
                  30484
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  30481,
                  30484
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 3,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Graceful Degradation Module\n * \n * This module provides mechanisms for handling partial API outages and ensuring\n * continued functionality with degraded service levels. It works alongside the\n * circuit breaker pattern to provide a comprehensive approach to API resilience.\n * \n * Key features:\n * - Multiple degradation levels based on service health\n * - Fallback strategies for critical functionality\n * - Cached content serving during outages\n * - Intelligent retry mechanisms with exponential backoff\n * - Health monitoring and automatic recovery\n * - Metrics integration for observability\n * \n * @module graceful-degradation\n * @author Digital Samba Team\n * @version 0.1.0\n */\n\n// Node.js modules\nimport { EventEmitter } from 'events';\n\n// Local modules\nimport { MemoryCache } from './cache.js';\nimport logger from './logger.js';\nimport { DegradedServiceError } from './errors.js';\nimport circuitBreakerRegistry, { CircuitBreaker, CircuitState } from './circuit-breaker.js';\n\n/**\n * Service health status levels\n */\nexport enum ServiceHealthStatus {\n  HEALTHY = 'HEALTHY',           // All systems operational\n  PARTIALLY_DEGRADED = 'PARTIALLY_DEGRADED', // Some non-critical systems affected\n  SEVERELY_DEGRADED = 'SEVERELY_DEGRADED',   // Critical systems affected\n  UNAVAILABLE = 'UNAVAILABLE'    // Service completely unavailable\n}\n\n/**\n * Service component health tracking\n */\nexport interface ServiceComponentHealth {\n  name: string;\n  status: ServiceHealthStatus;\n  lastCheck: Date;\n  errorCount: number;\n  message?: string;\n}\n\n/**\n * Fallback strategy type\n * \n * Defines a function that provides alternative functionality\n * when a primary service is unavailable\n */\nexport type FallbackStrategy<T> = () => Promise<T>;\n\n/**\n * Degradation options interface\n */\nexport interface GracefulDegradationOptions {\n  /**\n   * Cache instance for storing fallback data\n   */\n  cache?: MemoryCache;\n  \n  /**\n   * Maximum number of retry attempts for failed operations\n   * @default 3\n   */\n  maxRetryAttempts?: number;\n  \n  /**\n   * Initial delay in milliseconds before first retry\n   * @default 1000 (1 second)\n   */\n  initialRetryDelay?: number;\n  \n  /**\n   * Factor to multiply delay by for each subsequent retry\n   * @default 2 (exponential backoff)\n   */\n  retryBackoffFactor?: number;\n  \n  /**\n   * Maximum delay in milliseconds between retries\n   * @default 30000 (30 seconds)\n   */\n  maxRetryDelay?: number;\n  \n  /**\n   * Interval in milliseconds to check service health\n   * @default 60000 (1 minute)\n   */\n  healthCheckInterval?: number;\n  \n  /**\n   * Component failure threshold before considering the component degraded\n   * @default 3\n   */\n  componentFailureThreshold?: number;\n  \n  /**\n   * Component success threshold before considering the component recovered\n   * @default 2\n   */\n  componentRecoveryThreshold?: number;\n}\n\n/**\n * Fallback configuration interface\n */\nexport interface FallbackConfig<T> {\n  /**\n   * The fallback function to call when the primary operation fails\n   */\n  fallbackFn: FallbackStrategy<T>;\n  \n  /**\n   * Is this operation critical for the application\n   * @default false\n   */\n  isCritical?: boolean;\n  \n  /**\n   * TTL for cached fallback data in milliseconds\n   * @default 300000 (5 minutes)\n   */\n  cacheTTL?: number;\n  \n  /**\n   * Indicates whether the fallback is currently active\n   * @default false\n   */\n  isActive?: boolean;\n}\n\n/**\n * Operation result with degradation information\n */\nexport interface DegradedResult<T> {\n  /**\n   * The operation result data\n   */\n  data: T;\n  \n  /**\n   * Indicates if the result comes from a degraded service\n   */\n  isDegraded: boolean;\n  \n  /**\n   * Degradation level if applicable\n   */\n  degradationLevel?: ServiceHealthStatus;\n  \n  /**\n   * Source of the data (primary, cache, fallback)\n   */\n  source: 'primary' | 'cache' | 'fallback';\n  \n  /**\n   * Optional message about the degradation\n   */\n  message?: string;\n}\n\n/**\n * Graceful degradation service for handling API outages\n * \n * This class provides mechanisms for handling partial API outages and ensuring\n * the application can continue functioning with degraded service levels.\n * \n * @class GracefulDegradation\n * @example\n * // Create a graceful degradation service\n * const degradationService = new GracefulDegradation({\n *   cache: new MemoryCache(),\n *   maxRetryAttempts: 3,\n *   initialRetryDelay: 1000\n * });\n * \n * // Register a fallback for the listRooms operation\n * degradationService.registerFallback('listRooms', {\n *   fallbackFn: async () => ({ data: [], total_count: 0, length: 0, map: () => [] }),\n *   isCritical: true\n * });\n * \n * // Execute an operation with graceful degradation\n * const result = await degradationService.executeWithFallback(\n *   'listRooms',\n *   () => apiClient.listRooms(),\n *   { cacheKey: 'rooms' }\n * );\n */\nexport class GracefulDegradation extends EventEmitter {\n  private cache?: MemoryCache;\n  private maxRetryAttempts: number;\n  private initialRetryDelay: number;\n  private retryBackoffFactor: number;\n  private maxRetryDelay: number;\n  private healthCheckInterval: number;\n  private componentFailureThreshold: number;\n  private componentRecoveryThreshold: number;\n  private healthCheckTimer?: NodeJS.Timeout;\n  private fallbacks: Map<string, FallbackConfig<any>> = new Map();\n  private componentHealth: Map<string, ServiceComponentHealth> = new Map();\n  private overallHealth: ServiceHealthStatus = ServiceHealthStatus.HEALTHY;\n  \n  /**\n   * Creates a new GracefulDegradation instance\n   * \n   * @constructor\n   * @param {GracefulDegradationOptions} options - Configuration options\n   */\n  constructor(options: GracefulDegradationOptions = {}) {\n    super();\n    this.cache = options.cache;\n    this.maxRetryAttempts = options.maxRetryAttempts ?? 3;\n    this.initialRetryDelay = options.initialRetryDelay ?? 1000;\n    this.retryBackoffFactor = options.retryBackoffFactor ?? 2;\n    this.maxRetryDelay = options.maxRetryDelay ?? 30000;\n    this.healthCheckInterval = options.healthCheckInterval ?? 60000;\n    this.componentFailureThreshold = options.componentFailureThreshold ?? 3;\n    this.componentRecoveryThreshold = options.componentRecoveryThreshold ?? 2;\n    \n    // Log the service creation\n    logger.debug('Graceful degradation service created', {\n      maxRetryAttempts: this.maxRetryAttempts,\n      initialRetryDelay: this.initialRetryDelay,\n      retryBackoffFactor: this.retryBackoffFactor,\n      maxRetryDelay: this.maxRetryDelay,\n      healthCheckInterval: this.healthCheckInterval,\n      componentFailureThreshold: this.componentFailureThreshold,\n      componentRecoveryThreshold: this.componentRecoveryThreshold\n    });\n    \n    // Monitor circuit breakers to automatically detect component health\n    this.monitorCircuitBreakers();\n    \n    // Start health check timer\n    this.startHealthCheck();\n    \n    // Track metrics\n    this.updateMetrics('created');\n  }\n  \n  /**\n   * Start periodic health checks\n   * \n   * @private\n   */\n  private startHealthCheck(): void {\n    if (this.healthCheckTimer) {\n      clearInterval(this.healthCheckTimer);\n    }\n    \n    this.healthCheckTimer = setInterval(() => {\n      this.checkHealth();\n    }, this.healthCheckInterval);\n    \n    // Initial health check\n    this.checkHealth();\n  }\n  \n  /**\n   * Stop periodic health checks\n   * \n   * @private\n   */\n  private stopHealthCheck(): void {\n    if (this.healthCheckTimer) {\n      clearInterval(this.healthCheckTimer);\n      this.healthCheckTimer = undefined;\n    }\n  }\n  \n  /**\n   * Cleanup resources - call when shutting down\n   */\n  dispose(): void {\n    this.stopHealthCheck();\n  }\n  \n  /**\n   * Monitor circuit breakers to detect component health\n   * \n   * @private\n   */\n  private monitorCircuitBreakers(): void {\n    const circuits = circuitBreakerRegistry.getAll();\n    \n    for (const circuit of circuits) {\n      this.monitorCircuitBreaker(circuit);\n    }\n    \n    // Listen for new circuit breakers\n    try {\n      if (typeof circuitBreakerRegistry.on === 'function') {\n        circuitBreakerRegistry.on('created', (circuit: CircuitBreaker) => {\n          this.monitorCircuitBreaker(circuit);\n        });\n      } else {\n        logger.debug('Circuit breaker registry does not support events, will not monitor new circuits');\n      }\n    } catch (error) {\n      logger.debug(`Error setting up circuit breaker registry listener: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n  \n  /**\n   * Monitor a specific circuit breaker\n   * \n   * @private\n   * @param {CircuitBreaker} circuit - The circuit breaker to monitor\n   */\n  private monitorCircuitBreaker(circuit: CircuitBreaker): void {\n    const circuitName = circuit.getName();\n    \n    // Add to component health if not already present\n    if (!this.componentHealth.has(circuitName)) {\n      this.componentHealth.set(circuitName, {\n        name: circuitName,\n        status: ServiceHealthStatus.HEALTHY,\n        lastCheck: new Date(),\n        errorCount: 0\n      });\n    }\n    \n    // Monitor state changes\n    circuit.on('open', () => {\n      this.updateComponentHealth(circuitName, ServiceHealthStatus.SEVERELY_DEGRADED);\n      logger.warn(`Circuit ${circuitName} opened, component marked as severely degraded`);\n    });\n    \n    circuit.on('half-open', () => {\n      this.updateComponentHealth(circuitName, ServiceHealthStatus.PARTIALLY_DEGRADED);\n      logger.info(`Circuit ${circuitName} half-opened, component marked as partially degraded`);\n    });\n    \n    circuit.on('close', () => {\n      this.updateComponentHealth(circuitName, ServiceHealthStatus.HEALTHY);\n      logger.info(`Circuit ${circuitName} closed, component marked as healthy`);\n    });\n  }\n  \n  /**\n   * Register a fallback strategy for an operation\n   * \n   * @param {string} operationName - The name of the operation\n   * @param {FallbackConfig<T>} config - The fallback configuration\n   * @example\n   * // Register a fallback for the listRooms operation\n   * degradationService.registerFallback('listRooms', {\n   *   fallbackFn: async () => ({ data: [], total_count: 0, length: 0, map: () => [] }),\n   *   isCritical: true,\n   *   cacheTTL: 600000 // 10 minutes\n   * });\n   */\n  registerFallback<T>(operationName: string, config: FallbackConfig<T>): void {\n    // Ensure the fallback has the isActive property\n    const fullConfig: FallbackConfig<T> = {\n      ...config,\n      isActive: false\n    };\n    \n    this.fallbacks.set(operationName, fullConfig);\n    \n    logger.debug(`Registered fallback for operation: ${operationName}`, {\n      operation: operationName,\n      isCritical: fullConfig.isCritical,\n      cacheTTL: fullConfig.cacheTTL\n    });\n    \n    this.updateMetrics('fallback_registered', { operation: operationName });\n  }\n  \n  /**\n   * Execute an operation with graceful degradation and fallback support\n   * \n   * This method attempts to execute the primary operation, and if it fails,\n   * it follows a degradation strategy:\n   * 1. Try to fetch from cache if available\n   * 2. Retry with exponential backoff if appropriate\n   * 3. Use the registered fallback if available\n   * 4. Throw an error if all strategies fail\n   * \n   * @template T - The type of the operation result\n   * @param {string} operationName - The name of the operation (should match the registered fallback)\n   * @param {() => Promise<T>} primaryFn - The primary operation function\n   * @param {Object} options - Additional options\n   * @param {string} [options.cacheKey] - Key to use for caching results\n   * @param {number} [options.cacheTTL] - TTL for cache in milliseconds\n   * @param {boolean} [options.skipCache] - Skip cache check\n   * @param {boolean} [options.skipRetry] - Skip retry attempts\n   * @returns {Promise<DegradedResult<T>>} The operation result with degradation information\n   * @throws {DegradedServiceError} If all strategies fail and no fallback is available\n   * @example\n   * // Execute a function with graceful degradation\n   * const result = await degradationService.executeWithFallback(\n   *   'listRooms',\n   *   () => apiClient.listRooms(),\n   *   { cacheKey: 'rooms', cacheTTL: 300000 }\n   * );\n   * \n   * // Use the result, checking if it's degraded\n   * if (result.isDegraded) {\n   *   console.log(`Using ${result.source} data due to ${result.degradationLevel} service`);\n   * }\n   * const rooms = result.data;\n   */\n  async executeWithFallback<T>(\n    operationName: string,\n    primaryFn: () => Promise<T>,\n    options: {\n      cacheKey?: string;\n      cacheTTL?: number;\n      skipCache?: boolean;\n      skipRetry?: boolean;\n    } = {}\n  ): Promise<DegradedResult<T>> {\n    const startTime = Date.now();\n    const { cacheKey, cacheTTL, skipCache = false, skipRetry = false } = options;\n    const fallbackConfig = this.fallbacks.get(operationName);\n    const cacheNamespace = 'degradation';\n    const componentHealth = this.componentHealth.get(operationName) || {\n      name: operationName,\n      status: ServiceHealthStatus.HEALTHY,\n      lastCheck: new Date(),\n      errorCount: 0\n    };\n    let source: 'primary' | 'cache' | 'fallback' = 'primary';\n    let retryAttempt = 0;\n    \n    // Check component health - if severely degraded or unavailable, use fallback immediately\n    if (componentHealth.status === ServiceHealthStatus.SEVERELY_DEGRADED ||\n        componentHealth.status === ServiceHealthStatus.UNAVAILABLE) {\n      logger.debug(`Skipping primary execution for ${operationName} due to ${componentHealth.status} status`);\n      \n      // Try cache first\n      if (!skipCache && this.cache && cacheKey) {\n        const cachedResult = this.cache.get(cacheNamespace, cacheKey);\n        if (cachedResult) {\n          logger.debug(`Cache hit for ${operationName} during degraded service`);\n          source = 'cache';\n          \n          // Track metrics\n          this.updateMetrics('cache_hit', { operation: operationName });\n          \n          return {\n            data: cachedResult.value as T,\n            isDegraded: true,\n            degradationLevel: componentHealth.status,\n            source,\n            message: `Using cached data due to ${componentHealth.status} service`\n          };\n        }\n      }\n      \n      // If cache miss, use fallback\n      if (fallbackConfig) {\n        // Activate fallback if not already active\n        if (!fallbackConfig.isActive) {\n          fallbackConfig.isActive = true;\n          this.emit('fallback_activated', { operationName });\n          this.updateMetrics('fallback_activated', { operation: operationName });\n        }\n        \n        logger.debug(`Using fallback for ${operationName} due to ${componentHealth.status} status`);\n        source = 'fallback';\n        \n        try {\n          const fallbackResult = await fallbackConfig.fallbackFn();\n          \n          // Track metrics\n          this.updateMetrics('fallback_success', { operation: operationName });\n          \n          return {\n            data: fallbackResult,\n            isDegraded: true,\n            degradationLevel: componentHealth.status,\n            source,\n            message: `Using fallback data due to ${componentHealth.status} service`\n          };\n        } catch (error) {\n          // Fallback also failed\n          logger.error(`Fallback for ${operationName} failed: ${error instanceof Error ? error.message : String(error)}`);\n          \n          // Track metrics\n          this.updateMetrics('fallback_failure', { operation: operationName });\n          \n          throw new DegradedServiceError(\n            `All strategies failed for ${operationName}: ${error instanceof Error ? error.message : String(error)}`,\n            { \n              operationName, \n              componentStatus: componentHealth.status,\n              attemptedStrategies: ['cache', 'fallback']\n            }\n          );\n        }\n      }\n    }\n    \n    // Try primary function first\n    try {\n      const result = await primaryFn();\n      \n      // Success - reset error count\n      if (this.componentHealth.has(operationName)) {\n        const health = this.componentHealth.get(operationName)!;\n        health.errorCount = 0;\n        \n        // If it was degraded, update status\n        if (health.status !== ServiceHealthStatus.HEALTHY) {\n          this.updateComponentHealth(operationName, ServiceHealthStatus.HEALTHY);\n        }\n      }\n      \n      // Deactivate fallback if active\n      if (fallbackConfig?.isActive) {\n        fallbackConfig.isActive = false;\n        this.emit('fallback_deactivated', { operationName });\n        this.updateMetrics('fallback_deactivated', { operation: operationName });\n      }\n      \n      // Cache the successful result if caching is enabled\n      if (this.cache && cacheKey && cacheTTL) {\n        this.cache.set(cacheNamespace, cacheKey, result, cacheTTL);\n        logger.debug(`Cached result for ${operationName}`, { cacheKey, cacheTTL });\n      }\n      \n      // Track execution time in metrics\n      const duration = (Date.now() - startTime) / 1000; // Convert to seconds\n      this.updateMetrics('operation_duration', { operation: operationName, source }, duration);\n      \n      return {\n        data: result,\n        isDegraded: false,\n        source: 'primary'\n      };\n    } catch (error) {\n      // Primary operation failed\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.warn(`Primary operation ${operationName} failed: ${errorMessage}`);\n      \n      // Track failure in metrics\n      this.updateMetrics('operation_failure', { operation: operationName });\n      \n      // Increment error count and update component health\n      if (this.componentHealth.has(operationName)) {\n        const health = this.componentHealth.get(operationName)!;\n        health.errorCount++;\n        \n        if (health.errorCount >= this.componentFailureThreshold) {\n          this.updateComponentHealth(operationName, ServiceHealthStatus.PARTIALLY_DEGRADED);\n        }\n      } else {\n        // Create new component health entry\n        this.componentHealth.set(operationName, {\n          name: operationName,\n          status: ServiceHealthStatus.HEALTHY, // Start as healthy\n          lastCheck: new Date(),\n          errorCount: 1 // First error\n        });\n      }\n      \n      // Try cache first (if available)\n      if (!skipCache && this.cache && cacheKey) {\n        const cachedResult = this.cache.get(cacheNamespace, cacheKey);\n        if (cachedResult) {\n          logger.debug(`Cache hit for ${operationName} after primary failure`);\n          source = 'cache';\n          \n          // Track metrics\n          this.updateMetrics('cache_hit', { operation: operationName });\n          \n          return {\n            data: cachedResult.value as T,\n            isDegraded: true,\n            degradationLevel: ServiceHealthStatus.PARTIALLY_DEGRADED,\n            source,\n            message: `Using cached data due to temporary service disruption`\n          };\n        }\n      }\n      \n      // Try retry with exponential backoff (if not skipped)\n      if (!skipRetry && retryAttempt < this.maxRetryAttempts) {\n        logger.debug(`Retry attempt ${retryAttempt + 1}/${this.maxRetryAttempts} for ${operationName}`);\n        \n        // Calculate the delay with exponential backoff\n        const delay = Math.min(\n          this.initialRetryDelay * Math.pow(this.retryBackoffFactor, retryAttempt),\n          this.maxRetryDelay\n        );\n        \n        // Track retry metrics\n        this.updateMetrics('retry_attempt', { operation: operationName, attempt: String(retryAttempt + 1) });\n        \n        // Wait for the calculated delay\n        await new Promise(resolve => setTimeout(resolve, delay));\n        \n        // Increment retry attempt and try again recursively\n        retryAttempt++;\n        \n        try {\n          const retryResult = await primaryFn();\n          \n          // Success on retry - update metrics\n          this.updateMetrics('retry_success', { operation: operationName, attempt: String(retryAttempt) });\n          \n          // Cache the successful result if caching is enabled\n          if (this.cache && cacheKey && cacheTTL) {\n            this.cache.set(cacheNamespace, cacheKey, retryResult, cacheTTL);\n          }\n          \n          // Track execution time in metrics\n          const duration = (Date.now() - startTime) / 1000; // Convert to seconds\n          this.updateMetrics('operation_duration', { operation: operationName, source: 'primary' }, duration);\n          \n          return {\n            data: retryResult,\n            isDegraded: false,\n            source: 'primary'\n          };\n        } catch (retryError) {\n          // Retry also failed - log and continue with fallback\n          logger.warn(`Retry ${retryAttempt}/${this.maxRetryAttempts} for ${operationName} failed: ${retryError instanceof Error ? retryError.message : String(retryError)}`);\n          \n          // Track retry failure metrics\n          this.updateMetrics('retry_failure', { operation: operationName, attempt: String(retryAttempt) });\n        }\n      }\n      \n      // If we have a fallback, use it\n      if (fallbackConfig) {\n        // Activate fallback if not already active\n        if (!fallbackConfig.isActive) {\n          fallbackConfig.isActive = true;\n          this.emit('fallback_activated', { operationName });\n          this.updateMetrics('fallback_activated', { operation: operationName });\n        }\n        \n        logger.debug(`Using fallback for ${operationName} after primary failure`);\n        source = 'fallback';\n        \n        try {\n          const fallbackResult = await fallbackConfig.fallbackFn();\n          \n          // Track metrics\n          this.updateMetrics('fallback_success', { operation: operationName });\n          \n          // Track execution time in metrics\n          const duration = (Date.now() - startTime) / 1000; // Convert to seconds\n          this.updateMetrics('operation_duration', { operation: operationName, source }, duration);\n          \n          return {\n            data: fallbackResult,\n            isDegraded: true,\n            degradationLevel: ServiceHealthStatus.PARTIALLY_DEGRADED,\n            source,\n            message: `Using fallback data due to temporary service disruption`\n          };\n        } catch (fallbackError) {\n          // Fallback also failed\n          logger.error(`Fallback for ${operationName} failed: ${fallbackError instanceof Error ? fallbackError.message : String(fallbackError)}`);\n          \n          // Track metrics\n          this.updateMetrics('fallback_failure', { operation: operationName });\n          \n          throw new DegradedServiceError(\n            `All strategies failed for ${operationName}: ${error instanceof Error ? error.message : String(error)}`,\n            { \n              operationName, \n              componentStatus: this.componentHealth.get(operationName)?.status,\n              attemptedStrategies: ['primary', 'cache', ...(retryAttempt > 0 ? ['retry'] : []), 'fallback']\n            }\n          );\n        }\n      }\n      \n      // No fallback available, re-throw the original error\n      throw error;\n    }\n  }\n  \n  /**\n   * Update component health status\n   * \n   * @private\n   * @param {string} componentName - The name of the component\n   * @param {ServiceHealthStatus} status - The new status\n   */\n  private updateComponentHealth(componentName: string, status: ServiceHealthStatus): void {\n    // Get current component health or create new entry\n    const health = this.componentHealth.get(componentName) || {\n      name: componentName,\n      status: ServiceHealthStatus.HEALTHY,\n      lastCheck: new Date(),\n      errorCount: 0\n    };\n    \n    const previousStatus = health.status;\n    \n    // Update health status\n    health.status = status;\n    health.lastCheck = new Date();\n    \n    // If becoming healthy, reset error count\n    if (status === ServiceHealthStatus.HEALTHY) {\n      health.errorCount = 0;\n    }\n    \n    // Store updated health\n    this.componentHealth.set(componentName, health);\n    \n    // Log status change\n    if (previousStatus !== status) {\n      logger.info(`Component ${componentName} health changed from ${previousStatus} to ${status}`);\n      \n      // Emit status change event\n      this.emit('component_status_changed', {\n        componentName,\n        previousStatus,\n        newStatus: status\n      });\n      \n      // Update metrics\n      this.updateMetrics('component_status_changed', {\n        component: componentName,\n        status\n      });\n    }\n    \n    // Recalculate overall health\n    this.recalculateOverallHealth();\n  }\n  \n  /**\n   * Check health of all components\n   * \n   * @private\n   */\n  private checkHealth(): void {\n    logger.debug('Performing health check');\n    \n    // Get all circuit breakers\n    const circuits = circuitBreakerRegistry.getAll();\n    \n    // Update component health based on circuit breaker state\n    for (const circuit of circuits) {\n      const circuitName = circuit.getName();\n      const circuitState = circuit.getState();\n      \n      let status = ServiceHealthStatus.HEALTHY;\n      \n      if (circuitState === CircuitState.OPEN) {\n        status = ServiceHealthStatus.SEVERELY_DEGRADED;\n      } else if (circuitState === CircuitState.HALF_OPEN) {\n        status = ServiceHealthStatus.PARTIALLY_DEGRADED;\n      }\n      \n      this.updateComponentHealth(circuitName, status);\n    }\n    \n    // Recalculate overall health\n    this.recalculateOverallHealth();\n    \n    // Update metrics\n    this.updateMetrics('health_check');\n  }\n  \n  /**\n   * Recalculate overall service health based on component health\n   * \n   * @private\n   */\n  private recalculateOverallHealth(): void {\n    // Default to healthy\n    let newHealth = ServiceHealthStatus.HEALTHY;\n    \n    // Count critical component issues\n    let criticalComponentIssues = 0;\n    let nonCriticalComponentIssues = 0;\n    \n    for (const [componentName, health] of this.componentHealth.entries()) {\n      // Skip healthy components\n      if (health.status === ServiceHealthStatus.HEALTHY) {\n        continue;\n      }\n      \n      // Check if component has a fallback\n      const hasFallback = Array.from(this.fallbacks.entries())\n        .some(([opName, _config]) => opName === componentName);\n      \n      // Get the fallback config if it exists\n      const fallbackConfig = Array.from(this.fallbacks.entries())\n        .find(([opName]) => opName === componentName)?.[1];\n      \n      const isCritical = fallbackConfig?.isCritical ?? false;\n      \n      // Update counters based on component health and criticality\n      if (health.status === ServiceHealthStatus.UNAVAILABLE) {\n        // If component is unavailable and critical, it's a critical issue\n        if (isCritical && !hasFallback) {\n          criticalComponentIssues++;\n        } else {\n          nonCriticalComponentIssues++;\n        }\n      } else if (health.status === ServiceHealthStatus.SEVERELY_DEGRADED) {\n        // Severely degraded critical component without fallback is a critical issue\n        if (isCritical && !hasFallback) {\n          criticalComponentIssues++;\n        } else {\n          nonCriticalComponentIssues++;\n        }\n      } else if (health.status === ServiceHealthStatus.PARTIALLY_DEGRADED) {\n        // Partially degraded components count as non-critical issues\n        nonCriticalComponentIssues++;\n      }\n    }\n    \n    // Determine overall health based on component issues\n    if (criticalComponentIssues > 0) {\n      // If any critical components are unavailable or severely degraded without fallbacks,\n      // the service is unavailable\n      newHealth = ServiceHealthStatus.UNAVAILABLE;\n    } else if (nonCriticalComponentIssues > 2) {\n      // If more than 2 non-critical components have issues, service is severely degraded\n      newHealth = ServiceHealthStatus.SEVERELY_DEGRADED;\n    } else if (nonCriticalComponentIssues > 0) {\n      // If any non-critical components have issues, service is partially degraded\n      newHealth = ServiceHealthStatus.PARTIALLY_DEGRADED;\n    }\n    \n    // Update overall health if changed\n    if (newHealth !== this.overallHealth) {\n      const previousHealth = this.overallHealth;\n      this.overallHealth = newHealth;\n      \n      logger.info(`Overall service health changed from ${previousHealth} to ${newHealth}`);\n      \n      // Emit status change event\n      this.emit('overall_status_changed', {\n        previousStatus: previousHealth,\n        newStatus: newHealth\n      });\n      \n      // Update metrics\n      this.updateMetrics('overall_status_changed', {\n        status: newHealth\n      });\n    }\n  }\n  \n  /**\n   * Get current overall service health\n   * \n   * @returns {ServiceHealthStatus} The current overall health status\n   */\n  getOverallHealth(): ServiceHealthStatus {\n    return this.overallHealth;\n  }\n  \n  /**\n   * Get health of all components\n   * \n   * @returns {ServiceComponentHealth[]} Array of component health statuses\n   */\n  getComponentHealth(): ServiceComponentHealth[] {\n    return Array.from(this.componentHealth.values());\n  }\n  \n  /**\n   * Get health of a specific component\n   * \n   * @param {string} componentName - The name of the component\n   * @returns {ServiceComponentHealth | undefined} The component health or undefined if not found\n   */\n  getComponentHealthById(componentName: string): ServiceComponentHealth | undefined {\n    return this.componentHealth.get(componentName);\n  }\n  \n  /**\n   * Update metrics for the graceful degradation service\n   * \n   * This method attempts to update Prometheus metrics if the metrics module is available.\n   * If the metrics module cannot be imported, the method silently ignores the error.\n   * \n   * @private\n   * @param {string} event - The event type\n   * @param {Record<string, any>} [labels] - Additional labels for the metric\n   * @param {number} [value] - Value for gauge metrics\n   */\n  private async updateMetrics(\n    event: 'created' | 'health_check' | 'component_status_changed' | 'overall_status_changed' | \n          'fallback_registered' | 'fallback_activated' | 'fallback_deactivated' | \n          'fallback_success' | 'fallback_failure' | 'operation_duration' | \n          'operation_failure' | 'cache_hit' | 'retry_attempt' | 'retry_success' | 'retry_failure',\n    labels?: Record<string, any>,\n    value?: number\n  ): Promise<void> {\n    try {\n      // Skip metrics updates in test environment or if Jest is tearing down\n      if (process.env.NODE_ENV === 'test' || (typeof globalThis !== 'undefined' && (globalThis as any).jest)) {\n        return;\n      }\n      \n      const metricsRegistry = await import('./metrics.js').then(m => m.default);\n      \n      switch (event) {\n        case 'created':\n          // New degradation service created\n          break;\n        \n        case 'health_check':\n          // Health check performed\n          metricsRegistry.degradationHealthChecksTotal.inc();\n          break;\n        \n        case 'component_status_changed':\n          // Component status changed\n          if (labels?.component && labels?.status) {\n            metricsRegistry.degradationComponentStatusInfo.set({\n              component: labels.component,\n              status: labels.status\n            }, 1);\n            \n            // Set other statuses to 0\n            const allStatuses = Object.values(ServiceHealthStatus);\n            for (const status of allStatuses) {\n              if (status !== labels.status) {\n                metricsRegistry.degradationComponentStatusInfo.set({\n                  component: labels.component,\n                  status\n                }, 0);\n              }\n            }\n          }\n          break;\n        \n        case 'overall_status_changed':\n          // Overall status changed\n          if (labels?.status) {\n            metricsRegistry.degradationOverallStatusInfo.set({\n              status: labels.status\n            }, 1);\n            \n            // Set other statuses to 0\n            const allStatuses = Object.values(ServiceHealthStatus);\n            for (const status of allStatuses) {\n              if (status !== labels.status) {\n                metricsRegistry.degradationOverallStatusInfo.set({\n                  status\n                }, 0);\n              }\n            }\n          }\n          break;\n        \n        case 'fallback_registered':\n          // Fallback registered\n          if (labels?.operation) {\n            metricsRegistry.degradationFallbacksRegisteredTotal.inc({\n              operation: labels.operation\n            });\n          }\n          break;\n        \n        case 'fallback_activated':\n          // Fallback activated\n          if (labels?.operation) {\n            metricsRegistry.degradationFallbackActivationsTotal.inc({\n              operation: labels.operation\n            });\n          }\n          break;\n        \n        case 'fallback_deactivated':\n          // Fallback deactivated\n          if (labels?.operation) {\n            metricsRegistry.degradationFallbackDeactivationsTotal.inc({\n              operation: labels.operation\n            });\n          }\n          break;\n        \n        case 'fallback_success':\n          // Fallback success\n          if (labels?.operation) {\n            metricsRegistry.degradationFallbackSuccessTotal.inc({\n              operation: labels.operation\n            });\n          }\n          break;\n        \n        case 'fallback_failure':\n          // Fallback failure\n          if (labels?.operation) {\n            metricsRegistry.degradationFallbackFailureTotal.inc({\n              operation: labels.operation\n            });\n          }\n          break;\n        \n        case 'operation_duration':\n          // Operation duration\n          if (labels?.operation && labels?.source && value !== undefined) {\n            metricsRegistry.degradationOperationDuration.observe({\n              operation: labels.operation,\n              source: labels.source\n            }, value);\n          }\n          break;\n        \n        case 'operation_failure':\n          // Operation failure\n          if (labels?.operation) {\n            metricsRegistry.degradationOperationFailuresTotal.inc({\n              operation: labels.operation\n            });\n          }\n          break;\n        \n        case 'cache_hit':\n          // Cache hit\n          if (labels?.operation) {\n            metricsRegistry.degradationCacheHitsTotal.inc({\n              operation: labels.operation\n            });\n          }\n          break;\n        \n        case 'retry_attempt':\n          // Retry attempt\n          if (labels?.operation && labels?.attempt) {\n            metricsRegistry.degradationRetryAttemptsTotal.inc({\n              operation: labels.operation,\n              attempt: labels.attempt\n            });\n          }\n          break;\n        \n        case 'retry_success':\n          // Retry success\n          if (labels?.operation && labels?.attempt) {\n            metricsRegistry.degradationRetrySuccessTotal.inc({\n              operation: labels.operation,\n              attempt: labels.attempt\n            });\n          }\n          break;\n        \n        case 'retry_failure':\n          // Retry failure\n          if (labels?.operation && labels?.attempt) {\n            metricsRegistry.degradationRetryFailureTotal.inc({\n              operation: labels.operation,\n              attempt: labels.attempt\n            });\n          }\n          break;\n      }\n    } catch (error) {\n      // Metrics module might not be available, or other error occurred\n      // This is non-critical, so just log at debug level\n      logger.debug(`Error updating graceful degradation metrics: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n}\n\n/**\n * Singleton instance of the graceful degradation service\n */\nexport const gracefulDegradation = new GracefulDegradation();\n\nexport default gracefulDegradation;\n",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/index.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'_originalConsole' is assigned a value but never used.",
          "line": 13,
          "column": 9,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 13,
          "endColumn": 25
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'createConnectionManager' is defined but never used.",
          "line": 47,
          "column": 10,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 47,
          "endColumn": 33
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'createTokenManager' is defined but never used.",
          "line": 48,
          "column": 10,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 48,
          "endColumn": 28
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'createResourceOptimizer' is defined but never used.",
          "line": 49,
          "column": 10,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 49,
          "endColumn": 33
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'createEnhancedApiClient' is defined but never used.",
          "line": 50,
          "column": 10,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 50,
          "endColumn": 33
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'ENABLE_RATE_LIMITING' is assigned a value but never used.",
          "line": 125,
          "column": 9,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 125,
          "endColumn": 29
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'RATE_LIMIT_REQUESTS_PER_MINUTE' is assigned a value but never used.",
          "line": 126,
          "column": 9,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 126,
          "endColumn": 39
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'params' is defined but never used. Allowed unused args must match /^_/u.",
          "line": 328,
          "column": 19,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 328,
          "endColumn": 25
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'request' is defined but never used. Allowed unused args must match /^_/u.",
          "line": 328,
          "column": 27,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 328,
          "endColumn": 34
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'apiClient' is assigned a value but never used.",
          "line": 388,
          "column": 11,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 388,
          "endColumn": 20
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'server' is assigned a value but never used.",
          "line": 1157,
          "column": 11,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 1157,
          "endColumn": 17
        }
      ],
      "suppressedMessages": [],
      "errorCount": 11,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "// Node.js built-in modules\nimport { randomUUID } from 'crypto';\nimport { createServer as createHttpServer } from 'http';\nimport { config as loadEnv } from 'dotenv';\n\n// Check if we're in MCP JSON-RPC mode (used by Claude Desktop)\nconst isMcpJsonRpcMode = process.env.MCP_JSON_RPC_MODE === 'true';\n\n// If in MCP mode, we need to be very careful about console output\n// as it would interfere with the JSON-RPC protocol\nif (isMcpJsonRpcMode) {\n  // In MCP mode, redirect all stdout console outputs to stderr\n  const _originalConsole = {\n    log: console.log,\n    info: console.info,\n    warn: console.warn\n  };\n  \n  // Only output errors and warnings to stderr, suppress other logs\n  console.log = () => {};\n  console.info = () => {};\n  // Keep console.error and console.warn as they go to stderr\n}\n\n// If NO_CONSOLE_OUTPUT is set, completely suppress console output\nif (process.env.NO_CONSOLE_OUTPUT === 'true') {\n  console.log = () => {};\n  console.error = () => {};\n  console.warn = () => {};\n  console.info = () => {};\n  console.debug = () => {};\n}\n\n// Load environment variables from .env file\nloadEnv();\n\n// External dependencies\nimport express from 'express';\n// import { z } from 'zod'; // Removed: unused\n\n// MCP SDK imports\nimport { McpServer, ResourceTemplate } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';\n\n// Local modules\nimport apiKeyContext, { extractApiKey, getApiKeyFromRequest } from './auth.js';\nimport { createConnectionManager } from './connection-manager.js';\nimport { createTokenManager } from './token-manager.js';\nimport { createResourceOptimizer } from './resource-optimizer.js';\nimport { createEnhancedApiClient, EnhancedDigitalSambaApiClient } from './digital-samba-api-enhanced.js';\n// import { CircuitBreakerApiClient } from './digital-samba-api-circuit-breaker.js'; // Removed: unused\n// import ResilientApiClient from './digital-samba-api-resilient.js'; // Removed: unused\nimport { MemoryCache } from './cache.js';\nimport { DigitalSambaApiClient } from './digital-samba-api.js';\nimport logger from './logger.js';\nimport metricsRegistry, { initializeMetrics } from './metrics.js';\nimport { createApiKeyRateLimiter } from './rate-limiter.js';\nimport { setupRecordingFunctionality } from './recordings.js';\nimport WebhookService, { setupWebhookTools } from './webhooks.js';\nimport gracefulDegradation, { ServiceHealthStatus } from './graceful-degradation.js';\n// import AnalyticsResource from './analytics.js'; // Removed: unused\n// import { setupSessionTools } from './sessions.js'; // Removed: unused\n\n// Import modular resources and tools\nimport { registerAnalyticsResources, handleAnalyticsResource } from './resources/analytics/index.js';\nimport { registerAnalyticsTools, executeAnalyticsTool } from './tools/analytics-tools/index.js';\nimport { registerSessionTools, executeSessionTool } from './tools/session-management/index.js';\nimport { registerRoomResources, handleRoomResource } from './resources/rooms/index.js';\nimport { registerRoomTools, executeRoomTool } from './tools/room-management/index.js';\nimport { registerSessionResources, handleSessionResource } from './resources/sessions/index.js';\nimport { registerExportResources, ExportResources } from './resources/exports/index.js';\nimport { registerLiveSessionTools, executeLiveSessionTool } from './tools/live-session-controls/index.js';\nimport { registerCommunicationTools, executeCommunicationTool } from './tools/communication-management/index.js';\nimport { registerPollTools, executePollTool } from './tools/poll-management/index.js';\nimport { registerLibraryTools, executeLibraryTool } from './tools/library-management/index.js';\nimport { registerContentResources, handleContentResource } from './resources/content/index.js';\n\n// Type definitions for server options\nexport interface ServerOptions {\n  port?: number;\n  apiUrl?: string;\n  webhookSecret?: string;\n  webhookEndpoint?: string;\n  publicUrl?: string;\n  enableRateLimiting?: boolean;\n  rateLimitRequestsPerMinute?: number;\n  enableCache?: boolean;\n  cacheTtl?: number;\n  enableConnectionManagement?: boolean;\n  enableTokenManagement?: boolean;\n  enableResourceOptimization?: boolean;\n  enableCircuitBreaker?: boolean;\n  circuitBreakerFailureThreshold?: number;\n  circuitBreakerResetTimeout?: number;\n  enableGracefulDegradation?: boolean;\n  gracefulDegradationMaxRetries?: number;\n  gracefulDegradationInitialDelay?: number;\n  connectionPoolSize?: number;\n  enableMetrics?: boolean;\n  metricsEndpoint?: string;\n  metricsPrefix?: string;\n  collectDefaultMetrics?: boolean;\n  enableSilentMode?: boolean; // Option for MCP mode\n  debugTimeouts?: boolean; // Enable timeout debugging\n  debugInitialization?: boolean; // Enable initialization debugging\n  initialRequestTimeout?: number; // Override initial request timeout\n  logLevel?: 'error' | 'warn' | 'info' | 'debug' | 'silly'; // Control log level\n  // Direct options for testing/debugging\n  apiKey?: string; // Direct API key for testing\n}\n\n// Create and configure the MCP server\nexport function createServer(options?: ServerOptions) {\n  // Configure environment\n  let PORT = 4521; // Uncommon port to avoid conflicts\n  if (options?.port !== undefined) {\n    PORT = options.port;\n  } else if (process.env.PORT) {\n    PORT = parseInt(process.env.PORT as string);\n  }\n  const API_URL = options?.apiUrl || process.env.DIGITAL_SAMBA_API_URL || 'https://api.digitalsamba.com/api/v1';\n  const WEBHOOK_SECRET = options?.webhookSecret || process.env.WEBHOOK_SECRET;\n  const WEBHOOK_ENDPOINT = options?.webhookEndpoint || process.env.WEBHOOK_ENDPOINT || '/webhooks/digitalsamba';\n  const PUBLIC_URL = options?.publicUrl || process.env.PUBLIC_URL || `http://localhost:${PORT}`;\n  const ENABLE_RATE_LIMITING = options?.enableRateLimiting !== undefined ? options.enableRateLimiting : process.env.ENABLE_RATE_LIMITING === 'true';\n  const RATE_LIMIT_REQUESTS_PER_MINUTE = options?.rateLimitRequestsPerMinute || (process.env.RATE_LIMIT_REQUESTS_PER_MINUTE ? parseInt(process.env.RATE_LIMIT_REQUESTS_PER_MINUTE) : 60);\n  const ENABLE_CACHE = options?.enableCache !== undefined ? options.enableCache : process.env.ENABLE_CACHE === 'true';\n  const CACHE_TTL = options?.cacheTtl || (process.env.CACHE_TTL ? parseInt(process.env.CACHE_TTL) : 5 * 60 * 1000); // 5 minutes default\n  const ENABLE_CONNECTION_MANAGEMENT = options?.enableConnectionManagement !== undefined ? options.enableConnectionManagement : process.env.ENABLE_CONNECTION_MANAGEMENT === 'true';\n  const ENABLE_TOKEN_MANAGEMENT = options?.enableTokenManagement !== undefined ? options.enableTokenManagement : process.env.ENABLE_TOKEN_MANAGEMENT === 'true';\n  const ENABLE_RESOURCE_OPTIMIZATION = options?.enableResourceOptimization !== undefined ? options.enableResourceOptimization : process.env.ENABLE_RESOURCE_OPTIMIZATION === 'true';\n  const ENABLE_CIRCUIT_BREAKER = options?.enableCircuitBreaker !== undefined ? options.enableCircuitBreaker : process.env.ENABLE_CIRCUIT_BREAKER === 'true';\n  const CIRCUIT_BREAKER_FAILURE_THRESHOLD = options?.circuitBreakerFailureThreshold || (process.env.CIRCUIT_BREAKER_FAILURE_THRESHOLD ? parseInt(process.env.CIRCUIT_BREAKER_FAILURE_THRESHOLD) : 5);\n  const CIRCUIT_BREAKER_RESET_TIMEOUT = options?.circuitBreakerResetTimeout || (process.env.CIRCUIT_BREAKER_RESET_TIMEOUT ? parseInt(process.env.CIRCUIT_BREAKER_RESET_TIMEOUT) : 30000);\n  const ENABLE_GRACEFUL_DEGRADATION = options?.enableGracefulDegradation !== undefined ? options.enableGracefulDegradation : process.env.ENABLE_GRACEFUL_DEGRADATION === 'true';\n  const GRACEFUL_DEGRADATION_MAX_RETRIES = options?.gracefulDegradationMaxRetries || (process.env.GRACEFUL_DEGRADATION_MAX_RETRIES ? parseInt(process.env.GRACEFUL_DEGRADATION_MAX_RETRIES) : 3);\n  const GRACEFUL_DEGRADATION_INITIAL_DELAY = options?.gracefulDegradationInitialDelay || (process.env.GRACEFUL_DEGRADATION_INITIAL_DELAY ? parseInt(process.env.GRACEFUL_DEGRADATION_INITIAL_DELAY) : 1000);\n  const CONNECTION_POOL_SIZE = options?.connectionPoolSize || (process.env.CONNECTION_POOL_SIZE ? parseInt(process.env.CONNECTION_POOL_SIZE) : 5);\n  const ENABLE_METRICS = options?.enableMetrics !== undefined ? options.enableMetrics : process.env.ENABLE_METRICS === 'true';\n  const METRICS_ENDPOINT = options?.metricsEndpoint || process.env.METRICS_ENDPOINT || '/metrics';\n  const METRICS_PREFIX = options?.metricsPrefix || process.env.METRICS_PREFIX || 'digital_samba_mcp_';\n  const COLLECT_DEFAULT_METRICS = options?.collectDefaultMetrics !== undefined ? options.collectDefaultMetrics : process.env.COLLECT_DEFAULT_METRICS === 'true';\n\n  // Create the MCP server\n  const server = new McpServer({\n    name: 'Digital Samba MCP Server',\n    version: '0.1.0',\n  });\n  \n  // Initialize cache if enabled\n  let apiCache: MemoryCache | undefined;\n  if (ENABLE_CACHE) {\n    logger.info('Initializing API response cache', { cacheTtl: CACHE_TTL });\n    apiCache = new MemoryCache({\n      ttl: CACHE_TTL,\n      maxItems: 1000,\n      useEtag: true\n    });\n  }\n\n  // Create webhook service\n  const webhookService = new WebhookService(server, {\n    secret: WEBHOOK_SECRET,\n    endpoint: WEBHOOK_ENDPOINT\n  });\n\n  // Set up webhook tools\n  setupWebhookTools(server, webhookService, API_URL);\n  \n  // Set up recording functionality\n  setupRecordingFunctionality(server, API_URL);\n  \n  // Note: Session tools are now registered through the modular system below\n  // setupSessionTools(server, API_URL) - removed to avoid duplicate registration\n\n  // -------------------------------------------------------------------\n  // Analytics Resources (Modular)\n  // -------------------------------------------------------------------\n\n  // Register analytics resources using the modular approach\n  const analyticsResources = registerAnalyticsResources(new DigitalSambaApiClient(undefined, API_URL, apiCache));\n  \n  // Register each analytics resource with the server\n  analyticsResources.forEach(resource => {\n    server.resource(\n      resource.name,\n      new ResourceTemplate(resource.uri, { list: undefined }),\n      async (uri, _params, _request) => {\n        logger.info(`Handling analytics resource: ${resource.name}`);\n        \n        const apiKey = getApiKeyFromRequest(_request);\n        if (!apiKey) {\n          throw new Error('No API key found. Please include an Authorization header with a Bearer token.');\n        }\n        \n        const client = new DigitalSambaApiClient(undefined, API_URL, apiCache);\n        \n        try {\n          // Use the modular handler\n          const data = await handleAnalyticsResource(uri.href, client);\n          \n          // Format the response based on the resource type\n          if (resource.name === 'analytics-participants') {\n            const contents = data.map(participant => ({\n              uri: `digitalsamba://analytics/participants/${participant.participant_id}`,\n              text: JSON.stringify(participant, null, 2),\n            }));\n            return { contents };\n          } else if (resource.name === 'analytics-rooms') {\n            const contents = data.map(room => ({\n              uri: `digitalsamba://analytics/rooms/${room.room_id}`,\n              text: JSON.stringify(room, null, 2),\n            }));\n            return { contents };\n          } else {\n            // For single resources like usage and team\n            return {\n              contents: [{\n                uri: uri.href,\n                text: JSON.stringify(data, null, 2),\n              }]\n            };\n          }\n        } catch (error) {\n          logger.error(`Error in analytics resource ${resource.name}`, { \n            error: error instanceof Error ? error.message : String(error) \n          });\n          throw error;\n        }\n      }\n    );\n  });\n\n  // -------------------------------------------------------------------\n  // Room Resources (Modular)\n  // -------------------------------------------------------------------\n\n  // Register room resources using the modular approach\n  const roomResources = registerRoomResources();\n  \n  // Register each room resource with the server\n  roomResources.forEach(resource => {\n    server.resource(\n      resource.name,\n      new ResourceTemplate(resource.uri, { list: undefined }),\n      async (uri, _params, _request) => {\n        logger.info(`Handling room resource: ${resource.name}`);\n        \n        try {\n          // Use the modular handler with all the configuration options\n          const result = await handleRoomResource(\n            uri.href,\n            _params,\n            _request,\n            {\n              apiUrl: API_URL,\n              apiKey: options?.apiKey,\n              apiCache,\n              enableConnectionManagement: ENABLE_CONNECTION_MANAGEMENT,\n              enableTokenManagement: ENABLE_TOKEN_MANAGEMENT,\n              enableResourceOptimization: ENABLE_RESOURCE_OPTIMIZATION,\n              connectionPoolSize: CONNECTION_POOL_SIZE\n            }\n          );\n          \n          return result;\n        } catch (error) {\n          logger.error(`Error in room resource ${resource.name}`, { \n            error: error instanceof Error ? error.message : String(error) \n          });\n          throw error;\n        }\n      }\n    );\n  });\n\n  // -------------------------------------------------------------------\n  // Session Resources (Modular)\n  // -------------------------------------------------------------------\n\n  // Register session resources using the modular approach\n  const sessionResources = registerSessionResources();\n  \n  // Register each session resource with the server\n  sessionResources.forEach(resource => {\n    server.resource(\n      resource.name,\n      new ResourceTemplate(resource.uri, { list: undefined }),\n      async (uri, params, request) => {\n        logger.info(`Handling session resource: ${resource.name}`);\n        \n        try {\n          // Use the modular handler\n          const result = await handleSessionResource(\n            uri.href,\n            params,\n            request,\n            {\n              apiUrl: API_URL,\n              apiCache\n            }\n          );\n          \n          return result;\n        } catch (error) {\n          logger.error(`Error in session resource ${resource.name}`, { \n            error: error instanceof Error ? error.message : String(error) \n          });\n          throw error;\n        }\n      }\n    );\n  });\n\n  // -------------------------------------------------------------------\n  // Export Resources (Modular)\n  // -------------------------------------------------------------------\n\n  // Register export resources using the modular approach\n  const exportResources = registerExportResources();\n  const exportResourceHandler = new ExportResources(new DigitalSambaApiClient(undefined, API_URL, apiCache));\n  \n  // Register each export resource with the server\n  exportResources.forEach(resource => {\n    server.resource(\n      resource.name,\n      new ResourceTemplate(resource.uri, { list: undefined }),\n      async (uri, params, request) => {\n        logger.info(`Handling export resource: ${resource.name}`);\n        \n        try {\n          // Use the export resource handler\n          const result = await exportResourceHandler.handleResourceRequest(uri.href);\n          \n          return result;\n        } catch (error) {\n          logger.error(`Error in export resource ${resource.name}`, { \n            error: error instanceof Error ? error.message : String(error) \n          });\n          throw error;\n        }\n      }\n    );\n  });\n\n\n  // -------------------------------------------------------------------\n  // Room Management Tools (Modular)\n  // -------------------------------------------------------------------\n\n  // Register room management tools using the modular approach\n  const roomTools = registerRoomTools();\n  \n  // Register each room tool with the server\n  roomTools.forEach(tool => {\n    server.tool(\n      tool.name,\n      tool.inputSchema,\n      async (params, request) => {\n        logger.info(`Executing room tool: ${tool.name}`);\n        \n        // Create API client with appropriate configuration\n        const apiKey = getApiKeyFromRequest(request);\n        if (!apiKey) {\n          return {\n            content: [{ \n              type: 'text', \n              text: 'No API key found. Please include an Authorization header with a Bearer token.'\n            }],\n            isError: true,\n          };\n        }\n        \n        let apiClient;\n        if (ENABLE_CONNECTION_MANAGEMENT || ENABLE_TOKEN_MANAGEMENT || ENABLE_RESOURCE_OPTIMIZATION) {\n          apiClient = new EnhancedDigitalSambaApiClient(\n            apiKey,\n            API_URL,\n            apiCache,\n            {\n              enableConnectionManagement: ENABLE_CONNECTION_MANAGEMENT,\n              enableTokenManagement: ENABLE_TOKEN_MANAGEMENT,\n              enableResourceOptimization: ENABLE_RESOURCE_OPTIMIZATION,\n              connectionPoolSize: CONNECTION_POOL_SIZE\n            }\n          );\n        } else {\n          apiClient = new DigitalSambaApiClient(apiKey, API_URL, apiCache);\n        }\n        \n        // Execute the tool using the modular function\n        return executeRoomTool(tool.name, params, request, {\n          apiUrl: API_URL,\n          apiCache,\n          enableConnectionManagement: ENABLE_CONNECTION_MANAGEMENT,\n          enableTokenManagement: ENABLE_TOKEN_MANAGEMENT,\n          enableResourceOptimization: ENABLE_RESOURCE_OPTIMIZATION,\n          connectionPoolSize: CONNECTION_POOL_SIZE\n        });\n      }\n    );\n  });\n\n  // -------------------------------------------------------------------\n  // Analytics Tools (Modular)\n  // -------------------------------------------------------------------\n\n  // Register analytics tools using the modular approach\n  const analyticsTools = registerAnalyticsTools();\n  \n  // Register each analytics tool with the server\n  analyticsTools.forEach(tool => {\n    server.tool(\n      tool.name,\n      tool.inputSchema,\n      async (params, request) => {\n        logger.info(`Executing analytics tool: ${tool.name}`);\n        \n        // Create API client\n        const apiKey = getApiKeyFromRequest(request);\n        if (!apiKey) {\n          return {\n            content: [{ \n              type: 'text', \n              text: 'No API key found. Please include an Authorization header with a Bearer token.'\n            }],\n            isError: true,\n          };\n        }\n        \n        const apiClient = new DigitalSambaApiClient(apiKey, API_URL, apiCache);\n        \n        // Execute the tool using the modular function\n        return executeAnalyticsTool(tool.name, params, apiClient);\n      }\n    );\n  });\n\n  // -------------------------------------------------------------------\n  // Session Management Tools (Modular)\n  // -------------------------------------------------------------------\n\n  // Register session management tools using the modular approach\n  const sessionTools = registerSessionTools();\n\n  // Register each session tool with the server\n  sessionTools.forEach(tool => {\n    server.tool(\n      tool.name,\n      tool.inputSchema,\n      async (params, request) => {\n        logger.info(`Executing session tool: ${tool.name}`);\n        \n        // Create API client\n        const apiKey = getApiKeyFromRequest(request);\n        if (!apiKey) {\n          return {\n            content: [{ \n              type: 'text', \n              text: 'No API key found. Please include an Authorization header with a Bearer token.'\n            }],\n            isError: true,\n          };\n        }\n        \n        const apiClient = new DigitalSambaApiClient(apiKey, API_URL, apiCache);\n        \n        // Execute the tool using the modular function\n        return executeSessionTool(tool.name, params, apiClient, request);\n      }\n    );\n  });\n\n  // -------------------------------------------------------------------\n  // Live Session Control Tools (Modular)\n  // -------------------------------------------------------------------\n\n  // Register live session control tools using the modular approach\n  const liveSessionTools = registerLiveSessionTools();\n\n  // Register each live session tool with the server\n  liveSessionTools.forEach(tool => {\n    server.tool(\n      tool.name,\n      tool.inputSchema,\n      async (params, request) => {\n        logger.info(`Executing live session tool: ${tool.name}`);\n        \n        // Create API client\n        const apiKey = getApiKeyFromRequest(request);\n        if (!apiKey) {\n          return {\n            content: [{ \n              type: 'text', \n              text: 'No API key found. Please include an Authorization header with a Bearer token.'\n            }],\n            isError: true,\n          };\n        }\n        \n        const apiClient = new DigitalSambaApiClient(apiKey, API_URL, apiCache);\n        \n        // Execute the tool using the modular function\n        return executeLiveSessionTool(tool.name, params, apiClient);\n      }\n    );\n  });\n\n  // -------------------------------------------------------------------\n  // Communication Management Tools (Modular)\n  // -------------------------------------------------------------------\n\n  // Register communication management tools using the modular approach\n  const communicationTools = registerCommunicationTools();\n\n  // Register each communication tool with the server\n  communicationTools.forEach(tool => {\n    server.tool(\n      tool.name,\n      tool.inputSchema,\n      async (params, request) => {\n        logger.info(`Executing communication tool: ${tool.name}`);\n        \n        // Create API client\n        const apiKey = getApiKeyFromRequest(request);\n        if (!apiKey) {\n          return {\n            content: [{ \n              type: 'text', \n              text: 'No API key found. Please include an Authorization header with a Bearer token.'\n            }],\n            isError: true,\n          };\n        }\n        \n        const apiClient = new DigitalSambaApiClient(apiKey, API_URL, apiCache);\n        \n        // Execute the tool using the modular function\n        return executeCommunicationTool(tool.name, params, apiClient);\n      }\n    );\n  });\n\n  // -------------------------------------------------------------------\n  // Poll Management Tools (Modular)\n  // -------------------------------------------------------------------\n\n  // Register poll management tools using the modular approach\n  const pollTools = registerPollTools();\n\n  // Register each poll tool with the server\n  pollTools.forEach(tool => {\n    server.tool(\n      tool.name,\n      tool.inputSchema,\n      async (params, request) => {\n        logger.info(`Executing poll tool: ${tool.name}`);\n        \n        // Create API client\n        const apiKey = getApiKeyFromRequest(request);\n        if (!apiKey) {\n          return {\n            content: [{ \n              type: 'text', \n              text: 'No API key found. Please include an Authorization header with a Bearer token.'\n            }],\n            isError: true,\n          };\n        }\n        \n        const apiClient = new DigitalSambaApiClient(apiKey, API_URL, apiCache);\n        \n        // Execute the tool using the modular function\n        return executePollTool(tool.name, params, apiClient);\n      }\n    );\n  });\n\n  // -------------------------------------------------------------------\n  // Library Management Tools (Modular)\n  // -------------------------------------------------------------------\n\n  // Register library management tools using the modular approach\n  const libraryTools = registerLibraryTools();\n\n  // Register each library tool with the server\n  libraryTools.forEach(tool => {\n    server.tool(\n      tool.name,\n      tool.inputSchema,\n      async (params, request) => {\n        logger.info(`Executing library tool: ${tool.name}`);\n        \n        // Create API client\n        const apiKey = getApiKeyFromRequest(request);\n        if (!apiKey) {\n          return {\n            content: [{ \n              type: 'text', \n              text: 'No API key found. Please include an Authorization header with a Bearer token.'\n            }],\n            isError: true,\n          };\n        }\n        \n        const apiClient = new DigitalSambaApiClient(apiKey, API_URL, apiCache);\n        \n        // Execute the tool using the modular function\n        return executeLibraryTool(tool.name, params, apiClient);\n      }\n    );\n  });\n\n  // -------------------------------------------------------------------\n  // Content Resources (Modular)\n  // -------------------------------------------------------------------\n\n  // Register content resources using the modular approach\n  const contentResources = registerContentResources();\n\n  // Register each content resource with the server\n  contentResources.forEach(resource => {\n    server.resource(\n      resource.name,\n      new ResourceTemplate(resource.uri, { list: undefined }),\n      async (uri, params, request) => {\n        logger.info(`Handling content resource: ${resource.name}`);\n        \n        const apiKey = getApiKeyFromRequest(request);\n        if (!apiKey) {\n          return {\n            content: [{\n              type: 'text',\n              text: JSON.stringify({\n                error: 'No API key found. Please include an Authorization header with a Bearer token.',\n                timestamp: new Date().toISOString()\n              }, null, 2)\n            }]\n          };\n        }\n        \n        const apiClient = new DigitalSambaApiClient(apiKey, API_URL, apiCache);\n        \n        try {\n          return await handleContentResource(uri.href, apiClient);\n        } catch (error) {\n          logger.error('Error handling content resource', { \n            uri: uri.href,\n            error: error instanceof Error ? error.message : String(error) \n          });\n          throw error;\n        }\n      }\n    );\n  });\n\n  // [INLINE TOOLS REMOVED - Now using modular approach]\n  // All tools are registered through their respective modules above\n\n  return { \n    server, \n    port: PORT, \n    apiUrl: API_URL, \n    webhookEndpoint: WEBHOOK_ENDPOINT, \n    publicUrl: PUBLIC_URL,\n    cache: apiCache,\n    enableConnectionManagement: ENABLE_CONNECTION_MANAGEMENT,\n    enableTokenManagement: ENABLE_TOKEN_MANAGEMENT,\n    enableResourceOptimization: ENABLE_RESOURCE_OPTIMIZATION,\n    enableCircuitBreaker: ENABLE_CIRCUIT_BREAKER,\n    circuitBreakerFailureThreshold: CIRCUIT_BREAKER_FAILURE_THRESHOLD,\n    circuitBreakerResetTimeout: CIRCUIT_BREAKER_RESET_TIMEOUT,\n    enableGracefulDegradation: ENABLE_GRACEFUL_DEGRADATION,\n    gracefulDegradationMaxRetries: GRACEFUL_DEGRADATION_MAX_RETRIES,\n    gracefulDegradationInitialDelay: GRACEFUL_DEGRADATION_INITIAL_DELAY,\n    enableMetrics: ENABLE_METRICS,\n    metricsEndpoint: METRICS_ENDPOINT,\n    metricsPrefix: METRICS_PREFIX,\n    collectDefaultMetrics: COLLECT_DEFAULT_METRICS\n  };\n}\n\n// Start a server with the provided options\nexport function startServer(options?: ServerOptions) {\n  // Check if we should run in silent mode\n  const enableSilentMode = options?.enableSilentMode || process.env.MCP_JSON_RPC_MODE === 'true';\n  \n  // Only log if not in silent mode\n  const shouldLog = !enableSilentMode && process.env.NO_CONSOLE_OUTPUT !== 'true';\n  \n  if (shouldLog) logger.debug(\"startServer function called with options:\", options);\n  \n  try {\n    // Detect debug options\n    const debugTimeouts = options?.debugTimeouts || process.env.DEBUG_TIMEOUTS === 'true';\n    const debugInitialization = options?.debugInitialization || process.env.DEBUG_INITIALIZATION === 'true';\n    const initialRequestTimeout = options?.initialRequestTimeout || \n                              process.env.INITIAL_REQUEST_TIMEOUT ? \n                              parseInt(process.env.INITIAL_REQUEST_TIMEOUT) : 60000;\n    \n    if (debugTimeouts) {\n      logger.info(\"Timeout debugging enabled\");\n      console.log(\"Timeout debugging enabled\");\n      console.log(\"Initial request timeout:\", initialRequestTimeout);\n      \n      // Set the environment variable for child processes\n      process.env.DEBUG_TIMEOUTS = 'true';\n      process.env.INITIAL_REQUEST_TIMEOUT = initialRequestTimeout.toString();\n    }\n    \n    if (debugInitialization) {\n      logger.info(\"Initialization debugging enabled\");\n      console.log(\"Initialization debugging enabled\");\n      \n      // Set the environment variable for child processes\n      process.env.DEBUG_INITIALIZATION = 'true';\n    }\n    \n    // Create Express app\n    if (shouldLog) logger.debug(\"Creating Express app...\");\n    const app = express();\n    app.use(express.json());\n    if (shouldLog) logger.debug(\"Express app created and JSON middleware added\");\n\n    // Create the MCP server\n    if (shouldLog) logger.debug(\"Creating MCP server...\");\n    const serverConfig = createServer({\n      ...options,\n      initialRequestTimeout,\n      debugTimeouts,\n      debugInitialization\n    });\n    \n    // Add metrics middleware if enabled\n    if (serverConfig.enableMetrics) {\n      if (shouldLog) logger.debug(\"Adding metrics middleware...\");\n      app.use(metricsRegistry.createHttpMetricsMiddleware());\n      metricsRegistry.registerMetricsEndpoint(app, serverConfig.metricsEndpoint);\n      if (shouldLog) logger.debug(`Metrics endpoint registered at ${serverConfig.metricsEndpoint}`);\n    }\n    const { \n      server, \n      port, \n      apiUrl, \n      webhookEndpoint, \n      publicUrl, \n      cache, \n      enableConnectionManagement, \n      enableTokenManagement, \n      enableResourceOptimization,\n      enableMetrics,\n      metricsEndpoint,\n      metricsPrefix,\n      collectDefaultMetrics\n    } = serverConfig;\n    if (shouldLog) logger.debug(\"MCP server created with configuration:\", { \n      port, \n      apiUrl, \n      webhookEndpoint, \n      publicUrl, \n      hasCache: !!cache,\n      enableConnectionManagement,\n      enableTokenManagement,\n      enableResourceOptimization,\n      enableMetrics,\n      metricsEndpoint\n    });\n    \n    // Initialize metrics if enabled\n    if (enableMetrics) {\n      console.log(\"Initializing metrics collection...\");\n      const metrics = initializeMetrics({\n        prefix: metricsPrefix,\n        defaultMetrics: collectDefaultMetrics,\n        enableHttpMetrics: true,\n        enableApiMetrics: true,\n        enableCacheMetrics: cache !== undefined,\n        enableRateLimitMetrics: options?.enableRateLimiting || process.env.ENABLE_RATE_LIMITING === 'true'\n      });\n      \n      // Track active sessions\n      metrics.activeSessions.set(0);\n      console.log(\"Metrics collection initialized\");\n    }\n\n    // Map to store transports by session ID\n    const transports: { [sessionId: string]: StreamableHTTPServerTransport } = {};\n    console.log(\"Transport map initialized\");\n    \n    // Add rate limiting middleware if enabled\n    if (options?.enableRateLimiting || process.env.ENABLE_RATE_LIMITING === 'true') {\n      const requestsPerMinute = options?.rateLimitRequestsPerMinute || \n        (process.env.RATE_LIMIT_REQUESTS_PER_MINUTE ? parseInt(process.env.RATE_LIMIT_REQUESTS_PER_MINUTE) : 60);\n      \n      console.log(\"Enabling rate limiting:\", { requestsPerMinute });\n      logger.info('Enabling rate limiting', { requestsPerMinute });\n      app.use('/mcp', createApiKeyRateLimiter({\n        maxRequests: requestsPerMinute,\n        windowMs: 60 * 1000, // 1 minute\n        message: 'Too many requests from this API key, please try again later.'\n      }));\n      console.log(\"Rate limiting middleware added\");\n    }\n\n    // Handle POST requests for client-to-server communication\n    console.log(\"Setting up POST handler for /mcp...\");\n    app.post('/mcp', async (req, res) => {\n      try {\n        console.log(\"Received POST request to /mcp\");\n        logger.info('Received POST MCP request', { \n          contentLength: req.headers['content-length'],\n          sessionId: req.headers['mcp-session-id'] || 'new-session'\n        });\n        \n        // Extract API key from Authorization header\n        const apiKey = extractApiKey(req);\n        if (apiKey) {\n          console.log(\"Found API key in Authorization header\");\n          logger.debug('Found API key in Authorization header');\n        }\n        \n        // Check for existing session ID\n        const sessionId = req.headers['mcp-session-id'] as string | undefined;\n        let transport: StreamableHTTPServerTransport;\n        \n        if (sessionId && transports[sessionId]) {\n          // Reuse existing transport\n          transport = transports[sessionId];\n          console.log(`Using existing transport for session: ${sessionId}`);\n          logger.debug(`Using existing transport for session: ${sessionId}`);\n          \n          // Update API key if provided\n          if (apiKey) {\n            apiKeyContext.setApiKey(sessionId, apiKey);\n          }\n        } else {\n          // Create new transport\n          console.log(\"Creating new transport\");\n          transport = new StreamableHTTPServerTransport({\n            sessionIdGenerator: () => randomUUID(),\n            onsessioninitialized: (sessionId: string) => {\n              // Store the transport by session ID\n              transports[sessionId] = transport;\n              console.log(`Initialized new session: ${sessionId}`);\n              logger.info(`Initialized new session: ${sessionId}`);\n              \n              // Store API key in the context if provided\n              if (apiKey) {\n                apiKeyContext.setApiKey(sessionId, apiKey);\n              }\n              \n              // Update session metrics if enabled\n              if (enableMetrics) {\n                metricsRegistry.activeSessions.inc();\n              }\n            },\n            // No timeout option is available for StreamableHTTPServerTransport\n            // We'll rely on circuit breaker timeouts instead\n          });\n          \n          // Clean up transport when closed\n          transport.onclose = () => {\n            if (transport.sessionId) {\n              console.log(`Closing session: ${transport.sessionId}`);\n              logger.info(`Closing session: ${transport.sessionId}`);\n              apiKeyContext.removeApiKey(transport.sessionId);\n              delete transports[transport.sessionId];\n              \n              // Update session metrics if enabled\n              if (enableMetrics) {\n                metricsRegistry.activeSessions.dec();\n              }\n            }\n          };\n          \n          // Connect to the MCP server\n          console.log(\"Connecting transport to MCP server...\");\n          await server.connect(transport);\n          console.log(\"Transport connected to MCP server\");\n          logger.info('Connected transport to MCP server');\n        }\n        \n        // Handle the request\n        console.log(\"Handling MCP request...\");\n        await transport.handleRequest(req, res, req.body);\n        console.log(\"MCP request handled successfully\");\n      } catch (error) {\n        console.error(\"Error handling MCP request:\", error);\n        logger.error('Error handling MCP request:', { \n          error: error instanceof Error ? error.message : String(error),\n          stack: error instanceof Error ? error.stack : undefined\n        });\n        \n        if (!res.headersSent) {\n          res.status(500).json({\n            jsonrpc: '2.0',\n            error: {\n              code: -32603,\n              message: error instanceof Error ? error.message : 'Internal server error',\n            },\n            id: null,\n          });\n        }\n      }\n    });\n    console.log(\"POST handler for /mcp set up successfully\");\n\n    // Reusable handler for GET and DELETE requests\n    console.log(\"Setting up session request handler...\");\n    const handleSessionRequest = async (req: express.Request, res: express.Response) => {\n      try {\n        const sessionId = req.headers['mcp-session-id'] as string | undefined;\n        if (!sessionId || !transports[sessionId]) {\n          console.warn(`Invalid or missing session ID: ${sessionId}`);\n          logger.warn(`Invalid or missing session ID: ${sessionId}`);\n          res.status(400).send('Invalid or missing session ID');\n          return;\n        }\n        \n        // Extract API key from Authorization header\n        const apiKey = extractApiKey(req);\n        if (apiKey) {\n          console.log(\"Found API key in Authorization header\");\n          logger.debug('Found API key in Authorization header');\n          apiKeyContext.setApiKey(sessionId, apiKey);\n        }\n        \n        console.log(`Processing ${req.method} request for session: ${sessionId}`);\n        logger.info(`Processing ${req.method} request for session: ${sessionId}`);\n        const transport = transports[sessionId];\n        await transport.handleRequest(req, res);\n      } catch (error) {\n        console.error(\"Error handling session request:\", error);\n        logger.error('Error handling session request:', { \n          error: error instanceof Error ? error.message : String(error),\n          stack: error instanceof Error ? error.stack : undefined\n        });\n        \n        if (!res.headersSent) {\n          res.status(500).send('Internal server error');\n        }\n      }\n    };\n    console.log(\"Session request handler created\");\n\n    // Handle GET requests for server-to-client notifications via SSE\n    console.log(\"Setting up GET handler for /mcp...\");\n    app.get('/mcp', handleSessionRequest);\n    console.log(\"GET handler for /mcp set up successfully\");\n\n    // Handle DELETE requests for session termination\n    console.log(\"Setting up DELETE handler for /mcp...\");\n    app.delete('/mcp', handleSessionRequest);\n    console.log(\"DELETE handler for /mcp set up successfully\");\n\n    // Health check endpoint\n    console.log(\"Setting up health check endpoint...\");\n    app.get('/health', (req, res) => {\n      console.log(\"Received request to /health\");\n      \n      // Always respond with 200 OK for health checks\n      // This is critical for the proxy to work correctly\n      try {\n        res.status(200).json({\n          status: 'ok',\n          timestamp: new Date().toISOString(),\n          version: '0.1.0',\n          name: 'Digital Samba MCP Server',\n          port: port,\n          apiUrl: apiUrl,\n          environment: process.env.NODE_ENV || 'development'\n        });\n        console.log(\"Health check responded successfully\");\n      } catch (error) {\n        console.error(\"Error in health check response:\", error);\n        // Even if there's an error, still try to send a 200 response\n        if (!res.headersSent) {\n          res.status(200).send('Health check OK');\n        }\n      }\n    });\n    console.log(\"Health check endpoint set up successfully\");\n    \n    // Secondary health check endpoint on root path\n    // This provides a fallback if '/health' is not accessible\n    app.get('/', (req, res) => {\n      console.log(\"Received request to root path\");\n      res.status(200).send('Digital Samba MCP Server is running');\n    });\n\n    // System health status endpoint\n    console.log(\"Setting up system health endpoint...\");\n    app.get('/health/system', (req, res) => {\n      console.log(\"Received request to /health/system\");\n      \n      // Get graceful degradation health status\n      const overallHealth = gracefulDegradation.getOverallHealth();\n      const componentHealth = gracefulDegradation.getComponentHealth();\n      \n      // Format component health for response\n      const formattedComponents = componentHealth.map(component => ({\n        name: component.name,\n        status: component.status,\n        lastCheck: component.lastCheck,\n        errorCount: component.errorCount,\n        message: component.message\n      }));\n      \n      res.status(200).json({\n        status: overallHealth === ServiceHealthStatus.HEALTHY ? 'ok' : \n                overallHealth === ServiceHealthStatus.PARTIALLY_DEGRADED ? 'degraded' : \n                overallHealth === ServiceHealthStatus.SEVERELY_DEGRADED ? 'critical' : 'unavailable',\n        timestamp: new Date().toISOString(),\n        version: '0.1.0',\n        name: 'Digital Samba MCP Server',\n        degradation: {\n          overall: overallHealth,\n          components: formattedComponents\n        },\n        features: {\n          cache: options?.enableCache ?? (process.env.ENABLE_CACHE === 'true'),\n          circuitBreaker: options?.enableCircuitBreaker ?? (process.env.ENABLE_CIRCUIT_BREAKER === 'true'),\n          gracefulDegradation: options?.enableGracefulDegradation ?? (process.env.ENABLE_GRACEFUL_DEGRADATION === 'true'),\n          connectionManagement: options?.enableConnectionManagement ?? (process.env.ENABLE_CONNECTION_MANAGEMENT === 'true'),\n          tokenManagement: options?.enableTokenManagement ?? (process.env.ENABLE_TOKEN_MANAGEMENT === 'true'),\n          resourceOptimization: options?.enableResourceOptimization ?? (process.env.ENABLE_RESOURCE_OPTIMIZATION === 'true'),\n          metrics: options?.enableMetrics ?? (process.env.ENABLE_METRICS === 'true')\n        }\n      });\n    });\n    console.log(\"System health endpoint set up successfully\");\n\n    // Get the webhook service instance\n    console.log(\"Setting up webhook service...\");\n    const webhookService = new WebhookService(server, {\n      secret: process.env.WEBHOOK_SECRET,\n      endpoint: webhookEndpoint\n    });\n\n    // Register webhook endpoint\n    console.log(\"Registering webhook endpoint...\");\n    webhookService.registerWebhookEndpoint(app);\n    console.log(\"Webhook endpoint registered successfully\");\n\n    // Start the server\n    console.log(\"Creating HTTP server...\");\n    const httpServer = createHttpServer(app);\n    console.log(\"HTTP server created\");\n\n    console.log(`Starting server on port ${port}...`);\n    httpServer.listen(port, () => {\n      console.log(`Digital Samba MCP Server running on port ${port}`);\n      logger.info(`Digital Samba MCP Server running on port ${port}`);\n      logger.info(`Digital Samba API URL: ${apiUrl}`);\n      logger.info(`Webhook endpoint: ${publicUrl}${webhookEndpoint}`);\n      \n      if (enableMetrics) {\n        logger.info(`Metrics endpoint: ${publicUrl}${metricsEndpoint}`);\n      }\n    });\n    console.log(\"Server listen call completed\");\n\n    // Handle graceful shutdown\n    process.on('SIGTERM', () => {\n      console.log('SIGTERM received, shutting down gracefully');\n      logger.info('SIGTERM received, shutting down gracefully');\n      httpServer.close(() => {\n        logger.info('HTTP server closed');\n      });\n      \n      // Close all transport connections\n      Object.keys(transports).forEach(sessionId => {\n        logger.info(`Closing transport for session: ${sessionId}`);\n        transports[sessionId].close();\n      });\n      \n      process.exit(0);\n    });\n\n    process.on('SIGINT', () => {\n      console.log('SIGINT received, shutting down gracefully');\n      logger.info('SIGINT received, shutting down gracefully');\n      httpServer.close(() => {\n        logger.info('HTTP server closed');\n      });\n      \n      // Close all transport connections\n      Object.keys(transports).forEach(sessionId => {\n        logger.info(`Closing transport for session: ${sessionId}`);\n        transports[sessionId].close();\n      });\n      \n      process.exit(0);\n    });\n    \n    console.log(\"Server startup completed successfully\");\n    return httpServer;\n  } catch (error) {\n    console.error(\"Error in startServer function:\", error);\n    logger.error(\"Failed to start server:\", {\n      error: error instanceof Error ? error.message : String(error),\n      stack: error instanceof Error ? error.stack : undefined\n    });\n    throw error;\n  }\n}\n\n// Export transport functions for unified API\nexport { runStdioServer, validateStdioConfig } from './transports/stdio-transport.js';\nexport { runHttpServer, createHttpServerConfig, validateHttpConfig } from './transports/http-transport.js';\n\n// If this file is executed directly or via npm run dev, start the server\n// Only start if the file is executed directly, not when imported\n// The module initialization check had to be rewritten to work with tsx\nconst isMainModule = () => {\n  // In a more straightforward environment, we would check:\n  // import.meta.url === `file://${process.argv[1]}`\n  // But with tsx and different environments, we need to be more flexible\n  \n  // Allow explicit opt-out via environment variable\n  if (process.env.MCP_DISABLE_AUTO_START === 'true') {\n    console.log(\"Auto-start disabled by MCP_DISABLE_AUTO_START environment variable\");\n    return false;\n  }\n  \n  // Check if this is a test environment\n  if (process.env.NODE_ENV === 'test') {\n    console.log(\"Not starting server in test environment\");\n    return false;\n  }\n  \n  // Allow explicit opt-in via environment variable\n  if (process.env.MCP_FORCE_START === 'true') {\n    console.log(\"Auto-start forced by MCP_FORCE_START environment variable\");\n    return true;\n  }\n  \n  return true; // Default to starting the server\n};\n\nif (isMainModule()) {\n  console.log(\"Starting server initialization...\");\n  \n  try {\n    console.log(\"Creating server instance...\");\n    const serverConfig = createServer();\n    console.log(\"Server created:\", serverConfig);\n    \n    console.log(\"Starting server with config:\", {\n      port: serverConfig.port,\n      apiUrl: serverConfig.apiUrl,\n      webhookEndpoint: serverConfig.webhookEndpoint,\n      publicUrl: serverConfig.publicUrl,\n      cacheEnabled: !!serverConfig.cache\n    });\n    \n    const server = startServer();\n    console.log(`Server started successfully`);\n  } catch (error) {\n    console.error('Failed to start server:', error);\n    logger.error('Failed to start server:', { \n      error: error instanceof Error ? error.message : String(error),\n      stack: error instanceof Error ? error.stack : undefined\n    });\n    process.exit(1);\n  }\n}\n",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/logger.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 43,
          "column": 18,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 43,
          "endColumn": 21,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1001,
                  1004
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1001,
                  1004
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 180,
          "column": 35,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 180,
          "endColumn": 38,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  5295,
                  5298
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  5295,
                  5298
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 182,
          "column": 35,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 182,
          "endColumn": 38,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  5365,
                  5368
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  5365,
                  5368
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 3,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Logger configuration for Digital Samba MCP Server\n * \n * This module configures a Winston logger with console and file transports.\n * It provides structured logging with timestamps and supports different log levels\n * that can be configured through the LOG_LEVEL environment variable.\n *\n * @module logger\n * @author Digital Samba Team\n * @version 0.1.0\n */\n\n// Node.js built-in modules\nimport os from 'os';\nimport { randomUUID } from 'crypto';\n\n// External dependencies\nimport winston from 'winston';\nconst { format, createLogger, transports } = winston;\n\n/**\n * Enhanced metadata structure for logging\n */\nexport interface LoggingMetadata {\n  // System information\n  instanceId?: string;\n  hostname?: string;\n  nodeVersion?: string;\n  pid?: number;\n  \n  // Request context\n  requestId?: string;\n  sessionId?: string;\n  apiKey?: string;\n  \n  // Operation metadata\n  operation?: string;\n  component?: string;\n  duration?: number;\n  statusCode?: number;\n  \n  // Custom metadata\n  [key: string]: any;\n}\n\n// Generate an instance ID at startup for correlating logs from the same process\nconst instanceId = randomUUID();\n\n/**\n * Format function to add standard metadata to all log entries\n */\nconst addStandardMetadata = format((info) => {\n  // Add standard metadata to every log\n  return {\n    ...info,\n    instanceId,\n    hostname: os.hostname(),\n    nodeVersion: process.version,\n    pid: process.pid,\n    timestamp: info.timestamp || new Date().toISOString(),\n    environment: process.env.NODE_ENV || 'development'\n  };\n});\n\n/**\n * Request context storage for correlating logs within a request lifecycle\n */\nexport class LogContext {\n  private static requestContext = new Map<string, LoggingMetadata>();\n  \n  /**\n   * Initialize a new request context with a unique ID\n   * @param sessionId Optional session ID\n   * @returns Request ID for the new context\n   */\n  static initRequest(sessionId?: string): string {\n    const requestId = randomUUID();\n    this.requestContext.set(requestId, {\n      requestId,\n      sessionId,\n      startTime: Date.now()\n    });\n    return requestId;\n  }\n  \n  /**\n   * Get the metadata for a request context\n   * @param requestId Request ID\n   * @returns Metadata object or empty object if not found\n   */\n  static getContext(requestId: string): LoggingMetadata {\n    return this.requestContext.get(requestId) || {};\n  }\n  \n  /**\n   * Update the metadata for a request context\n   * @param requestId Request ID\n   * @param metadata Metadata to merge with existing context\n   */\n  static updateContext(requestId: string, metadata: LoggingMetadata): void {\n    const existing = this.requestContext.get(requestId) || {};\n    this.requestContext.set(requestId, {\n      ...existing,\n      ...metadata\n    });\n  }\n  \n  /**\n   * Remove a request context when the request is complete\n   * @param requestId Request ID\n   */\n  static endRequest(requestId: string): void {\n    this.requestContext.delete(requestId);\n  }\n  \n  /**\n   * Create a logger that includes the request context in every log entry\n   * @param requestId Request ID\n   * @returns Logger with request context\n   */\n  static getContextLogger(requestId: string) {\n    return {\n      debug: (message: string, metadata?: LoggingMetadata) => {\n        logger.debug(message, { ...this.getContext(requestId), ...metadata });\n      },\n      info: (message: string, metadata?: LoggingMetadata) => {\n        logger.info(message, { ...this.getContext(requestId), ...metadata });\n      },\n      warn: (message: string, metadata?: LoggingMetadata) => {\n        logger.warn(message, { ...this.getContext(requestId), ...metadata });\n      },\n      error: (message: string, metadata?: LoggingMetadata) => {\n        logger.error(message, { ...this.getContext(requestId), ...metadata });\n      }\n    };\n  }\n  \n  /**\n   * Create a child logger for a specific component\n   * @param component Component name\n   * @returns Logger with component in metadata\n   */\n  static getComponentLogger(component: string) {\n    return {\n      debug: (message: string, metadata?: LoggingMetadata) => {\n        logger.debug(message, { component, ...metadata });\n      },\n      info: (message: string, metadata?: LoggingMetadata) => {\n        logger.info(message, { component, ...metadata });\n      },\n      warn: (message: string, metadata?: LoggingMetadata) => {\n        logger.warn(message, { component, ...metadata });\n      },\n      error: (message: string, metadata?: LoggingMetadata) => {\n        logger.error(message, { component, ...metadata });\n      }\n    };\n  }\n}\n\n/**\n * Format function to handle Error objects in metadata\n * Extracts relevant properties from Error objects for better serialization\n */\nconst handleErrorObjects = format((info) => {\n  // Handle any Error objects in the metadata\n  const processedInfo = { ...info };\n  \n  Object.keys(processedInfo).forEach(key => {\n    if (processedInfo[key] instanceof Error) {\n      const error = processedInfo[key];\n      processedInfo[key] = {\n        message: error.message,\n        stack: error.stack,\n        name: error.name,\n        // Extract any custom properties from the error\n        ...(Object.getOwnPropertyNames(error)\n          .filter(prop => !['message', 'stack', 'name'].includes(prop))\n          .reduce((obj, prop) => {\n            obj[prop] = (error as any)[prop];\n            return obj;\n          }, {} as Record<string, any>))\n      };\n    }\n  });\n  \n  return processedInfo;\n});\n\n/**\n * Format for console output - more human-readable\n */\nconst consoleFormat = format.combine(\n  format.colorize(),\n  format.timestamp(),\n  format.printf(({ level, message, timestamp, ...metadata }) => {\n    // Extract important metadata for console display\n    const { requestId, component, operation, duration, statusCode } = metadata;\n    \n    // Format important metadata into a concise string\n    let metadataStr = '';\n    if (requestId) metadataStr += `requestId=${requestId} `;\n    if (component) metadataStr += `component=${component} `;\n    if (operation) metadataStr += `operation=${operation} `;\n    if (duration) metadataStr += `duration=${duration}ms `;\n    if (statusCode) metadataStr += `status=${statusCode} `;\n    \n    return `${timestamp} ${level}: ${message} ${metadataStr}`;\n  })\n);\n\n/**\n * Configure and create the Winston logger instance\n * \n * The logger uses the following configuration:\n * - Log level: Configured via LOG_LEVEL environment variable (defaults to 'info')\n * - Format: JSON with timestamps for file output, colorized simple format for console\n * - Transports:\n *   - Console: All levels, with colorization\n *   - Error File: Only error level messages in 'error.log'\n *   - Combined File: All levels in 'combined.log'\n */\nconst logger = createLogger({\n  level: process.env.LOG_LEVEL || 'info',\n  format: format.combine(\n    format.timestamp(),\n    addStandardMetadata(),\n    handleErrorObjects(),\n    format.json()\n  ),\n  transports: [\n    new transports.Console({\n      format: consoleFormat\n    }),\n    new transports.File({ filename: 'error.log', level: 'error' }),\n    new transports.File({ filename: 'combined.log' })\n  ],\n  exitOnError: false // Don't crash on logger error\n});\n\n/**\n * Helper function to create a scoped logger with standard metadata\n * @param component Component name for categorizing logs\n * @returns A logger instance with component metadata\n */\nexport function createComponentLogger(component: string) {\n  return LogContext.getComponentLogger(component);\n}\n\n/**\n * Helper function to log performance metrics\n * @param operation Operation name\n * @param startTime Start time in milliseconds\n * @param metadata Additional metadata\n */\nexport function logPerformance(operation: string, startTime: number, metadata: LoggingMetadata = {}) {\n  const duration = Date.now() - startTime;\n  logger.debug(`Performance: ${operation}`, {\n    operation,\n    duration,\n    ...metadata\n  });\n}\n\n/**\n * The configured logger instance for use throughout the application\n * \n * @example\n * import logger from './logger.js';\n * \n * // Basic logging\n * logger.debug('Detailed debugging information');\n * logger.info('General operational information');\n * logger.warn('Warning conditions');\n * logger.error('Error conditions', { error: err });\n * \n * // Structured logging with metadata\n * logger.info('User logged in', { userId: 123, role: 'admin' });\n * \n * // Component-specific logging\n * import { createComponentLogger } from './logger.js';\n * const dbLogger = createComponentLogger('database');\n * dbLogger.info('Connected to database', { database: 'users' });\n * \n * // Request-scoped logging\n * import { LogContext } from './logger.js';\n * const requestId = LogContext.initRequest(sessionId);\n * const reqLogger = LogContext.getContextLogger(requestId);\n * reqLogger.info('Processing request', { endpoint: '/api/users' });\n * // Later when done\n * LogContext.endRequest(requestId);\n * \n * // Performance logging\n * import { logPerformance } from './logger.js';\n * const startTime = Date.now();\n * // ... do operation ...\n * logPerformance('fetch-users', startTime, { count: 10 });\n */\nexport default logger;",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/metrics.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'register' is defined but never used.",
          "line": 24,
          "column": 60,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 24,
          "endColumn": 68
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 490,
          "column": 35,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 490,
          "endColumn": 38,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  15967,
                  15970
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  15967,
                  15970
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 490,
          "column": 49,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 490,
          "endColumn": 52,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  15981,
                  15984
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  15981,
                  15984
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 497,
          "column": 33,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 497,
          "endColumn": 36,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  16264,
                  16267
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  16264,
                  16267
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 497,
          "column": 47,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 497,
          "endColumn": 50,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  16278,
                  16281
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  16278,
                  16281
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 1,
      "fatalErrorCount": 0,
      "warningCount": 4,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - Metrics Module\n * \n * This module provides Prometheus metrics collection for the Digital Samba MCP Server.\n * It sets up standardized metrics for monitoring system health, request performance,\n * and Digital Samba API interactions.\n * \n * Features include:\n * - HTTP request metrics (count, duration, status codes)\n * - API client metrics (requests, errors, latency)\n * - System metrics (memory usage, CPU, etc.)\n * - Custom application metrics (cache hits/misses, rate limiting)\n * - Metrics endpoint for Prometheus scraping\n * \n * @module metrics\n * @author Digital Samba Team\n * @version 0.1.0\n */\n\n// Node.js built-in modules\nimport os from 'os';\n\n// External dependencies\nimport { collectDefaultMetrics, Counter, Gauge, Histogram, register, Registry } from 'prom-client';\nimport express from 'express';\n\n// Local modules\nimport logger from './logger.js';\n\n/**\n * Metrics configuration options\n */\nexport interface MetricsOptions {\n  /** Whether to collect default Node.js metrics */\n  defaultMetrics?: boolean;\n  \n  /** Prefix for all metrics */\n  prefix?: string;\n  \n  /** Whether to enable HTTP request metrics */\n  enableHttpMetrics?: boolean;\n  \n  /** Whether to enable API client metrics */\n  enableApiMetrics?: boolean;\n  \n  /** Whether to enable cache metrics */\n  enableCacheMetrics?: boolean;\n  \n  /** Whether to enable rate limiting metrics */\n  enableRateLimitMetrics?: boolean;\n  \n  /** Collection interval for default metrics in milliseconds */\n  defaultMetricsInterval?: number;\n}\n\n/**\n * Default metrics configuration\n */\nconst defaultOptions: MetricsOptions = {\n  defaultMetrics: true,\n  prefix: 'digital_samba_mcp_',\n  enableHttpMetrics: true,\n  enableApiMetrics: true,\n  enableCacheMetrics: true,\n  enableRateLimitMetrics: true,\n  defaultMetricsInterval: 10000 // 10 seconds\n};\n\n/**\n * Main metrics registry\n */\nclass MetricsRegistry {\n  private registry: Registry;\n  private options: MetricsOptions;\n  private initialized: boolean = false;\n\n  // HTTP metrics\n  public httpRequestsTotal: Counter;\n  public httpRequestDuration: Histogram;\n  public httpRequestsInFlight: Gauge;\n  public httpResponseSize: Histogram;\n\n  // API client metrics\n  public apiRequestsTotal: Counter;\n  public apiRequestDuration: Histogram;\n  public apiErrorsTotal: Counter;\n\n  // Cache metrics\n  public cacheHitsTotal: Counter;\n  public cacheMissesTotal: Counter;\n  public cacheSize: Gauge;\n  public cacheEntriesCount: Gauge;\n\n  // Rate limiting metrics\n  public rateLimitExceededTotal: Counter;\n  public rateLimitRemainingTokens: Gauge;\n\n  // System metrics\n  public appInfo: Gauge;\n  public activeConnections: Gauge;\n  public activeSessions: Gauge;\n  \n  // Circuit breaker metrics\n  public circuitBreakersTotal: Counter;\n  public circuitBreakerSuccess: Counter;\n  public circuitBreakerFailures: Counter;\n  public circuitBreakerStateInfo: Gauge;\n  public circuitBreakerResets: Counter;\n  public circuitBreakerTrips: Counter;\n  \n  // Graceful degradation metrics\n  public degradationHealthChecksTotal: Counter;\n  public degradationComponentStatusInfo: Gauge;\n  public degradationOverallStatusInfo: Gauge;\n  public degradationFallbacksRegisteredTotal: Counter;\n  public degradationFallbackActivationsTotal: Counter;\n  public degradationFallbackDeactivationsTotal: Counter;\n  public degradationFallbackSuccessTotal: Counter;\n  public degradationFallbackFailureTotal: Counter;\n  public degradationOperationDuration: Histogram;\n  public degradationOperationFailuresTotal: Counter;\n  public degradationCacheHitsTotal: Counter;\n  public degradationRetryAttemptsTotal: Counter;\n  public degradationRetrySuccessTotal: Counter;\n  public degradationRetryFailureTotal: Counter;\n  \n  /**\n   * Constructor for the metrics registry\n   * @param options Metrics configuration options\n   */\n  constructor(options: MetricsOptions = {}) {\n    this.options = { ...defaultOptions, ...options };\n    this.registry = new Registry();\n    \n    // Set up app info metric\n    this.appInfo = new Gauge({\n      name: `${this.options.prefix}app_info`,\n      help: 'Application information',\n      labelNames: ['version', 'node_version', 'hostname'],\n      registers: [this.registry]\n    });\n    \n    // Initialize HTTP metrics\n    this.httpRequestsTotal = new Counter({\n      name: `${this.options.prefix}http_requests_total`,\n      help: 'Total number of HTTP requests',\n      labelNames: ['method', 'path', 'status'],\n      registers: [this.registry]\n    });\n    \n    this.httpRequestDuration = new Histogram({\n      name: `${this.options.prefix}http_request_duration_seconds`,\n      help: 'HTTP request duration in seconds',\n      labelNames: ['method', 'path', 'status'],\n      buckets: [0.01, 0.05, 0.1, 0.5, 1, 2, 5, 10],\n      registers: [this.registry]\n    });\n    \n    this.httpRequestsInFlight = new Gauge({\n      name: `${this.options.prefix}http_requests_in_flight`,\n      help: 'Number of HTTP requests currently being processed',\n      labelNames: ['method', 'path'],\n      registers: [this.registry]\n    });\n    \n    this.httpResponseSize = new Histogram({\n      name: `${this.options.prefix}http_response_size_bytes`,\n      help: 'Size of HTTP responses in bytes',\n      buckets: [100, 1000, 10000, 100000, 1000000],\n      registers: [this.registry]\n    });\n    \n    // Initialize API client metrics\n    this.apiRequestsTotal = new Counter({\n      name: `${this.options.prefix}api_requests_total`,\n      help: 'Total number of API requests',\n      labelNames: ['endpoint', 'method'],\n      registers: [this.registry]\n    });\n    \n    this.apiRequestDuration = new Histogram({\n      name: `${this.options.prefix}api_request_duration_seconds`,\n      help: 'API request duration in seconds',\n      labelNames: ['endpoint', 'method', 'status'],\n      buckets: [0.05, 0.1, 0.5, 1, 2, 5, 10],\n      registers: [this.registry]\n    });\n    \n    this.apiErrorsTotal = new Counter({\n      name: `${this.options.prefix}api_errors_total`,\n      help: 'Total number of API errors',\n      labelNames: ['endpoint', 'method', 'error_type'],\n      registers: [this.registry]\n    });\n    \n    // Initialize cache metrics\n    this.cacheHitsTotal = new Counter({\n      name: `${this.options.prefix}cache_hits_total`,\n      help: 'Total number of cache hits',\n      labelNames: ['namespace'],\n      registers: [this.registry]\n    });\n    \n    this.cacheMissesTotal = new Counter({\n      name: `${this.options.prefix}cache_misses_total`,\n      help: 'Total number of cache misses',\n      labelNames: ['namespace'],\n      registers: [this.registry]\n    });\n    \n    this.cacheSize = new Gauge({\n      name: `${this.options.prefix}cache_size_bytes`,\n      help: 'Size of cache in bytes',\n      registers: [this.registry]\n    });\n    \n    this.cacheEntriesCount = new Gauge({\n      name: `${this.options.prefix}cache_entries_count`,\n      help: 'Number of entries in the cache',\n      labelNames: ['namespace'],\n      registers: [this.registry]\n    });\n    \n    // Initialize rate limiting metrics\n    this.rateLimitExceededTotal = new Counter({\n      name: `${this.options.prefix}rate_limit_exceeded_total`,\n      help: 'Total number of rate limit exceeded events',\n      labelNames: ['key_type'],\n      registers: [this.registry]\n    });\n    \n    this.rateLimitRemainingTokens = new Gauge({\n      name: `${this.options.prefix}rate_limit_remaining_tokens`,\n      help: 'Number of tokens remaining for rate limited keys',\n      labelNames: ['key_type'],\n      registers: [this.registry]\n    });\n    \n    // Initialize connection metrics\n    this.activeConnections = new Gauge({\n      name: `${this.options.prefix}active_connections`,\n      help: 'Number of active connections',\n      registers: [this.registry]\n    });\n    \n    this.activeSessions = new Gauge({\n      name: `${this.options.prefix}active_sessions`,\n      help: 'Number of active sessions',\n      registers: [this.registry]\n    });\n    \n    // Initialize circuit breaker metrics\n    this.circuitBreakersTotal = new Counter({\n      name: `${this.options.prefix}circuit_breakers_total`,\n      help: 'Total number of circuit breakers',\n      registers: [this.registry]\n    });\n    \n    this.circuitBreakerSuccess = new Counter({\n      name: `${this.options.prefix}circuit_breaker_success_total`,\n      help: 'Total number of successful circuit breaker calls',\n      labelNames: ['circuit'],\n      registers: [this.registry]\n    });\n    \n    this.circuitBreakerFailures = new Counter({\n      name: `${this.options.prefix}circuit_breaker_failures_total`,\n      help: 'Total number of failed circuit breaker calls',\n      labelNames: ['circuit'],\n      registers: [this.registry]\n    });\n    \n    this.circuitBreakerStateInfo = new Gauge({\n      name: `${this.options.prefix}circuit_breaker_state_info`,\n      help: 'Circuit breaker state (0 = inactive, 1 = active)',\n      labelNames: ['circuit', 'state'],\n      registers: [this.registry]\n    });\n    \n    this.circuitBreakerResets = new Counter({\n      name: `${this.options.prefix}circuit_breaker_resets_total`,\n      help: 'Total number of circuit breaker manual resets',\n      labelNames: ['circuit'],\n      registers: [this.registry]\n    });\n    \n    this.circuitBreakerTrips = new Counter({\n      name: `${this.options.prefix}circuit_breaker_trips_total`,\n      help: 'Total number of circuit breaker manual trips',\n      labelNames: ['circuit'],\n      registers: [this.registry]\n    });\n    \n    // Initialize graceful degradation metrics\n    this.degradationHealthChecksTotal = new Counter({\n      name: `${this.options.prefix}degradation_health_checks_total`,\n      help: 'Total number of degradation health checks performed',\n      registers: [this.registry]\n    });\n    \n    this.degradationComponentStatusInfo = new Gauge({\n      name: `${this.options.prefix}degradation_component_status_info`,\n      help: 'Degradation component status (0 = inactive, 1 = active)',\n      labelNames: ['component', 'status'],\n      registers: [this.registry]\n    });\n    \n    this.degradationOverallStatusInfo = new Gauge({\n      name: `${this.options.prefix}degradation_overall_status_info`,\n      help: 'Overall degradation status (0 = inactive, 1 = active)',\n      labelNames: ['status'],\n      registers: [this.registry]\n    });\n    \n    this.degradationFallbacksRegisteredTotal = new Counter({\n      name: `${this.options.prefix}degradation_fallbacks_registered_total`,\n      help: 'Total number of fallbacks registered',\n      labelNames: ['operation'],\n      registers: [this.registry]\n    });\n    \n    this.degradationFallbackActivationsTotal = new Counter({\n      name: `${this.options.prefix}degradation_fallback_activations_total`,\n      help: 'Total number of fallback activations',\n      labelNames: ['operation'],\n      registers: [this.registry]\n    });\n    \n    this.degradationFallbackDeactivationsTotal = new Counter({\n      name: `${this.options.prefix}degradation_fallback_deactivations_total`,\n      help: 'Total number of fallback deactivations',\n      labelNames: ['operation'],\n      registers: [this.registry]\n    });\n    \n    this.degradationFallbackSuccessTotal = new Counter({\n      name: `${this.options.prefix}degradation_fallback_success_total`,\n      help: 'Total number of successful fallback operations',\n      labelNames: ['operation'],\n      registers: [this.registry]\n    });\n    \n    this.degradationFallbackFailureTotal = new Counter({\n      name: `${this.options.prefix}degradation_fallback_failure_total`,\n      help: 'Total number of failed fallback operations',\n      labelNames: ['operation'],\n      registers: [this.registry]\n    });\n    \n    this.degradationOperationDuration = new Histogram({\n      name: `${this.options.prefix}degradation_operation_duration_seconds`,\n      help: 'Duration of operations with degradation protection',\n      labelNames: ['operation', 'source'],\n      buckets: [0.01, 0.05, 0.1, 0.5, 1, 2, 5, 10],\n      registers: [this.registry]\n    });\n    \n    this.degradationOperationFailuresTotal = new Counter({\n      name: `${this.options.prefix}degradation_operation_failures_total`,\n      help: 'Total number of operation failures with degradation protection',\n      labelNames: ['operation'],\n      registers: [this.registry]\n    });\n    \n    this.degradationCacheHitsTotal = new Counter({\n      name: `${this.options.prefix}degradation_cache_hits_total`,\n      help: 'Total number of cache hits during degraded operations',\n      labelNames: ['operation'],\n      registers: [this.registry]\n    });\n    \n    this.degradationRetryAttemptsTotal = new Counter({\n      name: `${this.options.prefix}degradation_retry_attempts_total`,\n      help: 'Total number of retry attempts during degraded operations',\n      labelNames: ['operation', 'attempt'],\n      registers: [this.registry]\n    });\n    \n    this.degradationRetrySuccessTotal = new Counter({\n      name: `${this.options.prefix}degradation_retry_success_total`,\n      help: 'Total number of successful retries during degraded operations',\n      labelNames: ['operation', 'attempt'],\n      registers: [this.registry]\n    });\n    \n    this.degradationRetryFailureTotal = new Counter({\n      name: `${this.options.prefix}degradation_retry_failure_total`,\n      help: 'Total number of failed retries during degraded operations',\n      labelNames: ['operation', 'attempt'],\n      registers: [this.registry]\n    });\n  }\n  \n  /**\n   * Initialize metrics collection\n   */\n  initialize() {\n    if (this.initialized) {\n      return;\n    }\n    \n    if (this.options.defaultMetrics) {\n      // Use correctly typed options for collectDefaultMetrics\n      const metricsOpts = {\n        register: this.registry,\n        prefix: this.options.prefix\n      };\n      \n      // Call collectDefaultMetrics with valid options\n      collectDefaultMetrics(metricsOpts);\n      \n      // If interval is specified, set the collection interval\n      if (this.options.defaultMetricsInterval) {\n        // Note: setting interval is no longer supported in the configuration object\n        // If needed, use alternative approaches to control collection frequency\n        logger.debug('Note: Custom metrics collection interval is not supported in this version');\n      }\n    }\n    \n    // Set app info\n    this.appInfo.labels(\n      process.env.npm_package_version || '0.1.0',\n      process.version,\n      os.hostname()\n    ).set(1);\n    \n    logger.info('Metrics collection initialized', { \n      prefix: this.options.prefix,\n      defaultMetrics: this.options.defaultMetrics,\n      defaultMetricsInterval: this.options.defaultMetricsInterval\n    });\n    \n    this.initialized = true;\n  }\n  \n  /**\n   * Get the metrics registry\n   * @returns Prometheus Registry instance\n   */\n  getRegistry() {\n    return this.registry;\n  }\n  \n  /**\n   * Reset all metrics\n   */\n  resetMetrics() {\n    this.registry.resetMetrics();\n    logger.info('Metrics reset');\n  }\n  \n  /**\n   * Get metrics as string in Prometheus format\n   * @returns Prometheus metrics string\n   */\n  async getMetricsAsString() {\n    return await this.registry.metrics();\n  }\n  \n  /**\n   * Create Express middleware for tracking HTTP requests\n   * @returns Express middleware function\n   */\n  createHttpMetricsMiddleware() {\n    return (req: express.Request, res: express.Response, next: express.NextFunction) => {\n      if (!this.options.enableHttpMetrics) {\n        return next();\n      }\n      \n      const path = req.path || req.url;\n      const method = req.method;\n      \n      // Skip metrics endpoint to avoid circular measurements\n      if (path === '/metrics') {\n        return next();\n      }\n      \n      const startTime = Date.now();\n      const labels = { method, path };\n      \n      // Increment in-flight counter\n      this.httpRequestsInFlight.inc(labels);\n      \n      // Add response size tracking\n      const originalWrite = res.write;\n      const originalEnd = res.end;\n      let responseSize = 0;\n      \n      // Override write method to track response size\n      res.write = function(chunk: any, ...args: any[]) {\n        responseSize += chunk.length;\n        return originalWrite.apply(res, [chunk, ...args]);\n      };\n      \n      // Override end method to track response size and finalize metrics\n      // Use type assertion to fix the TypeScript error\n      res.end = function(chunk: any, ...args: any[]) {\n        if (chunk) {\n          responseSize += chunk.length;\n        }\n        \n        return originalEnd.apply(res, [chunk, ...args]);\n      } as typeof res.end;\n      \n      // Add response finished handler\n      res.on('finish', () => {\n        const duration = (Date.now() - startTime) / 1000; // Convert to seconds\n        const statusCode = res.statusCode.toString();\n        const allLabels = { ...labels, status: statusCode };\n        \n        // Record metrics\n        this.httpRequestsTotal.inc(allLabels);\n        this.httpRequestDuration.observe(allLabels, duration);\n        this.httpResponseSize.observe(responseSize);\n        \n        // Decrement in-flight counter\n        this.httpRequestsInFlight.dec(labels);\n      });\n      \n      next();\n    };\n  }\n  \n  /**\n   * Register metrics endpoint on an Express app\n   * @param app Express application\n   * @param path Optional path for metrics endpoint (default: /metrics)\n   */\n  registerMetricsEndpoint(app: express.Application, path = '/metrics') {\n    app.get(path, async (req, res) => {\n      res.set('Content-Type', this.registry.contentType);\n      res.end(await this.getMetricsAsString());\n    });\n    \n    logger.info('Metrics endpoint registered', { path });\n  }\n}\n\n// Create singleton instance\nconst metricsRegistry = new MetricsRegistry();\n\n/**\n * Initialize metrics collection with options\n * @param options Metrics configuration options\n * @returns The metrics registry instance\n */\nexport function initializeMetrics(options: MetricsOptions = {}) {\n  // Apply options\n  const metrics = new MetricsRegistry(options);\n  metrics.initialize();\n  return metrics;\n}\n\n/**\n * Get the metrics registry instance\n * @returns The metrics registry\n */\nexport function getMetricsRegistry() {\n  return metricsRegistry;\n}\n\n/**\n * Export the default metrics registry\n */\nexport default metricsRegistry;\n",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/rate-limiter.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'ApiRequestError' is defined but never used.",
          "line": 29,
          "column": 10,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 29,
          "endColumn": 25
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'clientIp' is assigned a value but never used.",
          "line": 202,
          "column": 9,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 202,
          "endColumn": 17
        }
      ],
      "suppressedMessages": [],
      "errorCount": 2,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - Rate Limiting Module\n * \n * This module provides rate limiting functionality for the Digital Samba MCP Server.\n * It implements a token bucket algorithm for limiting the number of requests that can\n * be made in a given time period, helping to protect the Digital Samba API from abuse\n * and ensuring fair usage across clients.\n * \n * Features include:\n * - Configurable rate limits (requests per minute, per hour)\n * - Memory-based storage for rate limiting data\n * - Optional Redis-based storage for distributed deployments\n * - Detailed logging of rate limiting events\n * - Configurable response behavior for rate limited requests\n * \n * @module rate-limiter\n * @author Digital Samba Team\n * @version 0.1.0\n */\n\n// Node.js built-in modules\n// import { IncomingMessage } from 'http'; // Removed: unused\n\n// External dependencies \nimport { Request, Response, NextFunction } from 'express';\n\n// Local modules\nimport logger from './logger.js';\nimport { ApiRequestError } from './errors.js';\n\n/**\n * Rate limiter options interface\n */\nexport interface RateLimiterOptions {\n  /** Maximum number of requests allowed per window */\n  maxRequests: number;\n  \n  /** Time window in milliseconds */\n  windowMs: number;\n  \n  /** Whether to include headers in response */\n  headers: boolean;\n  \n  /** Message to send when rate limit is exceeded */\n  message?: string;\n  \n  /** Key function to identify requesters */\n  keyGenerator: (req: Request) => string;\n  \n  /** Skip function to bypass rate limiting for certain requests */\n  skip?: (req: Request) => boolean;\n  \n  /** Handler for when rate limit is exceeded */\n  handler?: (req: Request, res: Response) => void;\n  \n  /** Whether to trust the X-Forwarded-For header */\n  trustProxy?: boolean;\n}\n\n/**\n * Rate limit status for a client\n */\ninterface RateLimitStatus {\n  /** Number of tokens available */\n  tokens: number;\n  \n  /** Last refill timestamp */\n  lastRefill: number;\n}\n\n/**\n * Default options for the rate limiter\n */\nexport const defaultOptions: Partial<RateLimiterOptions> = {\n  maxRequests: 60, // 60 requests per minute by default\n  windowMs: 60 * 1000, // 1 minute\n  headers: true,\n  message: 'Too many requests, please try again later.',\n  keyGenerator: (req) => {\n    // Default to using IP address as key\n    const xForwardedFor = req.headers['x-forwarded-for'];\n    if (xForwardedFor && typeof xForwardedFor === 'string') {\n      return xForwardedFor.split(',')[0].trim();\n    }\n    return req.ip || '127.0.0.1';\n  },\n  skip: () => false, // Don't skip any requests by default\n  trustProxy: false\n};\n\n/**\n * TokenBucket rate limiter implementation\n * \n * This class implements a token bucket algorithm for rate limiting.\n * Each client has a bucket that's refilled at a constant rate.\n * When a request is made, a token is consumed from the bucket.\n * If there are no tokens left, the request is rate limited.\n */\nexport class TokenBucketRateLimiter {\n  private options: RateLimiterOptions;\n  private store: Map<string, RateLimitStatus>;\n  private tokensPerMs: number;\n\n  /**\n   * Creates a new TokenBucketRateLimiter\n   * @param options Rate limiter options\n   */\n  constructor(options: Partial<RateLimiterOptions> = {}) {\n    this.options = { ...defaultOptions, ...options } as RateLimiterOptions;\n    this.store = new Map<string, RateLimitStatus>();\n    this.tokensPerMs = this.options.maxRequests / this.options.windowMs;\n    \n    logger.info('Rate limiter initialized', {\n      maxRequests: this.options.maxRequests,\n      windowMs: this.options.windowMs\n    });\n  }\n\n  /**\n   * Gets the current status for a client\n   * @param key Client identifier\n   * @returns Rate limit status\n   */\n  private getClientStatus(key: string): RateLimitStatus {\n    const now = Date.now();\n    let status = this.store.get(key);\n    \n    if (!status) {\n      // New client, initialize with full bucket\n      status = {\n        tokens: this.options.maxRequests,\n        lastRefill: now\n      };\n      this.store.set(key, status);\n      return status;\n    }\n    \n    // Refill tokens based on elapsed time\n    const elapsedMs = now - status.lastRefill;\n    if (elapsedMs > 0) {\n      const tokensToAdd = elapsedMs * this.tokensPerMs;\n      status.tokens = Math.min(status.tokens + tokensToAdd, this.options.maxRequests);\n      status.lastRefill = now;\n    }\n    \n    return status;\n  }\n\n  /**\n   * Consumes a token for a client\n   * @param key Client identifier\n   * @returns Whether the token was successfully consumed\n   */\n  public consumeToken(key: string): boolean {\n    const status = this.getClientStatus(key);\n    \n    if (status.tokens >= 1) {\n      status.tokens -= 1;\n      return true;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Gets remaining tokens for a client\n   * @param key Client identifier\n   * @returns Number of tokens remaining\n   */\n  public getRemainingTokens(key: string): number {\n    const status = this.getClientStatus(key);\n    return Math.floor(status.tokens);\n  }\n\n  /**\n   * Gets reset time for a client's rate limit\n   * @param key Client identifier\n   * @returns Timestamp when rate limit will reset\n   */\n  public getResetTime(key: string): number {\n    const status = this.getClientStatus(key);\n    const tokensNeeded = this.options.maxRequests - status.tokens;\n    const msNeeded = tokensNeeded / this.tokensPerMs;\n    \n    return Date.now() + msNeeded;\n  }\n\n  /**\n   * Middleware function for Express\n   * @returns Express middleware\n   */\n  public middleware() {\n    return (req: Request, res: Response, next: NextFunction) => {\n      // Skip rate limiting if specified\n      if (this.options.skip && this.options.skip(req)) {\n        return next();\n      }\n      \n      // Trust proxy if enabled\n      let clientIp = req.ip;\n      if (this.options.trustProxy && req.headers['x-forwarded-for']) {\n        clientIp = (req.headers['x-forwarded-for'] as string)?.split(',')[0].trim() || req.ip;\n      }\n      \n      // Generate client key\n      const key = this.options.keyGenerator(req);\n      \n      // Check if client has tokens available\n      const allowed = this.consumeToken(key);\n      \n      // Set rate limit headers if enabled\n      if (this.options.headers) {\n        res.setHeader('X-RateLimit-Limit', this.options.maxRequests.toString());\n        res.setHeader('X-RateLimit-Remaining', this.getRemainingTokens(key).toString());\n        res.setHeader('X-RateLimit-Reset', Math.ceil(this.getResetTime(key) / 1000).toString());\n      }\n      \n      if (!allowed) {\n        logger.warn('Rate limit exceeded', { key });\n        \n        if (this.options.handler) {\n          return this.options.handler(req, res);\n        }\n        \n        res.status(429).json({\n          error: 'Too Many Requests',\n          message: this.options.message,\n          status: 429\n        });\n        return;\n      }\n      \n      next();\n    };\n  }\n\n  /**\n   * Gets rate limit status for a client\n   * @param key Client identifier\n   * @returns Client rate limit status\n   */\n  public getStatus(key: string) {\n    const status = this.getClientStatus(key);\n    \n    return {\n      remaining: Math.floor(status.tokens),\n      limit: this.options.maxRequests,\n      reset: this.getResetTime(key)\n    };\n  }\n\n  /**\n   * Clears the rate limiter store\n   */\n  public reset(): void {\n    this.store.clear();\n    logger.info('Rate limiter store cleared');\n  }\n}\n\n/**\n * Redis-backed token bucket rate limiter\n * This implementation uses Redis for storage, making it suitable for distributed deployments.\n * Note: This is a placeholder for the Redis implementation.\n * The actual implementation would use a Redis client library.\n */\nexport class RedisRateLimiter {\n  // Redis implementation would go here\n  // This is a placeholder class to show the interface\n  \n  constructor(_options: Partial<RateLimiterOptions> = {}) {\n    // Initialize with Redis client\n    logger.info('Redis rate limiter initialized');\n    \n    throw new Error('Redis rate limiter not yet implemented');\n  }\n}\n\n/**\n * Creates a rate limiter middleware for express\n * @param options Rate limiter options\n * @returns Express middleware\n */\nexport function createRateLimiter(options: Partial<RateLimiterOptions> = {}) {\n  const limiter = new TokenBucketRateLimiter(options);\n  return limiter.middleware();\n}\n\n/**\n * Creates an API key based rate limiter that limits requests per API key\n * @param options Rate limiter options\n * @returns Express middleware\n */\nexport function createApiKeyRateLimiter(options: Partial<RateLimiterOptions> = {}) {\n  const apiKeyLimiter = new TokenBucketRateLimiter({\n    ...options,\n    keyGenerator: (req) => {\n      // Extract API key from Authorization header\n      const authHeader = req.headers.authorization;\n      if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        return 'anonymous';\n      }\n      return authHeader.split(' ')[1];\n    }\n  });\n  \n  return apiKeyLimiter.middleware();\n}\n\n/**\n * Creates an IP based rate limiter that limits requests per IP address\n * @param options Rate limiter options\n * @returns Express middleware\n */\nexport function createIpRateLimiter(options: Partial<RateLimiterOptions> = {}) {\n  return createRateLimiter({\n    trustProxy: true,\n    ...options\n  });\n}\n\n/**\n * Exports the default rate limiter\n */\nexport default {\n  TokenBucketRateLimiter,\n  RedisRateLimiter,\n  createRateLimiter,\n  createApiKeyRateLimiter,\n  createIpRateLimiter\n};\n",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/recordings.ts",
      "messages": [],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/resource-optimizer.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 66,
          "column": 35,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 66,
          "endColumn": 38,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1662,
                  1665
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1662,
                  1665
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 88,
          "column": 45,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 88,
          "endColumn": 48,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  2247,
                  2250
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  2247,
                  2250
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 425,
          "column": 33,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 425,
          "endColumn": 36,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  11735,
                  11738
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  11735,
                  11738
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 425,
          "column": 39,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 425,
          "endColumn": 42,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  11741,
                  11744
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  11741,
                  11744
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 4,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - Resource Optimizer Module\n * \n * This module provides optimization strategies for high-traffic scenarios,\n * reducing resource usage and improving performance of the MCP server.\n * \n * Features include:\n * - Request batching to reduce API calls\n * - Resource prioritization\n * - Response compression\n * - Incremental data loading\n * - Memory usage optimization\n * \n * @module resource-optimizer\n * @author Digital Samba Team\n * @version 0.1.0\n */\n\n// Node.js built-in modules\nimport { EventEmitter } from 'events';\n\n// Local modules\nimport logger from './logger.js';\nimport { MemoryCache } from './cache.js';\n\n/**\n * Resource optimizer options\n */\nexport interface ResourceOptimizerOptions {\n  /** Maximum batch size for requests (default: 10) */\n  maxBatchSize?: number;\n  \n  /** Batch delay in milliseconds (default: 50) */\n  batchDelayMs?: number;\n  \n  /** Whether to enable response compression (default: true) */\n  enableCompression?: boolean;\n  \n  /** Whether to enable incremental loading (default: true) */\n  enableIncrementalLoading?: boolean;\n  \n  /** Cache TTL for optimized resources in milliseconds (default: 60000) */\n  cacheTtl?: number;\n  \n  /** Maximum memory usage in bytes (default: 100MB) */\n  maxMemoryUsage?: number;\n  \n  /** Memory check interval in milliseconds (default: 30000) */\n  memoryCheckIntervalMs?: number;\n}\n\n/**\n * Request batch\n */\ninterface RequestBatch<T> {\n  /** Batch ID */\n  id: string;\n  \n  /** Keys in the batch */\n  keys: string[];\n  \n  /** Key to resolver mapping */\n  resolvers: Map<string, (value: T) => void>;\n  \n  /** Key to rejecter mapping */\n  rejecters: Map<string, (reason: any) => void>;\n  \n  /** Timestamp when batch was created */\n  createdAt: number;\n  \n  /** Whether batch is being processed */\n  processing: boolean;\n}\n\n/**\n * Callback for batch execution\n */\ntype BatchExecutor<T> = (keys: string[]) => Promise<Map<string, T>>;\n\n/**\n * Resource Optimizer class\n * \n * Optimizes resource usage for high-traffic scenarios by batching requests,\n * compressing responses, and managing memory usage.\n */\nexport class ResourceOptimizer extends EventEmitter {\n  private options: Required<ResourceOptimizerOptions>;\n  private batches: Map<string, RequestBatch<any>> = new Map();\n  private batchTimers: Map<string, NodeJS.Timeout> = new Map();\n  private cache: MemoryCache;\n  private memoryCheckTimer?: NodeJS.Timeout;\n  \n  /**\n   * Resource Optimizer constructor\n   * @param options Resource optimizer options\n   */\n  constructor(options: ResourceOptimizerOptions = {}) {\n    super();\n    \n    // Set default options\n    this.options = {\n      maxBatchSize: options.maxBatchSize || 10,\n      batchDelayMs: options.batchDelayMs || 50,\n      enableCompression: options.enableCompression !== false,\n      enableIncrementalLoading: options.enableIncrementalLoading !== false,\n      cacheTtl: options.cacheTtl || 60000, // 1 minute\n      maxMemoryUsage: options.maxMemoryUsage || 100 * 1024 * 1024, // 100MB\n      memoryCheckIntervalMs: options.memoryCheckIntervalMs || 30000 // 30 seconds\n    };\n    \n    // Initialize cache\n    this.cache = new MemoryCache({\n      ttl: this.options.cacheTtl,\n      maxItems: 1000\n    });\n    \n    logger.info('Resource Optimizer initialized', {\n      maxBatchSize: this.options.maxBatchSize,\n      batchDelayMs: this.options.batchDelayMs,\n      cacheTtl: this.options.cacheTtl\n    });\n    \n    // Start memory monitoring\n    this.startMemoryMonitoring();\n  }\n  \n  /**\n   * Start memory usage monitoring\n   */\n  private startMemoryMonitoring(): void {\n    // Clear existing timer\n    this.stopMemoryMonitoring();\n    \n    // Start new timer\n    this.memoryCheckTimer = setInterval(() => {\n      this.checkMemoryUsage();\n    }, this.options.memoryCheckIntervalMs);\n    \n    logger.debug('Memory monitoring started', {\n      interval: `${this.options.memoryCheckIntervalMs / 1000} seconds`,\n      maxMemoryUsage: `${Math.round(this.options.maxMemoryUsage / (1024 * 1024))}MB`\n    });\n  }\n  \n  /**\n   * Stop memory usage monitoring\n   */\n  private stopMemoryMonitoring(): void {\n    if (this.memoryCheckTimer) {\n      clearInterval(this.memoryCheckTimer);\n      this.memoryCheckTimer = undefined;\n      \n      logger.debug('Memory monitoring stopped');\n    }\n  }\n  \n  /**\n   * Check memory usage and take action if needed\n   */\n  private checkMemoryUsage(): void {\n    try {\n      // Get memory usage\n      const memoryUsage = process.memoryUsage();\n      const heapUsed = memoryUsage.heapUsed;\n      \n      logger.debug('Memory usage check', {\n        heapUsedMB: Math.round(heapUsed / (1024 * 1024)),\n        maxMemoryUsageMB: Math.round(this.options.maxMemoryUsage / (1024 * 1024)),\n        rss: Math.round(memoryUsage.rss / (1024 * 1024))\n      });\n      \n      // Check if memory usage exceeds threshold\n      if (heapUsed > this.options.maxMemoryUsage) {\n        logger.warn('Memory usage exceeds threshold, clearing cache', {\n          heapUsedMB: Math.round(heapUsed / (1024 * 1024)),\n          maxMemoryUsageMB: Math.round(this.options.maxMemoryUsage / (1024 * 1024))\n        });\n        \n        // Clear cache\n        this.cache.clear();\n        \n        // Run garbage collection if available\n        if (global.gc) {\n          logger.debug('Triggering garbage collection');\n          global.gc();\n        }\n        \n        // Emit event\n        this.emit('memory:exceeded', {\n          heapUsed,\n          maxMemoryUsage: this.options.maxMemoryUsage\n        });\n      }\n    } catch (error) {\n      logger.error('Error checking memory usage', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  }\n  \n  /**\n   * Batch a request\n   * @param batchId Batch identifier\n   * @param key Request key\n   * @param executor Function to execute the batch\n   * @returns Promise resolving to the result\n   */\n  public batchRequest<T>(batchId: string, key: string, executor: BatchExecutor<T>): Promise<T> {\n    // Try to get from cache first\n    const cached = this.cache.get(`batch:${batchId}`, key);\n    if (cached) {\n      logger.debug('Batch request cache hit', { batchId, key });\n      return Promise.resolve(cached.value as T);\n    }\n    \n    return new Promise<T>((resolve, reject) => {\n      // Get or create batch\n      let batch = this.batches.get(batchId);\n      \n      if (!batch) {\n        batch = {\n          id: batchId,\n          keys: [],\n          resolvers: new Map(),\n          rejecters: new Map(),\n          createdAt: Date.now(),\n          processing: false\n        };\n        \n        this.batches.set(batchId, batch);\n        \n        // Schedule batch execution\n        const timerId = setTimeout(() => {\n          this.executeBatch(batchId, executor);\n        }, this.options.batchDelayMs);\n        \n        this.batchTimers.set(batchId, timerId);\n        \n        logger.debug('Created new batch', { batchId });\n      }\n      \n      // Add to batch\n      batch.keys.push(key);\n      batch.resolvers.set(key, resolve);\n      batch.rejecters.set(key, reject);\n      \n      logger.debug('Added request to batch', { \n        batchId, \n        key,\n        batchSize: batch.keys.length \n      });\n      \n      // Execute immediately if batch size reached\n      if (batch.keys.length >= this.options.maxBatchSize && !batch.processing) {\n        // Clear scheduled execution\n        const timerId = this.batchTimers.get(batchId);\n        if (timerId) {\n          clearTimeout(timerId);\n          this.batchTimers.delete(batchId);\n        }\n        \n        // Execute batch\n        this.executeBatch(batchId, executor);\n      }\n    });\n  }\n  \n  /**\n   * Execute a batch\n   * @param batchId Batch identifier\n   * @param executor Function to execute the batch\n   */\n  private async executeBatch<T>(batchId: string, executor: BatchExecutor<T>): Promise<void> {\n    // Get batch\n    const batch = this.batches.get(batchId);\n    if (!batch) {\n      logger.warn('Attempted to execute non-existent batch', { batchId });\n      return;\n    }\n    \n    // Clear timer\n    const timerId = this.batchTimers.get(batchId);\n    if (timerId) {\n      clearTimeout(timerId);\n      this.batchTimers.delete(batchId);\n    }\n    \n    // Skip if already processing\n    if (batch.processing) {\n      return;\n    }\n    \n    // Mark as processing\n    batch.processing = true;\n    \n    logger.info('Executing batch', { \n      batchId, \n      keyCount: batch.keys.length,\n      batchAge: `${(Date.now() - batch.createdAt)}ms`\n    });\n    \n    try {\n      // Get unique keys\n      const uniqueKeys = Array.from(new Set(batch.keys));\n      \n      // Execute batch\n      const results = await executor(uniqueKeys);\n      \n      // Process results\n      for (const key of batch.keys) {\n        const resolver = batch.resolvers.get(key);\n        if (!resolver) continue;\n        \n        const result = results.get(key);\n        \n        if (result !== undefined) {\n          // Cache result\n          this.cache.set(`batch:${batchId}`, key, result);\n          \n          // Resolve promise\n          resolver(result);\n          \n          logger.debug('Batch request resolved', { batchId, key });\n        } else {\n          // Not found, reject\n          const rejecter = batch.rejecters.get(key);\n          if (rejecter) {\n            rejecter(new Error(`No result found for key: ${key}`));\n          }\n          \n          logger.debug('Batch request rejected (no result)', { batchId, key });\n        }\n      }\n      \n      // Emit event\n      this.emit('batch:success', {\n        batchId,\n        keyCount: batch.keys.length,\n        uniqueKeyCount: uniqueKeys.length,\n        duration: Date.now() - batch.createdAt\n      });\n    } catch (error) {\n      logger.error('Error executing batch', {\n        batchId,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      \n      // Reject all promises\n      for (const key of batch.keys) {\n        const rejecter = batch.rejecters.get(key);\n        if (rejecter) {\n          rejecter(error);\n        }\n      }\n      \n      // Emit event\n      this.emit('batch:error', {\n        batchId,\n        error: error instanceof Error ? error.message : String(error),\n        keyCount: batch.keys.length\n      });\n    } finally {\n      // Remove batch\n      this.batches.delete(batchId);\n      \n      logger.debug('Batch execution completed', { batchId });\n    }\n  }\n  \n  /**\n   * Check if a batch is in progress\n   * @param batchId Batch identifier\n   * @returns Whether the batch is in progress\n   */\n  public isBatchInProgress(batchId: string): boolean {\n    return this.batches.has(batchId);\n  }\n  \n  /**\n   * Cancel a batch\n   * @param batchId Batch identifier\n   * @returns Whether the batch was cancelled\n   */\n  public cancelBatch(batchId: string): boolean {\n    // Get batch\n    const batch = this.batches.get(batchId);\n    if (!batch) {\n      return false;\n    }\n    \n    // Clear timer\n    const timerId = this.batchTimers.get(batchId);\n    if (timerId) {\n      clearTimeout(timerId);\n      this.batchTimers.delete(batchId);\n    }\n    \n    // Reject all promises\n    for (const key of batch.keys) {\n      const rejecter = batch.rejecters.get(key);\n      if (rejecter) {\n        rejecter(new Error('Batch cancelled'));\n      }\n    }\n    \n    // Remove batch\n    this.batches.delete(batchId);\n    \n    logger.info('Batch cancelled', { batchId, keyCount: batch.keys.length });\n    \n    // Emit event\n    this.emit('batch:cancelled', {\n      batchId,\n      keyCount: batch.keys.length\n    });\n    \n    return true;\n  }\n  \n  /**\n   * Compress a response if compression is enabled\n   * @param data Data to compress\n   * @returns Compressed data or original data if compression disabled\n   */\n  public compressResponse(data: any): any {\n    if (!this.options.enableCompression) {\n      return data;\n    }\n    \n    try {\n      // Simple compression for demonstration\n      // In a real implementation, use a proper compression algorithm\n      \n      if (typeof data === 'object' && data !== null) {\n        // Remove null and undefined values\n        const compressed = Object.fromEntries(\n          Object.entries(data).filter(([_, v]) => v != null)\n        );\n        \n        return compressed;\n      }\n      \n      return data;\n    } catch (error) {\n      logger.warn('Error compressing response', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      \n      // Return original data on error\n      return data;\n    }\n  }\n  \n  /**\n   * Load data incrementally\n   * @param dataLoader Function to load data\n   * @param pageSize Page size\n   * @param maxPages Maximum number of pages to load\n   * @returns Promise resolving to the loaded data\n   */\n  public async loadIncrementally<T>(\n    dataLoader: (page: number, pageSize: number) => Promise<{ data: T[], total: number }>,\n    pageSize: number = 20,\n    maxPages: number = 10\n  ): Promise<T[]> {\n    if (!this.options.enableIncrementalLoading) {\n      // Load all data at once\n      const result = await dataLoader(1, pageSize * maxPages);\n      return result.data;\n    }\n    \n    const allData: T[] = [];\n    let page = 1;\n    let total = 0;\n    \n    do {\n      // Load page\n      const result = await dataLoader(page, pageSize);\n      const data = result.data;\n      total = result.total;\n      \n      // Add to results\n      allData.push(...data);\n      \n      // Emit progress event\n      this.emit('incremental:progress', {\n        page,\n        loaded: allData.length,\n        total,\n        percentage: Math.min(100, Math.round((allData.length / total) * 100))\n      });\n      \n      // Check if we're done\n      if (data.length < pageSize || allData.length >= total || page >= maxPages) {\n        break;\n      }\n      \n      // Next page\n      page++;\n    } while (page < 1000); // Safety limit to prevent infinite loops\n    \n    // Emit completion event\n    this.emit('incremental:complete', {\n      pages: page,\n      loaded: allData.length,\n      total\n    });\n    \n    return allData;\n  }\n  \n  /**\n   * Get statistics for the resource optimizer\n   * @returns Resource optimizer statistics\n   */\n  public getStats() {\n    return {\n      activeBatches: this.batches.size,\n      cacheStats: this.cache.getStats(),\n      memoryUsage: process.memoryUsage()\n    };\n  }\n  \n  /**\n   * Clean up resources\n   */\n  public destroy(): void {\n    // Clear batches\n    for (const batchId of this.batches.keys()) {\n      this.cancelBatch(batchId);\n    }\n    \n    // Clear cache\n    this.cache.clear();\n    \n    // Stop memory monitoring\n    this.stopMemoryMonitoring();\n    \n    // Remove all listeners\n    this.removeAllListeners();\n    \n    logger.info('Resource Optimizer destroyed');\n  }\n}\n\n/**\n * Create a resource optimizer\n * @param options Resource optimizer options\n * @returns A new resource optimizer instance\n */\nexport function createResourceOptimizer(\n  options: ResourceOptimizerOptions = {}\n): ResourceOptimizer {\n  return new ResourceOptimizer(options);\n}\n\n/**\n * Export default resource optimizer utilities\n */\nexport default {\n  ResourceOptimizer,\n  createResourceOptimizer\n};\n",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/resources/analytics/index.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'_analytics' is assigned a value but never used.",
          "line": 23,
          "column": 9,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 23,
          "endColumn": 19
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 60,
          "column": 103,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 60,
          "endColumn": 106,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1874,
                  1877
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1874,
                  1877
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 1,
      "fatalErrorCount": 0,
      "warningCount": 1,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Analytics Resources Module\n * \n * This module provides read-only analytics resources for the Digital Samba MCP Server.\n * It implements comprehensive analytics resources for collecting participant, room, \n * session, and team statistics.\n * \n * @module resources/analytics\n */\n\nimport { Resource } from '@modelcontextprotocol/sdk/types.js';\nimport { DigitalSambaApiClient } from '../../digital-samba-api.js';\nimport { AnalyticsResource } from '../../analytics.js';\nimport logger from '../../logger.js';\n\n/**\n * Register all analytics resources\n * \n * @param apiClient - The Digital Samba API client instance\n * @returns Array of MCP Resource definitions\n */\nexport function registerAnalyticsResources(apiClient: DigitalSambaApiClient): Resource[] {\n  const _analytics = new AnalyticsResource(apiClient);\n  \n  return [\n    {\n      uri: 'digitalsamba://analytics/participants',\n      name: 'analytics-participants',\n      description: 'Get participant analytics and statistics',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://analytics/usage',\n      name: 'analytics-usage',\n      description: 'Get usage statistics and growth metrics',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://analytics/rooms',\n      name: 'analytics-rooms',\n      description: 'Get room analytics and statistics',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://analytics/team',\n      name: 'analytics-team',\n      description: 'Get team-wide statistics and metrics',\n      mimeType: 'application/json'\n    }\n  ];\n}\n\n/**\n * Handle analytics resource requests\n * \n * @param uri - The resource URI being requested\n * @param apiClient - The Digital Samba API client instance\n * @returns The resource content\n */\nexport async function handleAnalyticsResource(uri: string, apiClient: DigitalSambaApiClient): Promise<any> {\n  const _analytics = new AnalyticsResource(apiClient);\n  \n  // Parse the URI to determine which resource is being requested\n  const uriParts = uri.split('/');\n  const resourceType = uriParts[3]; // analytics/[resourceType]\n  \n  switch (resourceType) {\n    case 'participants':\n      logger.info('Fetching participant analytics');\n      return await _analytics.getAllParticipants();\n      \n    case 'usage':\n      logger.info('Fetching usage statistics');\n      return await _analytics.getUsageStatistics();\n      \n    case 'rooms':\n      logger.info('Fetching room analytics');\n      return await _analytics.getRoomAnalytics();\n      \n    case 'team':\n      logger.info('Fetching team statistics');\n      return await _analytics.getTeamGlobalStatistics();\n      \n    default:\n      throw new Error(`Unknown analytics resource: ${resourceType}`);\n  }\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/resources/content/index.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'McpServer' is defined but never used.",
          "line": 25,
          "column": 10,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 25,
          "endColumn": 19
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 97,
          "column": 101,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 97,
          "endColumn": 104,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  2773,
                  2776
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  2773,
                  2776
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 1,
      "fatalErrorCount": 0,
      "warningCount": 1,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - Content Resources\n * \n * This module implements read-only resources for accessing content libraries,\n * folders, files, and hierarchies within Digital Samba.\n * \n * Resources provided:\n * - libraries: List all content libraries\n * - library: Get details of a specific library\n * - library-hierarchy: Get complete hierarchy of a library\n * - library-folders: List folders in a library\n * - library-folder: Get details of a specific folder\n * - library-files: List files in a library\n * - library-file: Get details of a specific file\n * \n * @module resources/content\n * @author Digital Samba Team\n * @version 1.0.0\n */\n\n// External dependencies\n// import { z } from 'zod'; // Removed: unused\n\n// MCP SDK imports\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { \n  ErrorCode, \n  McpError,\n  Resource \n} from '@modelcontextprotocol/sdk/types.js';\n\n// Local modules\nimport { \n  DigitalSambaApiClient, \n} from '../../digital-samba-api.js';\nimport logger from '../../logger.js';\n\n/**\n * Register content resources\n * \n * @returns Array of MCP Resource definitions\n */\nexport function registerContentResources(): Resource[] {\n  return [\n    {\n      uri: 'digitalsamba://libraries',\n      name: 'libraries',\n      description: 'List all content libraries',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://libraries/{id}',\n      name: 'library',\n      description: 'Get details of a specific library',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://libraries/{id}/hierarchy',\n      name: 'library-hierarchy',\n      description: 'Get complete hierarchy of a library',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://libraries/{id}/folders',\n      name: 'library-folders',\n      description: 'List folders in a library',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://libraries/{id}/folders/{folderId}',\n      name: 'library-folder',\n      description: 'Get details of a specific folder',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://libraries/{id}/files',\n      name: 'library-files',\n      description: 'List files in a library',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://libraries/{id}/files/{fileId}',\n      name: 'library-file',\n      description: 'Get details of a specific file',\n      mimeType: 'application/json'\n    }\n  ];\n}\n\n/**\n * Handle content resource requests\n * \n * @param {string} uri - The resource URI\n * @param {DigitalSambaApiClient} apiClient - The Digital Samba API client\n * @returns {Promise<any>} The resource content\n */\nexport async function handleContentResource(uri: string, apiClient: DigitalSambaApiClient): Promise<any> {\n  const parts = uri.split('/');\n  \n  // Parse library ID from URI like digitalsamba://libraries/{id}\n  const getLibraryId = () => {\n    const libraryIndex = parts.indexOf('libraries');\n    return libraryIndex !== -1 && parts[libraryIndex + 1] ? parts[libraryIndex + 1] : null;\n  };\n\n  // Parse folder ID from URI like digitalsamba://libraries/{id}/folders/{folderId}\n  const getFolderId = () => {\n    const folderIndex = parts.indexOf('folders');\n    return folderIndex !== -1 && parts[folderIndex + 1] ? parts[folderIndex + 1] : null;\n  };\n\n  // Parse file ID from URI like digitalsamba://libraries/{id}/files/{fileId}\n  const getFileId = () => {\n    const fileIndex = parts.indexOf('files');\n    return fileIndex !== -1 && parts[fileIndex + 1] ? parts[fileIndex + 1] : null;\n  };\n\n  try {\n    // List all libraries\n    if (uri === 'digitalsamba://libraries') {\n      logger.info('Listing all libraries');\n      const response = await apiClient.listLibraries({ limit: 100 });\n      \n      return {\n        content: [{\n          type: 'text',\n          text: JSON.stringify({\n            libraries: response.data,\n            total_count: response.total_count,\n            summary: `Found ${response.data.length} libraries`\n          }, null, 2)\n        }]\n      };\n    }\n\n    const libraryId = getLibraryId();\n    \n    if (!libraryId) {\n      throw new McpError(ErrorCode.InvalidRequest, 'Invalid resource URI format');\n    }\n\n    // Get library hierarchy\n    if (uri.includes('/hierarchy')) {\n      logger.info('Getting library hierarchy', { libraryId });\n      const hierarchy = await apiClient.getLibraryHierarchy(libraryId);\n      \n      return {\n        content: [{\n          type: 'text',\n          text: JSON.stringify({\n            library_id: libraryId,\n            hierarchy: hierarchy,\n            summary: 'Complete library hierarchy retrieved'\n          }, null, 2)\n        }]\n      };\n    }\n\n    // Get specific folder\n    const folderId = getFolderId();\n    if (folderId) {\n      logger.info('Getting folder details', { libraryId, folderId });\n      const folder = await apiClient.getLibraryFolder(libraryId, folderId);\n      \n      return {\n        content: [{\n          type: 'text',\n          text: JSON.stringify({\n            library_id: libraryId,\n            folder: folder,\n            summary: `Folder details for ID: ${folderId}`\n          }, null, 2)\n        }]\n      };\n    }\n\n    // List library folders\n    if (uri.includes('/folders')) {\n      logger.info('Listing library folders', { libraryId });\n      const response = await apiClient.listLibraryFolders(libraryId, { limit: 100 });\n      \n      return {\n        content: [{\n          type: 'text',\n          text: JSON.stringify({\n            library_id: libraryId,\n            folders: response.data,\n            total_count: response.total_count,\n            summary: `Found ${response.data.length} folders in library`\n          }, null, 2)\n        }]\n      };\n    }\n\n    // Get specific file\n    const fileId = getFileId();\n    if (fileId) {\n      logger.info('Getting file details', { libraryId, fileId });\n      const file = await apiClient.getLibraryFile(libraryId, fileId);\n      \n      return {\n        content: [{\n          type: 'text',\n          text: JSON.stringify({\n            library_id: libraryId,\n            file: file,\n            summary: `File details for ID: ${fileId}`\n          }, null, 2)\n        }]\n      };\n    }\n\n    // List library files\n    if (uri.includes('/files')) {\n      logger.info('Listing library files', { libraryId });\n      const files = await apiClient.listLibraryFiles(libraryId, { limit: 100 });\n      \n      return {\n        content: [{\n          type: 'text',\n          text: JSON.stringify({\n            library_id: libraryId,\n            files: files,\n            total_count: files.length,\n            summary: `Found ${files.length} files in library`\n          }, null, 2)\n        }]\n      };\n    }\n\n    // Get specific library\n    logger.info('Getting library details', { libraryId });\n    const library = await apiClient.getLibrary(libraryId);\n    \n    return {\n      content: [{\n        type: 'text',\n        text: JSON.stringify({\n          library: library,\n          summary: `Library details for ID: ${libraryId}`\n        }, null, 2)\n      }]\n    };\n\n  } catch (error) {\n    logger.error('Error handling content resource', { \n      uri, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error accessing content resource: ${errorMessage}`;\n    \n    if (errorMessage.includes('404') || errorMessage.includes('not found')) {\n      displayMessage = `Resource not found: ${uri}`;\n    } else if (errorMessage.includes('401') || errorMessage.includes('403')) {\n      displayMessage = 'Authentication failed. Please check your API key.';\n    }\n    \n    return {\n      content: [{\n        type: 'text',\n        text: JSON.stringify({\n          error: displayMessage,\n          uri: uri,\n          timestamp: new Date().toISOString()\n        }, null, 2)\n      }]\n    };\n  }\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/resources/exports/index.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'searchParams' is defined but never used. Allowed unused args must match /^_/u.",
          "line": 151,
          "column": 5,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 151,
          "endColumn": 17
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'searchParams' is defined but never used. Allowed unused args must match /^_/u.",
          "line": 179,
          "column": 5,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 179,
          "endColumn": 17
        }
      ],
      "suppressedMessages": [],
      "errorCount": 2,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Export Resources Module\n * \n * This module provides MCP resources for exporting various types of data from Digital Samba:\n * - Communication data (chat messages, Q&A, transcripts)\n * - Poll data and results\n * - Recording downloads and metadata\n * \n * Resources in this module are read-only and provide data export capabilities.\n * \n * @module resources/exports\n */\n\nimport { Resource } from '@modelcontextprotocol/sdk/types.js';\nimport { \n  ErrorCode, \n  McpError\n} from '@modelcontextprotocol/sdk/types.js';\nimport logger from '../../logger.js';\nimport { DigitalSambaApiClient } from '../../digital-samba-api.js';\n\n/**\n * Export Resources Class\n * Handles MCP resource requests for data exports\n */\nexport class ExportResources {\n  private api: DigitalSambaApiClient;\n\n  constructor(api: DigitalSambaApiClient) {\n    this.api = api;\n  }\n\n  /**\n   * Handle export resource requests\n   */\n  async handleResourceRequest(uri: string): Promise<{ contents: Array<{ type: string; text: string }> }> {\n    try {\n      logger.info(`Handling export resource request: ${uri}`);\n      \n      const url = new URL(uri);\n      const pathParts = url.pathname.split('/').filter(Boolean);\n      \n      if (pathParts.length < 2) {\n        throw new McpError(ErrorCode.InvalidRequest, 'Invalid export resource URI format');\n      }\n\n      const exportType = pathParts[1]; // exports/{exportType}/...\n      \n      switch (exportType) {\n        case 'communications':\n          return this.handleCommunicationExport(pathParts, url.searchParams);\n        case 'polls':\n          return this.handlePollsExport(pathParts, url.searchParams);\n        case 'recordings':\n          return this.handleRecordingExport(pathParts, url.searchParams);\n        case 'sessions':\n          return this.handleSessionExport(pathParts, url.searchParams);\n        default:\n          throw new McpError(ErrorCode.InvalidRequest, `Unknown export type: ${exportType}`);\n      }\n    } catch (error) {\n      logger.error(`Error handling export resource request: ${error}`);\n      if (error instanceof McpError) {\n        throw error;\n      }\n      throw new McpError(ErrorCode.InternalError, `Export resource error: ${error}`);\n    }\n  }\n\n  /**\n   * Handle communication data exports (chat, Q&A, transcripts)\n   */\n  private async handleCommunicationExport(\n    pathParts: string[], \n    searchParams: URLSearchParams\n  ): Promise<{ contents: Array<{ type: string; text: string }> }> {\n    if (pathParts.length < 4) {\n      throw new McpError(ErrorCode.InvalidRequest, 'Communication export requires: /communications/{roomId}/{type}');\n    }\n\n    const roomId = pathParts[2];\n    const commType = pathParts[3]; // chat, qa, transcripts\n    \n    const format = searchParams.get('format') || 'json';\n    const sessionId = searchParams.get('session_id') || undefined;\n\n    let exportData: string;\n    let description: string;\n\n    switch (commType) {\n      case 'chat':\n        exportData = await this.api.exportChatMessages(roomId, { format: format as 'txt' | 'json', session_id: sessionId });\n        description = `Chat messages export for room ${roomId}`;\n        break;\n      case 'qa':\n        exportData = await this.api.exportQA(roomId, { format: format as 'txt' | 'json', session_id: sessionId });\n        description = `Q&A export for room ${roomId}`;\n        break;\n      case 'transcripts':\n        if (!sessionId) {\n          throw new McpError(ErrorCode.InvalidRequest, 'Transcript export requires session_id parameter');\n        }\n        exportData = await this.api.exportTranscripts(sessionId, { format: format as 'txt' | 'json' });\n        description = `Transcript export for session ${sessionId}`;\n        break;\n      default:\n        throw new McpError(ErrorCode.InvalidRequest, `Unknown communication type: ${commType}`);\n    }\n\n    return {\n      contents: [{\n        type: 'text',\n        text: `# ${description}\\n\\nFormat: ${format.toUpperCase()}\\n${sessionId ? `Session: ${sessionId}\\n` : ''}\\n\\`\\`\\`${format}\\n${exportData}\\n\\`\\`\\``\n      }]\n    };\n  }\n\n  /**\n   * Handle polls data export\n   */\n  private async handlePollsExport(\n    pathParts: string[], \n    searchParams: URLSearchParams\n  ): Promise<{ contents: Array<{ type: string; text: string }> }> {\n    if (pathParts.length < 3) {\n      throw new McpError(ErrorCode.InvalidRequest, 'Polls export requires: /polls/{roomId}');\n    }\n\n    const roomId = pathParts[2];\n    const format = searchParams.get('format') || 'json';\n    const sessionId = searchParams.get('session_id') || undefined;\n\n    const exportData = await this.api.exportPolls(roomId, { \n      format: format as 'txt' | 'json', \n      session_id: sessionId \n    });\n\n    return {\n      contents: [{\n        type: 'text',\n        text: `# Polls Export for Room ${roomId}\\n\\nFormat: ${format.toUpperCase()}\\n${sessionId ? `Session: ${sessionId}\\n` : ''}\\n\\`\\`\\`${format}\\n${exportData}\\n\\`\\`\\``\n      }]\n    };\n  }\n\n  /**\n   * Handle recording export/download\n   */\n  private async handleRecordingExport(\n    pathParts: string[], \n    searchParams: URLSearchParams\n  ): Promise<{ contents: Array<{ type: string; text: string }> }> {\n    if (pathParts.length < 3) {\n      throw new McpError(ErrorCode.InvalidRequest, 'Recording export requires: /recordings/{recordingId}');\n    }\n\n    const recordingId = pathParts[2];\n    \n    try {\n      // Get recording metadata first\n      const recording = await this.api.getRecording(recordingId);\n      \n      return {\n        contents: [{\n          type: 'text',\n          text: `# Recording Export Information\\n\\n**Recording ID**: ${recordingId}\\n**Name**: ${recording.name || 'Unnamed'}\\n**Status**: ${recording.status}\\n**Duration**: ${recording.duration || 'Unknown'}\\n\\n**Download URL**: Use the \\`download-recording\\` tool to get the download link.\\n\\n**Metadata**:\\n\\`\\`\\`json\\n${JSON.stringify(recording, null, 2)}\\n\\`\\`\\``\n        }]\n      };\n    } catch (error) {\n      throw new McpError(ErrorCode.InvalidRequest, `Recording ${recordingId} not found or not accessible`);\n    }\n  }\n\n  /**\n   * Handle session data export\n   */\n  private async handleSessionExport(\n    pathParts: string[], \n    searchParams: URLSearchParams\n  ): Promise<{ contents: Array<{ type: string; text: string }> }> {\n    if (pathParts.length < 4) {\n      throw new McpError(ErrorCode.InvalidRequest, 'Session export requires: /sessions/{sessionId}/{type}');\n    }\n\n    const sessionId = pathParts[2];\n    const exportType = pathParts[3]; // summary, metadata\n    \n    try {\n      const session = await this.api.getSessionStatistics(sessionId);\n      \n      switch (exportType) {\n        case 'summary':\n          return {\n            contents: [{\n              type: 'text',\n              text: `# Session Summary\\n\\n**Session ID**: ${sessionId}\\n**Room**: ${session.room_description || session.room_id}\\n**Started**: ${session.session_start_time}\\n**Ended**: ${session.session_end_time || 'Ongoing'}\\n**Duration**: ${session.session_duration || 'Unknown'} minutes\\n**Live**: ${session.session_live ? 'Yes' : 'No'}\\n**Participation Minutes**: ${session.participation_minutes}\\n\\n**Session Data**:\\n\\`\\`\\`json\\n${JSON.stringify(session, null, 2)}\\n\\`\\`\\``\n            }]\n          };\n        case 'metadata':\n          return {\n            contents: [{\n              type: 'text',\n              text: `# Session Metadata Export\\n\\n\\`\\`\\`json\\n${JSON.stringify(session, null, 2)}\\n\\`\\`\\``\n            }]\n          };\n        default:\n          throw new McpError(ErrorCode.InvalidRequest, `Unknown session export type: ${exportType}`);\n      }\n    } catch (error) {\n      throw new McpError(ErrorCode.InvalidRequest, `Session ${sessionId} not found or not accessible`);\n    }\n  }\n}\n\n/**\n * Register export resources with the MCP server\n */\nexport function registerExportResources(): Resource[] {\n  return [\n    {\n      uri: 'digitalsamba://exports/communications/{roomId}/chat',\n      name: 'Chat Messages Export',\n      description: 'Export chat messages from a room. Supports format (txt/json) and session_id parameters.',\n      mimeType: 'text/plain'\n    },\n    {\n      uri: 'digitalsamba://exports/communications/{roomId}/qa',\n      name: 'Q&A Export', \n      description: 'Export questions and answers from a room. Supports format (txt/json) and session_id parameters.',\n      mimeType: 'text/plain'\n    },\n    {\n      uri: 'digitalsamba://exports/communications/{sessionId}/transcripts',\n      name: 'Transcript Export',\n      description: 'Export session transcripts. Requires session_id, supports format (txt/json) parameter.',\n      mimeType: 'text/plain'\n    },\n    {\n      uri: 'digitalsamba://exports/polls/{roomId}',\n      name: 'Polls Export',\n      description: 'Export poll data and results from a room. Supports format (txt/json) and session_id parameters.',\n      mimeType: 'text/plain'\n    },\n    {\n      uri: 'digitalsamba://exports/recordings/{recordingId}',\n      name: 'Recording Export Info',\n      description: 'Get recording metadata and download information.',\n      mimeType: 'text/plain'\n    },\n    {\n      uri: 'digitalsamba://exports/sessions/{sessionId}/summary',\n      name: 'Session Summary Export',\n      description: 'Export a comprehensive session summary with key metrics and data.',\n      mimeType: 'text/plain'\n    },\n    {\n      uri: 'digitalsamba://exports/sessions/{sessionId}/metadata',\n      name: 'Session Metadata Export',\n      description: 'Export complete session metadata in JSON format.',\n      mimeType: 'text/plain'\n    }\n  ];\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/resources/recordings/index.ts",
      "messages": [],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/resources/rooms/index.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 49,
          "column": 11,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 49,
          "endColumn": 14,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1348,
                  1351
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1348,
                  1351
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 50,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 50,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1364,
                  1367
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1364,
                  1367
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 54,
          "column": 16,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 54,
          "endColumn": 19,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1438,
                  1441
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1438,
                  1441
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 60,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 60,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1612,
                  1615
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1612,
                  1615
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 4,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Room Resources Module\n * \n * This module provides read-only room resources for the Digital Samba MCP Server.\n * It implements resources for listing and retrieving room information.\n * \n * @module resources/rooms\n */\n\nimport { Resource } from '@modelcontextprotocol/sdk/types.js';\nimport { DigitalSambaApiClient } from '../../digital-samba-api.js';\nimport { EnhancedDigitalSambaApiClient } from '../../digital-samba-api-enhanced.js';\nimport { getApiKeyFromRequest } from '../../auth.js';\nimport logger from '../../logger.js';\n\n/**\n * Register all room resources\n * \n * @returns Array of MCP Resource definitions\n */\nexport function registerRoomResources(): Resource[] {\n  return [\n    {\n      uri: 'digitalsamba://rooms',\n      name: 'rooms',\n      description: 'List all rooms',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://rooms/{roomId}',\n      name: 'room',\n      description: 'Get details for a specific room',\n      mimeType: 'application/json'\n    }\n  ];\n}\n\n/**\n * Handle room resource requests\n * \n * @param uri - The resource URI being requested\n * @param params - URL parameters from the URI\n * @param request - The MCP request object\n * @param options - Server options including API configuration\n * @returns The resource content\n */\nexport async function handleRoomResource(\n  uri: string,\n  params: any,\n  request: any,\n  options: {\n    apiUrl: string;\n    apiKey?: string;\n    apiCache?: any;\n    enableConnectionManagement?: boolean;\n    enableTokenManagement?: boolean;\n    enableResourceOptimization?: boolean;\n    connectionPoolSize?: number;\n  }\n): Promise<any> {\n  const { apiUrl, apiCache, enableConnectionManagement, enableTokenManagement, enableResourceOptimization, connectionPoolSize } = options;\n  \n  // Parse the URI to determine which resource is being requested\n  const uriParts = uri.split('/');\n  const isSpecificRoom = uriParts.length > 3 && uriParts[3] !== '';\n  \n  if (isSpecificRoom) {\n    // Handle specific room request\n    const roomId = params.roomId || uriParts[3];\n    \n    if (!roomId) {\n      throw new Error('Room ID is required.');\n    }\n    \n    logger.info('Getting room details', { roomId });\n    \n    // Get API key from session context\n    const apiKey = getApiKeyFromRequest(request);\n    if (!apiKey) {\n      throw new Error('No API key found. Please include an Authorization header with a Bearer token.');\n    }\n    \n    // Create API client\n    logger.debug('Creating API client using context API key');\n    \n    let client;\n    if (enableConnectionManagement || enableTokenManagement || enableResourceOptimization) {\n      // Use enhanced API client\n      logger.debug('Using enhanced API client with additional features enabled');\n      client = new EnhancedDigitalSambaApiClient(\n        undefined,\n        apiUrl,\n        apiCache,\n        {\n          enableConnectionManagement,\n          enableTokenManagement,\n          enableResourceOptimization,\n          connectionPoolSize\n        }\n      );\n    } else {\n      // Use standard API client\n      client = new DigitalSambaApiClient(undefined, apiUrl, apiCache);\n    }\n    \n    try {\n      // Get room from API\n      const room = await client.getRoom(roomId);\n      \n      // Format room as resource content\n      const content = {\n        uri: uri,\n        text: JSON.stringify(room, null, 2),\n      };\n      \n      return { contents: [content] };\n    } catch (error) {\n      logger.error('Error fetching room', { \n        roomId, \n        error: error instanceof Error ? error.message : String(error) \n      });\n      throw error;\n    }\n  } else {\n    // Handle room listing\n    logger.info('Listing rooms');\n    \n    // Get API key from various sources in priority order:\n    // 1. Direct API key passed in options during server creation \n    // 2. API key from session context\n    // 3. Environment variable\n    let apiKey = options?.apiKey;\n    \n    if (!apiKey) {\n      apiKey = getApiKeyFromRequest(request);\n    }\n    \n    if (!apiKey && process.env.DIGITAL_SAMBA_API_KEY) {\n      apiKey = process.env.DIGITAL_SAMBA_API_KEY;\n      logger.debug('Using API key from environment variable');\n    }\n    \n    if (!apiKey) {\n      throw new Error('No API key found. Please include an Authorization header with a Bearer token.');\n    }\n    \n    // Create API client\n    logger.debug('Creating API client with key', { \n      apiKeyLength: apiKey ? apiKey.length : 0,\n      apiUrl: apiUrl\n    });\n    \n    let client;\n    if (enableConnectionManagement || enableTokenManagement || enableResourceOptimization) {\n      // Use enhanced API client\n      logger.debug('Using enhanced API client with additional features enabled');\n      client = new EnhancedDigitalSambaApiClient(\n        apiKey,\n        apiUrl,\n        apiCache,\n        {\n          enableConnectionManagement,\n          enableTokenManagement,\n          enableResourceOptimization,\n          connectionPoolSize\n        }\n      );\n    } else {\n      // Use standard API client\n      client = new DigitalSambaApiClient(apiKey, apiUrl, apiCache);\n    }\n    \n    try {\n      // Fetch rooms from API\n      const rooms = await client.listRooms();\n      logger.info('Fetched rooms successfully', { count: rooms.data.length });\n      \n      // Format rooms as resource contents\n      const contents = rooms.data.map(room => ({\n        uri: `digitalsamba://rooms/${room.id}`,\n        text: JSON.stringify(room, null, 2),\n      }));\n      \n      return { contents };\n    } catch (error) {\n      logger.error('Error fetching rooms', { \n        error: error instanceof Error ? error.message : String(error) \n      });\n      throw error;\n    }\n  }\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/resources/sessions/index.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 67,
          "column": 11,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 67,
          "endColumn": 14,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1942,
                  1945
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1942,
                  1945
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 68,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 68,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1958,
                  1961
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1958,
                  1961
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 71,
          "column": 16,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 71,
          "endColumn": 19,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  2011,
                  2014
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  2011,
                  2014
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 73,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 73,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  2031,
                  2034
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  2031,
                  2034
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 4,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Session Resources Module\n * \n * This module provides read-only session resources for the Digital Samba MCP Server.\n * It implements resources for listing sessions, retrieving session details,\n * session participants, and session statistics.\n * \n * @module resources/sessions\n */\n\nimport { Resource } from '@modelcontextprotocol/sdk/types.js';\nimport { DigitalSambaApiClient } from '../../digital-samba-api.js';\nimport { getApiKeyFromRequest } from '../../auth.js';\nimport logger from '../../logger.js';\n\n/**\n * Register all session resources\n * \n * @returns Array of MCP Resource definitions\n */\nexport function registerSessionResources(): Resource[] {\n  return [\n    {\n      uri: 'digitalsamba://sessions',\n      name: 'sessions',\n      description: 'List all sessions',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://sessions/{sessionId}',\n      name: 'session',\n      description: 'Get session summary and details',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://sessions/{sessionId}/participants',\n      name: 'session-participants',\n      description: 'List participants in a session',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://sessions/{sessionId}/statistics',\n      name: 'session-statistics',\n      description: 'Get session statistics and metrics',\n      mimeType: 'application/json'\n    },\n    {\n      uri: 'digitalsamba://rooms/{roomId}/sessions',\n      name: 'room-sessions',\n      description: 'List sessions for a specific room',\n      mimeType: 'application/json'\n    }\n  ];\n}\n\n/**\n * Handle session resource requests\n * \n * @param uri - The resource URI being requested\n * @param params - URL parameters from the URI\n * @param request - The MCP request object\n * @param options - Server options including API configuration\n * @returns The resource content\n */\nexport async function handleSessionResource(\n  uri: string,\n  params: any,\n  request: any,\n  options: {\n    apiUrl: string;\n    apiCache?: any;\n  }\n): Promise<any> {\n  const { apiUrl, apiCache } = options;\n  \n  // Get API key from session context\n  const apiKey = getApiKeyFromRequest(request);\n  if (!apiKey) {\n    throw new Error('No API key found. Please include an Authorization header with a Bearer token.');\n  }\n  \n  // Create API client\n  const client = new DigitalSambaApiClient(undefined, apiUrl, apiCache);\n  \n  // Parse the URI to determine which resource is being requested\n  const uriParts = uri.split('/');\n  \n  try {\n    // Handle different session resource types\n    if (uri.includes('/rooms/') && uri.endsWith('/sessions')) {\n      // Room sessions: digitalsamba://rooms/{roomId}/sessions\n      const roomId = params.roomId || uriParts[3];\n      \n      if (!roomId) {\n        throw new Error('Room ID is required.');\n      }\n      \n      logger.info('Fetching sessions for room', { roomId });\n      const response = await client.listRoomSessions(roomId);\n      const sessions = response.data || [];\n      \n      // Format sessions as resource contents\n      const contents = sessions.map(session => ({\n        uri: `digitalsamba://sessions/${session.id}`,\n        text: JSON.stringify(session, null, 2),\n      }));\n      \n      return { contents };\n      \n    } else if (uri.includes('/participants')) {\n      // Session participants: digitalsamba://sessions/{sessionId}/participants\n      const sessionId = params.sessionId || uriParts[3];\n      \n      if (!sessionId) {\n        throw new Error('Session ID is required.');\n      }\n      \n      logger.info('Fetching participants for session', { sessionId });\n      const response = await client.listSessionParticipants(sessionId);\n      const participants = response.data || [];\n      \n      // Format participants as resource contents\n      const contents = participants.map(participant => ({\n        uri: `digitalsamba://participants/${participant.id}`,\n        text: JSON.stringify(participant, null, 2),\n      }));\n      \n      return { contents };\n      \n    } else if (uri.includes('/statistics')) {\n      // Session statistics: digitalsamba://sessions/{sessionId}/statistics\n      const sessionId = params.sessionId || uriParts[3];\n      \n      if (!sessionId) {\n        throw new Error('Session ID is required.');\n      }\n      \n      logger.info('Fetching statistics for session', { sessionId });\n      const statistics = await client.getSessionStatistics(sessionId);\n      \n      return {\n        contents: [{\n          uri: uri,\n          text: JSON.stringify(statistics, null, 2),\n        }]\n      };\n      \n    } else if (uriParts.length > 3 && uriParts[3] !== '') {\n      // Specific session: digitalsamba://sessions/{sessionId}\n      const sessionId = params.sessionId || uriParts[3];\n      \n      if (!sessionId) {\n        throw new Error('Session ID is required.');\n      }\n      \n      logger.info('Fetching session summary', { sessionId });\n      const session = await client.getSessionSummary(sessionId);\n      \n      return {\n        contents: [{\n          uri: uri,\n          text: JSON.stringify(session, null, 2),\n        }]\n      };\n      \n    } else {\n      // List all sessions: digitalsamba://sessions\n      logger.info('Fetching all sessions');\n      const response = await client.listSessions();\n      const sessions = response.data || [];\n      \n      // Format sessions as resource contents\n      const contents = sessions.map(session => ({\n        uri: `digitalsamba://sessions/${session.id}`,\n        text: JSON.stringify(session, null, 2),\n      }));\n      \n      return { contents };\n    }\n  } catch (error) {\n    logger.error('Error handling session resource', {\n      uri,\n      error: error instanceof Error ? error.message : String(error)\n    });\n    throw error;\n  }\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/server-core.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'serverOptions' is assigned a value but never used.",
          "line": 61,
          "column": 5,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 61,
          "endColumn": 18
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'apiKey' is defined but never used. Allowed unused args must match /^_/u.",
          "line": 103,
          "column": 3,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 103,
          "endColumn": 9
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'cache' is defined but never used. Allowed unused args must match /^_/u.",
          "line": 105,
          "column": 3,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 105,
          "endColumn": 8
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'server' is defined but never used. Allowed unused args must match /^_/u.",
          "line": 123,
          "column": 3,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 123,
          "endColumn": 9
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'apiKey' is defined but never used. Allowed unused args must match /^_/u.",
          "line": 124,
          "column": 3,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 124,
          "endColumn": 9
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'apiUrl' is defined but never used. Allowed unused args must match /^_/u.",
          "line": 125,
          "column": 3,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 125,
          "endColumn": 9
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'cache' is defined but never used. Allowed unused args must match /^_/u.",
          "line": 126,
          "column": 3,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 126,
          "endColumn": 8
        }
      ],
      "suppressedMessages": [],
      "errorCount": 7,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - Shared Core\n * \n * This module contains the shared server logic that is used by both HTTP and STDIO transports.\n * It provides a unified interface for creating the MCP server with consistent functionality\n * across different transport modes.\n * \n * @module server-core\n * @author Digital Samba Team\n * @version 1.0.0\n */\n\n// MCP SDK imports\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\n\n// Local modules\nimport { setupRecordingFunctionality } from './recordings.js';\nimport { setupWebhookTools } from './webhooks.js';\nimport WebhookService from './webhooks.js';\nimport { MemoryCache } from './cache.js';\nimport logger from './logger.js';\nimport { ServerOptions } from './index.js';\n\n/**\n * Configuration for creating the shared server core\n */\nexport interface ServerCoreConfig {\n  /** API key for Digital Samba API (required for STDIO mode) */\n  apiKey?: string;\n  /** Base URL for Digital Samba API */\n  apiUrl?: string;\n  /** Cache instance to use */\n  _cache?: MemoryCache;\n  /** Whether to enable webhook functionality */\n  enableWebhooks?: boolean;\n  /** Webhook secret for verification */\n  webhookSecret?: string;\n  /** Webhook endpoint path */\n  webhookEndpoint?: string;\n  /** Server options from the main configuration */\n  serverOptions?: Partial<ServerOptions>;\n}\n\n/**\n * Create a shared MCP server core with consistent functionality\n * \n * This function creates the base MCP server and sets up all the core functionality\n * that should be available regardless of transport type (HTTP or STDIO).\n * \n * @param config - Configuration for the server core\n * @returns The configured MCP server instance\n */\nexport function createServerCore(config: ServerCoreConfig): McpServer {\n  const {\n    apiKey,\n    apiUrl = 'https://api.digitalsamba.com/api/v1',\n    _cache,\n    enableWebhooks = false,\n    webhookSecret,\n    webhookEndpoint = '/webhooks/digitalsamba',\n    serverOptions = {}\n  } = config;\n\n  logger.info('Creating server core', {\n    apiUrl,\n    hasApiKey: !!apiKey,\n    hasCache: !!_cache,\n    enableWebhooks\n  });\n\n  // Create the MCP server\n  const server = new McpServer({\n    name: 'Digital Samba MCP Server',\n    version: '1.0.0',\n  });\n\n  // Set up core functionality that applies to all transport types\n  setupCoreResources(server, apiKey, apiUrl, _cache);\n  setupCoreTools(server, apiKey, apiUrl, _cache);\n  \n  // Set up recording functionality (v1.0 scope - no live recording controls)\n  setupRecordingFunctionality(server, apiUrl);\n\n  // Set up webhooks if enabled (mainly for HTTP transport)\n  if (enableWebhooks) {\n    const webhookService = new WebhookService(server, {\n      secret: webhookSecret,\n      endpoint: webhookEndpoint\n    });\n    \n    setupWebhookTools(server, webhookService, apiUrl);\n  }\n\n  logger.info('Server core created successfully');\n  return server;\n}\n\n/**\n * Set up core resources that are available in both HTTP and STDIO modes\n */\nfunction setupCoreResources(\n  _server: McpServer, \n  apiKey: string | undefined, \n  _apiUrl: string, \n  cache?: MemoryCache\n): void {\n  // Import the resource setup from the main index file\n  // This ensures we use the exact same resource definitions\n  \n  // For now, we'll import these from the main index.ts\n  // In a future refactor, we could extract these to separate modules\n  logger.debug('Core resources will be set up by transport-specific implementations');\n  \n  // Note: The actual resource setup is currently handled by the main index.ts\n  // to avoid circular dependencies. In the future, we could extract resources\n  // to separate modules (e.g., src/resources/) for better organization.\n}\n\n/**\n * Set up core tools that are available in both HTTP and STDIO modes  \n */\nfunction setupCoreTools(\n  server: McpServer,\n  apiKey: string | undefined,\n  apiUrl: string,\n  cache?: MemoryCache\n): void {\n  // Import the tool setup from the main index file\n  // This ensures we use the exact same tool definitions\n  \n  logger.debug('Core tools will be set up by transport-specific implementations');\n  \n  // Note: The actual tool setup is currently handled by the main index.ts\n  // to avoid circular dependencies. In the future, we could extract tools\n  // to separate modules (e.g., src/tools/) for better organization.\n}\n\n/**\n * Utility function to merge server options with defaults\n */\nexport function mergeServerOptions(\n  provided: Partial<ServerOptions>,\n  defaults: Partial<ServerOptions>\n): Partial<ServerOptions> {\n  return {\n    ...defaults,\n    ...provided\n  };\n}\n\n/**\n * Utility function to validate required configuration for different modes\n */\nexport function validateServerConfig(config: ServerCoreConfig, mode: 'http' | 'stdio'): void {\n  if (mode === 'stdio' && !config.apiKey) {\n    throw new Error('API key is required for STDIO mode');\n  }\n  \n  if (!config.apiUrl) {\n    throw new Error('API URL is required');\n  }\n  \n  logger.debug('Server configuration validated', { mode });\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/sessions.ts",
      "messages": [],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/stdio-full-server.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 25,
          "column": 45,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 25,
          "endColumn": 48,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  912,
                  915
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  912,
                  915
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 1,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "#!/usr/bin/env node\n\nimport { runStdioServer, validateStdioConfig } from './transports/stdio-transport.js';\nimport logger from './logger.js';\n\nexport async function runFullStdioServer(): Promise<void> {\n  const apiKey = process.env.DIGITAL_SAMBA_API_KEY;\n  \n  if (!apiKey) {\n    console.error('No API key provided. Please set DIGITAL_SAMBA_API_KEY environment variable.');\n    process.exit(1);\n  }\n\n  console.error('[INFO] Starting Digital Samba MCP Server (full stdio mode)...');\n  console.error('[DEBUG] API Key found:', apiKey.substring(0, 5) + '...');\n\n  try {\n    // Create configuration for STDIO transport\n    const stdioConfig = {\n      apiKey,\n      apiUrl: process.env.DIGITAL_SAMBA_API_URL,\n      serverOptions: {\n        enableCache: process.env.ENABLE_CACHE !== 'false',\n        cacheTtl: process.env.CACHE_TTL ? parseInt(process.env.CACHE_TTL) : 300000,\n        logLevel: (process.env.LOG_LEVEL as any) || 'info'\n      }\n    };\n\n    // Validate configuration\n    validateStdioConfig(stdioConfig);\n\n    // Run the STDIO server using the transport wrapper\n    await runStdioServer(stdioConfig);\n    \n    console.error('[INFO] MCP server connected successfully with full features');\n  } catch (error) {\n    logger.error('Failed to start STDIO server', { \n      error: error instanceof Error ? error.message : String(error) \n    });\n    console.error('[ERROR] Failed to connect:', error);\n    process.exit(1);\n  }\n}\n\n// Run if executed directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  runFullStdioServer().catch(error => {\n    console.error('[FATAL] Server failed:', error);\n    process.exit(1);\n  });\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/token-manager.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'TokenRefreshResult' is defined but never used.",
          "line": 80,
          "column": 11,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 80,
          "endColumn": 29
        }
      ],
      "suppressedMessages": [],
      "errorCount": 1,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - Token Manager Module\n * \n * This module provides functionality for managing API tokens, including automatic\n * refresh of tokens when they expire and connection management for maintaining\n * a stable connection to the Digital Samba API.\n * \n * Features include:\n * - Token refresh based on expiration monitoring\n * - Background token refresh to avoid service interruption\n * - Automatic retry with exponential backoff for failed refresh attempts\n * - Event emission for token refresh lifecycle events\n * - Configurable refresh settings\n * \n * @module token-manager\n * @author Digital Samba Team\n * @version 0.1.0\n */\n// Node.js built-in modules\nimport { EventEmitter } from 'events';\n\n// Local modules\nimport logger from './logger.js';\nimport apiKeyContext from './auth.js';\nimport { AuthenticationError } from './errors.js';\nimport { DigitalSambaApiClient, TokenOptions } from './digital-samba-api.js';\n\n/**\n * Token manager options interface\n */\nexport interface TokenManagerOptions {\n  /** API URL for the Digital Samba API */\n  apiUrl?: string;\n  \n  /** Room ID for generating tokens */\n  roomId: string;\n  \n  /** Token options for generating tokens */\n  tokenOptions: TokenOptions;\n  \n  /** Refresh margin before expiration in milliseconds (default: 5 minutes) */\n  refreshMarginMs?: number;\n  \n  /** Maximum number of refresh attempts (default: 3) */\n  maxRefreshAttempts?: number;\n  \n  /** Initial backoff time for failed refresh attempts in milliseconds (default: 1000) */\n  initialBackoffMs?: number;\n  \n  /** Maximum backoff time for failed refresh attempts in milliseconds (default: 30000) */\n  maxBackoffMs?: number;\n  \n  /** Whether to retry on auth errors (default: false) */\n  retryOnAuthError?: boolean;\n}\n\n/**\n * Token object with expiration and other metadata\n */\nexport interface Token {\n  /** The actual token string */\n  token: string;\n  \n  /** The room link */\n  link: string;\n  \n  /** When the token was created */\n  createdAt: Date;\n  \n  /** When the token expires, calculated from token options */\n  expiresAt: Date;\n  \n  /** Session ID associated with this token */\n  sessionId?: string;\n}\n\n/**\n * Token refresh result\n */\ninterface TokenRefreshResult {\n  /** The new token */\n  token: Token;\n  \n  /** Whether the refresh was successful */\n  success: boolean;\n  \n  /** Error message if refresh failed */\n  error?: string;\n  \n  /** The attempt number */\n  attempt: number;\n}\n\n/**\n * Token Manager class\n * \n * Manages room tokens for the Digital Samba API, handling automatic refresh\n * and expiration monitoring.\n */\nexport class TokenManager extends EventEmitter {\n  private options: Required<TokenManagerOptions>;\n  private tokens: Map<string, Token> = new Map();\n  private refreshTimers: Map<string, NodeJS.Timeout> = new Map();\n  private refreshing: Map<string, boolean> = new Map();\n  private apiClient: DigitalSambaApiClient;\n  \n  /**\n   * Token Manager constructor\n   * @param options Token manager options\n   */\n  constructor(options: TokenManagerOptions) {\n    super();\n    \n    // Set default options\n    this.options = {\n      apiUrl: process.env.DIGITAL_SAMBA_API_URL || 'https://api.digitalsamba.com/api/v1',\n      roomId: options.roomId,\n      tokenOptions: options.tokenOptions,\n      refreshMarginMs: options.refreshMarginMs || 5 * 60 * 1000, // 5 minutes\n      maxRefreshAttempts: options.maxRefreshAttempts || 3,\n      initialBackoffMs: options.initialBackoffMs || 1000, // 1 second\n      maxBackoffMs: options.maxBackoffMs || 30 * 1000, // 30 seconds\n      retryOnAuthError: options.retryOnAuthError || false\n    };\n    \n    // Initialize API client\n    this.apiClient = new DigitalSambaApiClient(undefined, this.options.apiUrl);\n    \n    logger.info('Token Manager initialized', {\n      roomId: this.options.roomId,\n      refreshMargin: `${this.options.refreshMarginMs / 1000} seconds`,\n      maxRefreshAttempts: this.options.maxRefreshAttempts\n    });\n  }\n  \n  /**\n   * Generate a new token\n   * @param sessionId Session ID for the token\n   * @param apiKey API key to use for token generation\n   * @returns Promise resolving to the generated token\n   */\n  public async generateToken(sessionId: string, apiKey?: string): Promise<Token> {\n    try {\n      logger.info('Generating new token', { sessionId, roomId: this.options.roomId });\n      \n      // If API key is provided, use it directly\n      const client = apiKey \n        ? new DigitalSambaApiClient(apiKey, this.options.apiUrl)\n        : this.apiClient;\n      \n      const response = await client.generateRoomToken(this.options.roomId, this.options.tokenOptions);\n      \n      // Calculate expiration time\n      const expiresInMinutes = this.options.tokenOptions.exp \n        ? parseInt(this.options.tokenOptions.exp, 10) \n        : 60; // Default to 1 hour if not specified\n      \n      const createdAt = new Date();\n      const expiresAt = new Date(createdAt.getTime() + (expiresInMinutes * 60 * 1000));\n      \n      // Create token object\n      const token: Token = {\n        token: response.token,\n        link: response.link,\n        createdAt,\n        expiresAt,\n        sessionId\n      };\n      \n      // Store token\n      this.tokens.set(sessionId, token);\n      \n      // Schedule refresh\n      this.scheduleRefresh(sessionId);\n      \n      logger.info('Token generated successfully', { \n        sessionId, \n        expires: expiresAt.toISOString() \n      });\n      \n      // Emit event\n      this.emit('token:generated', { sessionId, expiresAt });\n      \n      return token;\n    } catch (error) {\n      logger.error('Error generating token', {\n        sessionId,\n        roomId: this.options.roomId,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      \n      // Emit event\n      this.emit('token:error', { \n        sessionId, \n        error: error instanceof Error ? error.message : String(error) \n      });\n      \n      throw error;\n    }\n  }\n  \n  /**\n   * Get a token for a session\n   * @param sessionId Session ID\n   * @returns The token or undefined if not found\n   */\n  public getToken(sessionId: string): Token | undefined {\n    return this.tokens.get(sessionId);\n  }\n  \n  /**\n   * Check if a token is expired\n   * @param token Token to check\n   * @returns Whether the token is expired\n   */\n  public isTokenExpired(token: Token): boolean {\n    return token.expiresAt.getTime() <= Date.now();\n  }\n  \n  /**\n   * Check if a token is about to expire (within the refresh margin)\n   * @param token Token to check\n   * @returns Whether the token is about to expire\n   */\n  public isTokenExpiring(token: Token): boolean {\n    return token.expiresAt.getTime() <= (Date.now() + this.options.refreshMarginMs);\n  }\n  \n  /**\n   * Schedule a token refresh\n   * @param sessionId Session ID\n   */\n  private scheduleRefresh(sessionId: string): void {\n    // Clear any existing timer\n    this.clearRefreshTimer(sessionId);\n    \n    const token = this.tokens.get(sessionId);\n    if (!token) {\n      logger.warn('Cannot schedule refresh for non-existent token', { sessionId });\n      return;\n    }\n    \n    // Calculate time until refresh\n    const now = Date.now();\n    const refreshTime = token.expiresAt.getTime() - this.options.refreshMarginMs;\n    const timeUntilRefresh = Math.max(0, refreshTime - now);\n    \n    logger.debug('Scheduling token refresh', {\n      sessionId,\n      refreshIn: `${Math.round(timeUntilRefresh / 1000)} seconds`,\n      expiresAt: token.expiresAt.toISOString()\n    });\n    \n    // Set refresh timer\n    const timerId = setTimeout(() => {\n      this.refreshToken(sessionId);\n    }, timeUntilRefresh);\n    \n    // Store timer reference\n    this.refreshTimers.set(sessionId, timerId);\n  }\n  \n  /**\n   * Clear a refresh timer\n   * @param sessionId Session ID\n   */\n  private clearRefreshTimer(sessionId: string): void {\n    const timerId = this.refreshTimers.get(sessionId);\n    if (timerId) {\n      clearTimeout(timerId);\n      this.refreshTimers.delete(sessionId);\n    }\n  }\n  \n  /**\n   * Refresh a token\n   * @param sessionId Session ID\n   * @param attempt Attempt number (for retries)\n   */\n  private async refreshToken(sessionId: string, attempt: number = 1): Promise<void> {\n    // Check if already refreshing\n    if (this.refreshing.get(sessionId)) {\n      logger.debug('Token refresh already in progress', { sessionId });\n      return;\n    }\n    \n    this.refreshing.set(sessionId, true);\n    \n    try {\n      logger.info('Refreshing token', { sessionId, attempt });\n      \n      // Emit event\n      this.emit('token:refreshing', { sessionId, attempt });\n      \n      // Get API key from context\n      const apiKey = apiKeyContext.getApiKey(sessionId);\n      if (!apiKey) {\n        throw new AuthenticationError('No API key found for session');\n      }\n      \n      // Generate new token\n      const token = await this.generateToken(sessionId, apiKey);\n      \n      // Emit success event\n      this.emit('token:refreshed', { \n        sessionId, \n        expiresAt: token.expiresAt \n      });\n      \n      logger.info('Token refreshed successfully', {\n        sessionId,\n        expiresAt: token.expiresAt.toISOString()\n      });\n    } catch (error) {\n      logger.error('Error refreshing token', {\n        sessionId,\n        attempt,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      \n      // Check if we should retry\n      const isAuthError = error instanceof AuthenticationError;\n      if (\n        attempt < this.options.maxRefreshAttempts && \n        (!isAuthError || this.options.retryOnAuthError)\n      ) {\n        // Calculate backoff time with exponential backoff\n        const backoffTime = Math.min(\n          this.options.initialBackoffMs * Math.pow(2, attempt - 1),\n          this.options.maxBackoffMs\n        );\n        \n        logger.info('Scheduling token refresh retry', {\n          sessionId,\n          attempt: attempt + 1,\n          backoffTime: `${backoffTime / 1000} seconds`\n        });\n        \n        // Schedule retry\n        setTimeout(() => {\n          this.refreshToken(sessionId, attempt + 1);\n        }, backoffTime);\n        \n        // Emit retry event\n        this.emit('token:refresh-retry', { \n          sessionId, \n          attempt, \n          nextAttempt: attempt + 1, \n          backoffMs: backoffTime \n        });\n      } else {\n        // Max attempts reached or auth error\n        logger.error('Token refresh failed after max attempts', {\n          sessionId,\n          maxAttempts: this.options.maxRefreshAttempts\n        });\n        \n        // Emit failure event\n        this.emit('token:refresh-failed', { \n          sessionId, \n          attempts: attempt,\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n    } finally {\n      this.refreshing.set(sessionId, false);\n    }\n  }\n  \n  /**\n   * Remove a token\n   * @param sessionId Session ID\n   * @returns Whether the token was removed\n   */\n  public removeToken(sessionId: string): boolean {\n    // Clear refresh timer\n    this.clearRefreshTimer(sessionId);\n    \n    // Remove from refreshing map\n    this.refreshing.delete(sessionId);\n    \n    // Remove from tokens map\n    const removed = this.tokens.delete(sessionId);\n    \n    if (removed) {\n      logger.info('Token removed', { sessionId });\n      \n      // Emit event\n      this.emit('token:removed', { sessionId });\n    }\n    \n    return removed;\n  }\n  \n  /**\n   * Get all managed tokens\n   * @returns All tokens\n   */\n  public getAllTokens(): Map<string, Token> {\n    return new Map(this.tokens);\n  }\n  \n  /**\n   * Get statistics about managed tokens\n   * @returns Token statistics\n   */\n  public getStats(): {\n    totalTokens: number;\n    expiredTokens: number;\n    expiringTokens: number;\n    activeRefreshes: number;\n  } {\n    const now = Date.now();\n    let expiredTokens = 0;\n    let expiringTokens = 0;\n    \n    for (const token of this.tokens.values()) {\n      if (token.expiresAt.getTime() <= now) {\n        expiredTokens++;\n      } else if (token.expiresAt.getTime() <= (now + this.options.refreshMarginMs)) {\n        expiringTokens++;\n      }\n    }\n    \n    return {\n      totalTokens: this.tokens.size,\n      expiredTokens,\n      expiringTokens,\n      activeRefreshes: Array.from(this.refreshing.values()).filter(r => r).length\n    };\n  }\n  \n  /**\n   * Clean up resources\n   */\n  public destroy(): void {\n    // Clear all refresh timers\n    for (const timerId of this.refreshTimers.values()) {\n      clearTimeout(timerId);\n    }\n    \n    // Clear maps\n    this.refreshTimers.clear();\n    this.refreshing.clear();\n    this.tokens.clear();\n    \n    // Remove all listeners\n    this.removeAllListeners();\n    \n    logger.info('Token Manager destroyed');\n  }\n}\n\n/**\n * Create a token manager for a room\n * @param roomId Room ID\n * @param tokenOptions Token options\n * @param options Additional token manager options\n * @returns A new token manager instance\n */\nexport function createTokenManager(\n  roomId: string,\n  tokenOptions: TokenOptions,\n  options: Partial<Omit<TokenManagerOptions, 'roomId' | 'tokenOptions'>> = {}\n): TokenManager {\n  return new TokenManager({\n    roomId,\n    tokenOptions,\n    ...options\n  });\n}\n\n/**\n * Export default token manager utilities\n */\nexport default {\n  TokenManager,\n  createTokenManager\n};\n",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/tools/analytics-tools/index.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 115,
          "column": 9,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 115,
          "endColumn": 12,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  3144,
                  3147
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  3144,
                  3147
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 117,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 117,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  3196,
                  3199
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  3196,
                  3199
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 2,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Analytics Tools Module\n * \n * This module provides analytics query tools for the Digital Samba MCP Server.\n * These tools allow for complex analytics queries with filters and parameters.\n * \n * @module tools/analytics-tools\n */\n\nimport { Tool } from '@modelcontextprotocol/sdk/types.js';\nimport { DigitalSambaApiClient } from '../../digital-samba-api.js';\nimport { AnalyticsResource, AnalyticsFilters } from '../../analytics.js';\nimport logger from '../../logger.js';\n\n/**\n * Register all analytics tools\n * \n * @returns Array of MCP Tool definitions\n */\nexport function registerAnalyticsTools(): Tool[] {\n  return [\n    {\n      name: 'get-participant-statistics',\n      description: 'Get detailed participant statistics with optional filters',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          participant_id: {\n            type: 'string',\n            description: 'Specific participant ID (optional)'\n          },\n          date_start: {\n            type: 'string',\n            description: 'Start date in YYYY-MM-DD format'\n          },\n          date_end: {\n            type: 'string',\n            description: 'End date in YYYY-MM-DD format'\n          },\n          room_id: {\n            type: 'string',\n            description: 'Filter by room ID'\n          },\n          session_id: {\n            type: 'string',\n            description: 'Filter by session ID'\n          }\n        },\n        required: []\n      }\n    },\n    {\n      name: 'get-room-analytics',\n      description: 'Get comprehensive room analytics with optional filters',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          room_id: {\n            type: 'string',\n            description: 'Specific room ID (optional)'\n          },\n          date_start: {\n            type: 'string',\n            description: 'Start date in YYYY-MM-DD format'\n          },\n          date_end: {\n            type: 'string',\n            description: 'End date in YYYY-MM-DD format'\n          },\n          period: {\n            type: 'string',\n            enum: ['day', 'week', 'month', 'year'],\n            description: 'Analytics period'\n          }\n        },\n        required: []\n      }\n    },\n    {\n      name: 'get-usage-statistics',\n      description: 'Get usage statistics and growth metrics',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          date_start: {\n            type: 'string',\n            description: 'Start date in YYYY-MM-DD format'\n          },\n          date_end: {\n            type: 'string',\n            description: 'End date in YYYY-MM-DD format'\n          },\n          period: {\n            type: 'string',\n            enum: ['day', 'week', 'month', 'year'],\n            description: 'Analytics period'\n          }\n        },\n        required: []\n      }\n    }\n  ];\n}\n\n/**\n * Handle analytics tool execution\n * \n * @param toolName - The name of the tool being executed\n * @param args - The tool arguments\n * @param apiClient - The Digital Samba API client instance\n * @returns The tool execution result\n */\nexport async function executeAnalyticsTool(\n  toolName: string, \n  args: any, \n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const analytics = new AnalyticsResource(apiClient);\n  \n  // Build filters from arguments\n  const filters: AnalyticsFilters = {\n    date_start: args.date_start,\n    date_end: args.date_end,\n    room_id: args.room_id,\n    session_id: args.session_id,\n    participant_id: args.participant_id,\n    period: args.period\n  };\n  \n  // Remove undefined values\n  Object.keys(filters).forEach(key => {\n    if (filters[key as keyof AnalyticsFilters] === undefined) {\n      delete filters[key as keyof AnalyticsFilters];\n    }\n  });\n  \n  switch (toolName) {\n    case 'get-participant-statistics':\n      logger.info('Executing participant statistics query', { args });\n      return await analytics.getParticipantStatistics(args.participant_id, filters);\n      \n    case 'get-room-analytics':\n      logger.info('Executing room analytics query', { args });\n      return await analytics.getRoomAnalytics(args.room_id, filters);\n      \n    case 'get-usage-statistics':\n      logger.info('Executing usage statistics query', { args });\n      return await analytics.getUsageStatistics(filters);\n      \n    default:\n      throw new Error(`Unknown analytics tool: ${toolName}`);\n  }\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/tools/communication-management/index.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'McpServer' is defined but never used.",
          "line": 26,
          "column": 10,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 26,
          "endColumn": 19
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 43,
          "column": 16,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 43,
          "endColumn": 19,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1392,
                  1395
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1392,
                  1395
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 129,
          "column": 11,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 129,
          "endColumn": 14,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  3986,
                  3989
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  3986,
                  3989
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 131,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 131,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  4037,
                  4040
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  4037,
                  4040
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 168,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 168,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  5178,
                  5181
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  5178,
                  5181
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 221,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 221,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  6471,
                  6474
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  6471,
                  6474
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 292,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 292,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  8233,
                  8236
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  8233,
                  8236
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 345,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 345,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  9518,
                  9521
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  9518,
                  9521
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 416,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 416,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  11272,
                  11275
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  11272,
                  11275
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 471,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 471,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  12738,
                  12741
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  12738,
                  12741
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 542,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 542,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  14561,
                  14564
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  14561,
                  14564
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 595,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 595,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  15891,
                  15894
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  15891,
                  15894
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 1,
      "fatalErrorCount": 0,
      "warningCount": 11,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - Communication Management Tools\n * \n * This module implements tools for managing communications within Digital Samba sessions.\n * It provides MCP tools for managing chat messages, Q&A, transcripts, and summaries.\n * \n * Tools provided:\n * - delete-session-chats: Delete all chat messages for a session\n * - delete-room-chats: Delete all chat messages for a room\n * - delete-session-qa: Delete all Q&A for a session\n * - delete-room-qa: Delete all Q&A for a room\n * - delete-session-transcripts: Delete all transcripts for a session\n * - delete-room-transcripts: Delete all transcripts for a room\n * - delete-session-summaries: Delete all summaries for a session\n * - delete-room-summaries: Delete all summaries for a room\n * \n * @module tools/communication-management\n * @author Digital Samba Team\n * @version 1.0.0\n */\n\n// External dependencies\nimport { z } from 'zod';\n\n// MCP SDK imports\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { \n  ErrorCode, \n  McpError\n} from '@modelcontextprotocol/sdk/types.js';\n\n// Local modules\n// import { getApiKeyFromRequest } from '../../auth.js'; // Removed: unused\nimport { DigitalSambaApiClient } from '../../digital-samba-api.js';\nimport logger from '../../logger.js';\n\n/**\n * Tool definition interface\n */\ninterface ToolDefinition {\n  name: string;\n  description: string;\n  inputSchema: any;\n}\n\n/**\n * Register communication management tools with the MCP SDK\n * \n * @returns {ToolDefinition[]} Array of tool definitions\n */\nexport function registerCommunicationTools(): ToolDefinition[] {\n  return [\n    // Chat Management\n    {\n      name: 'delete-session-chats',\n      description: 'Delete all chat messages for a specific session',\n      inputSchema: {\n        sessionId: z.string().describe('The ID of the session to delete chats from'),\n      }\n    },\n    {\n      name: 'delete-room-chats',\n      description: 'Delete all chat messages for all sessions in a room',\n      inputSchema: {\n        roomId: z.string().describe('The ID of the room to delete chats from'),\n      }\n    },\n    \n    // Q&A Management\n    {\n      name: 'delete-session-qa',\n      description: 'Delete all questions and answers for a specific session',\n      inputSchema: {\n        sessionId: z.string().describe('The ID of the session to delete Q&A from'),\n      }\n    },\n    {\n      name: 'delete-room-qa',\n      description: 'Delete all questions and answers for all sessions in a room',\n      inputSchema: {\n        roomId: z.string().describe('The ID of the room to delete Q&A from'),\n      }\n    },\n    \n    // Transcript Management\n    {\n      name: 'delete-session-transcripts',\n      description: 'Delete all transcripts for a specific session',\n      inputSchema: {\n        sessionId: z.string().describe('The ID of the session to delete transcripts from'),\n      }\n    },\n    {\n      name: 'delete-room-transcripts',\n      description: 'Delete all transcripts for all sessions in a room',\n      inputSchema: {\n        roomId: z.string().describe('The ID of the room to delete transcripts from'),\n      }\n    },\n    \n    // Summary Management\n    {\n      name: 'delete-session-summaries',\n      description: 'Delete all AI-generated summaries for a specific session',\n      inputSchema: {\n        sessionId: z.string().describe('The ID of the session to delete summaries from'),\n      }\n    },\n    {\n      name: 'delete-room-summaries',\n      description: 'Delete all AI-generated summaries for all sessions in a room',\n      inputSchema: {\n        roomId: z.string().describe('The ID of the room to delete summaries from'),\n      }\n    }\n  ];\n}\n\n/**\n * Execute a communication management tool\n * \n * @param {string} toolName - Name of the tool to execute\n * @param {any} params - Tool parameters\n * @param {DigitalSambaApiClient} apiClient - API client instance\n * @returns {Promise<any>} Tool execution result\n */\nexport async function executeCommunicationTool(\n  toolName: string,\n  params: any,\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  switch (toolName) {\n    // Chat Management\n    case 'delete-session-chats':\n      return handleDeleteSessionChats(params, apiClient);\n    case 'delete-room-chats':\n      return handleDeleteRoomChats(params, apiClient);\n    \n    // Q&A Management\n    case 'delete-session-qa':\n      return handleDeleteSessionQA(params, apiClient);\n    case 'delete-room-qa':\n      return handleDeleteRoomQA(params, apiClient);\n    \n    // Transcript Management\n    case 'delete-session-transcripts':\n      return handleDeleteSessionTranscripts(params, apiClient);\n    case 'delete-room-transcripts':\n      return handleDeleteRoomTranscripts(params, apiClient);\n    \n    // Summary Management\n    case 'delete-session-summaries':\n      return handleDeleteSessionSummaries(params, apiClient);\n    case 'delete-room-summaries':\n      return handleDeleteRoomSummaries(params, apiClient);\n    \n    default:\n      throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${toolName}`);\n  }\n}\n\n/**\n * Handle delete session chats\n */\nasync function handleDeleteSessionChats(\n  params: { sessionId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { sessionId } = params;\n  \n  if (!sessionId || sessionId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Session ID is required to delete chats.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting session chats', { sessionId });\n  \n  try {\n    await apiClient.deleteSessionChats(sessionId);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted all chat messages for session ${sessionId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting session chats', { \n      sessionId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error deleting session chats: ${errorMessage}`;\n    \n    if (errorMessage.includes('Session not found') || errorMessage.includes('404')) {\n      displayMessage = `Session with ID ${sessionId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle delete room chats\n */\nasync function handleDeleteRoomChats(\n  params: { roomId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { roomId } = params;\n  \n  if (!roomId || roomId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Room ID is required to delete chats.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting room chats', { roomId });\n  \n  try {\n    // Get all sessions for the room\n    const sessionsResponse = await apiClient.listSessions({ room_id: roomId });\n    const sessions = sessionsResponse.data;\n    \n    if (!sessions || sessions.length === 0) {\n      return {\n        content: [{ \n          type: 'text', \n          text: `No sessions found for room ${roomId}`\n        }],\n      };\n    }\n    \n    // Delete chats for each session\n    let deletedCount = 0;\n    for (const session of sessions) {\n      try {\n        await apiClient.deleteSessionChats(session.id);\n        deletedCount++;\n      } catch (error) {\n        logger.warn('Failed to delete chats for session', { \n          sessionId: session.id, \n          error: error instanceof Error ? error.message : String(error) \n        });\n      }\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted chat messages from ${deletedCount} sessions in room ${roomId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting room chats', { \n      roomId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Error deleting room chats: ${error instanceof Error ? error.message : String(error)}`\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle delete session Q&A\n */\nasync function handleDeleteSessionQA(\n  params: { sessionId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { sessionId } = params;\n  \n  if (!sessionId || sessionId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Session ID is required to delete Q&A.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting session Q&A', { sessionId });\n  \n  try {\n    await apiClient.deleteSessionQA(sessionId);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted all questions and answers for session ${sessionId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting session Q&A', { \n      sessionId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error deleting session Q&A: ${errorMessage}`;\n    \n    if (errorMessage.includes('Session not found') || errorMessage.includes('404')) {\n      displayMessage = `Session with ID ${sessionId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle delete room Q&A\n */\nasync function handleDeleteRoomQA(\n  params: { roomId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { roomId } = params;\n  \n  if (!roomId || roomId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Room ID is required to delete Q&A.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting room Q&A', { roomId });\n  \n  try {\n    // Get all sessions for the room\n    const sessionsResponse = await apiClient.listSessions({ room_id: roomId });\n    const sessions = sessionsResponse.data;\n    \n    if (!sessions || sessions.length === 0) {\n      return {\n        content: [{ \n          type: 'text', \n          text: `No sessions found for room ${roomId}`\n        }],\n      };\n    }\n    \n    // Delete Q&A for each session\n    let deletedCount = 0;\n    for (const session of sessions) {\n      try {\n        await apiClient.deleteSessionQA(session.id);\n        deletedCount++;\n      } catch (error) {\n        logger.warn('Failed to delete Q&A for session', { \n          sessionId: session.id, \n          error: error instanceof Error ? error.message : String(error) \n        });\n      }\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted Q&A from ${deletedCount} sessions in room ${roomId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting room Q&A', { \n      roomId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Error deleting room Q&A: ${error instanceof Error ? error.message : String(error)}`\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle delete session transcripts\n */\nasync function handleDeleteSessionTranscripts(\n  params: { sessionId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { sessionId } = params;\n  \n  if (!sessionId || sessionId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Session ID is required to delete transcripts.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting session transcripts', { sessionId });\n  \n  try {\n    // Note: The Digital Samba API might use different endpoints for transcripts\n    // This is a placeholder implementation\n    await apiClient.deleteSessionData(sessionId, 'transcripts');\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted all transcripts for session ${sessionId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting session transcripts', { \n      sessionId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error deleting session transcripts: ${errorMessage}`;\n    \n    if (errorMessage.includes('Session not found') || errorMessage.includes('404')) {\n      displayMessage = `Session with ID ${sessionId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle delete room transcripts\n */\nasync function handleDeleteRoomTranscripts(\n  params: { roomId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { roomId } = params;\n  \n  if (!roomId || roomId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Room ID is required to delete transcripts.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting room transcripts', { roomId });\n  \n  try {\n    // Get all sessions for the room\n    const sessionsResponse = await apiClient.listSessions({ room_id: roomId });\n    const sessions = sessionsResponse.data;\n    \n    if (!sessions || sessions.length === 0) {\n      return {\n        content: [{ \n          type: 'text', \n          text: `No sessions found for room ${roomId}`\n        }],\n      };\n    }\n    \n    // Delete transcripts for each session\n    let deletedCount = 0;\n    for (const session of sessions) {\n      try {\n        await apiClient.deleteSessionData(session.id, 'transcripts');\n        deletedCount++;\n      } catch (error) {\n        logger.warn('Failed to delete transcripts for session', { \n          sessionId: session.id, \n          error: error instanceof Error ? error.message : String(error) \n        });\n      }\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted transcripts from ${deletedCount} sessions in room ${roomId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting room transcripts', { \n      roomId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Error deleting room transcripts: ${error instanceof Error ? error.message : String(error)}`\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle delete session summaries\n */\nasync function handleDeleteSessionSummaries(\n  params: { sessionId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { sessionId } = params;\n  \n  if (!sessionId || sessionId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Session ID is required to delete summaries.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting session summaries', { sessionId });\n  \n  try {\n    await apiClient.deleteSessionSummaries(sessionId);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted all AI-generated summaries for session ${sessionId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting session summaries', { \n      sessionId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error deleting session summaries: ${errorMessage}`;\n    \n    if (errorMessage.includes('Session not found') || errorMessage.includes('404')) {\n      displayMessage = `Session with ID ${sessionId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle delete room summaries\n */\nasync function handleDeleteRoomSummaries(\n  params: { roomId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { roomId } = params;\n  \n  if (!roomId || roomId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Room ID is required to delete summaries.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting room summaries', { roomId });\n  \n  try {\n    // Get all sessions for the room\n    const sessionsResponse = await apiClient.listSessions({ room_id: roomId });\n    const sessions = sessionsResponse.data;\n    \n    if (!sessions || sessions.length === 0) {\n      return {\n        content: [{ \n          type: 'text', \n          text: `No sessions found for room ${roomId}`\n        }],\n      };\n    }\n    \n    // Delete summaries for each session\n    let deletedCount = 0;\n    for (const session of sessions) {\n      try {\n        await apiClient.deleteSessionSummaries(session.id);\n        deletedCount++;\n      } catch (error) {\n        logger.warn('Failed to delete summaries for session', { \n          sessionId: session.id, \n          error: error instanceof Error ? error.message : String(error) \n        });\n      }\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted summaries from ${deletedCount} sessions in room ${roomId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting room summaries', { \n      roomId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Error deleting room summaries: ${error instanceof Error ? error.message : String(error)}`\n      }],\n      isError: true,\n    };\n  }\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/tools/library-management/index.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'McpServer' is defined but never used.",
          "line": 28,
          "column": 10,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 28,
          "endColumn": 19
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 45,
          "column": 16,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 45,
          "endColumn": 19,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1380,
                  1383
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1380,
                  1383
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 179,
          "column": 11,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 179,
          "endColumn": 14,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  5856,
                  5859
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  5856,
                  5859
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 181,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 181,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  5907,
                  5910
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  5907,
                  5910
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 226,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 226,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  7356,
                  7359
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  7356,
                  7359
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 274,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 274,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  8489,
                  8492
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  8489,
                  8492
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 287,
          "column": 18,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 287,
          "endColumn": 21,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  8773,
                  8776
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  8773,
                  8776
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'result' is assigned a value but never used.",
          "line": 304,
          "column": 11,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 304,
          "endColumn": 17
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 341,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 341,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  10172,
                  10175
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  10172,
                  10175
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 394,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 394,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  11460,
                  11463
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  11460,
                  11463
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 410,
          "column": 23,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 410,
          "endColumn": 26,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  11830,
                  11833
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  11830,
                  11833
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 451,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 451,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  13040,
                  13043
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  13040,
                  13043
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 474,
          "column": 18,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 474,
          "endColumn": 21,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  13534,
                  13537
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  13534,
                  13537
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 529,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 529,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  15017,
                  15020
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  15017,
                  15020
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 593,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 593,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  16613,
                  16616
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  16613,
                  16616
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 619,
          "column": 21,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 619,
          "endColumn": 24,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  17153,
                  17156
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  17153,
                  17156
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 664,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 664,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  18557,
                  18560
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  18557,
                  18560
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 687,
          "column": 18,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 687,
          "endColumn": 21,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  19039,
                  19042
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  19039,
                  19042
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 742,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 742,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  20492,
                  20495
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  20492,
                  20495
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 806,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 806,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  22027,
                  22030
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  22027,
                  22030
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 881,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 881,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  23921,
                  23924
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  23921,
                  23924
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 907,
          "column": 23,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 907,
          "endColumn": 26,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  24461,
                  24464
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  24461,
                  24464
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 952,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 952,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  25844,
                  25847
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  25844,
                  25847
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 978,
          "column": 27,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 978,
          "endColumn": 30,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  26400,
                  26403
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  26400,
                  26403
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 2,
      "fatalErrorCount": 0,
      "warningCount": 22,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - Library Management Tools\n * \n * This module implements tools for managing content libraries within Digital Samba.\n * It provides MCP tools for creating, updating, and managing libraries, folders, and files.\n * \n * Tools provided:\n * - create-library: Create a new content library\n * - update-library: Update library details\n * - delete-library: Delete a library\n * - create-library-folder: Create a folder in a library\n * - update-library-folder: Update folder details\n * - delete-library-folder: Delete a folder\n * - create-library-file: Get upload URL for a new file\n * - update-library-file: Update file details\n * - delete-library-file: Delete a file\n * - get-file-links: Get viewing/thumbnail links for a file\n * \n * @module tools/library-management\n * @author Digital Samba Team\n * @version 1.0.0\n */\n\n// External dependencies\nimport { z } from 'zod';\n\n// MCP SDK imports\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { \n  ErrorCode, \n  McpError\n} from '@modelcontextprotocol/sdk/types.js';\n\n// Local modules\n// import { getApiKeyFromRequest } from '../../auth.js'; // Removed: unused\nimport { DigitalSambaApiClient } from '../../digital-samba-api.js';\nimport logger from '../../logger.js';\n\n/**\n * Tool definition interface\n */\ninterface ToolDefinition {\n  name: string;\n  description: string;\n  inputSchema: any;\n}\n\n/**\n * Register library management tools with the MCP SDK\n * \n * @returns {ToolDefinition[]} Array of tool definitions\n */\nexport function registerLibraryTools(): ToolDefinition[] {\n  return [\n    // Library CRUD\n    {\n      name: 'create-library',\n      description: 'Create a new content library',\n      inputSchema: {\n        name: z.string().optional().describe('Name of the library'),\n        externalId: z.string().describe('External identifier for the library'),\n      }\n    },\n    {\n      name: 'update-library',\n      description: 'Update library details',\n      inputSchema: {\n        libraryId: z.string().describe('The ID of the library to update'),\n        name: z.string().optional().describe('Updated name of the library'),\n        externalId: z.string().optional().describe('Updated external identifier'),\n      }\n    },\n    {\n      name: 'delete-library',\n      description: 'Delete a content library',\n      inputSchema: {\n        libraryId: z.string().describe('The ID of the library to delete'),\n      }\n    },\n    \n    // Folder Management\n    {\n      name: 'create-library-folder',\n      description: 'Create a new folder in a library',\n      inputSchema: {\n        libraryId: z.string().describe('The ID of the library'),\n        name: z.string().optional().describe('Name of the folder'),\n        parentId: z.string().optional().describe('Parent folder ID (for nested folders)'),\n      }\n    },\n    {\n      name: 'update-library-folder',\n      description: 'Update folder details',\n      inputSchema: {\n        libraryId: z.string().describe('The ID of the library'),\n        folderId: z.string().describe('The ID of the folder to update'),\n        name: z.string().optional().describe('Updated name of the folder'),\n        parentId: z.string().optional().describe('Updated parent folder ID'),\n      }\n    },\n    {\n      name: 'delete-library-folder',\n      description: 'Delete a folder from a library',\n      inputSchema: {\n        libraryId: z.string().describe('The ID of the library'),\n        folderId: z.string().describe('The ID of the folder to delete'),\n      }\n    },\n    \n    // File Management\n    {\n      name: 'create-library-file',\n      description: 'Create a new file entry and get upload URL',\n      inputSchema: {\n        libraryId: z.string().describe('The ID of the library'),\n        name: z.string().describe('Name of the file'),\n        folderId: z.string().optional().describe('Folder ID to place the file in'),\n      }\n    },\n    {\n      name: 'update-library-file',\n      description: 'Update file details',\n      inputSchema: {\n        libraryId: z.string().describe('The ID of the library'),\n        fileId: z.string().describe('The ID of the file to update'),\n        name: z.string().optional().describe('Updated name of the file'),\n        folderId: z.string().optional().describe('Updated folder ID'),\n      }\n    },\n    {\n      name: 'delete-library-file',\n      description: 'Delete a file from a library',\n      inputSchema: {\n        libraryId: z.string().describe('The ID of the library'),\n        fileId: z.string().describe('The ID of the file to delete'),\n      }\n    },\n    {\n      name: 'get-file-links',\n      description: 'Get viewing and thumbnail links for a file',\n      inputSchema: {\n        libraryId: z.string().describe('The ID of the library'),\n        fileId: z.string().describe('The ID of the file'),\n      }\n    },\n    \n    // Webapp and Whiteboard Creation\n    {\n      name: 'create-webapp',\n      description: 'Create a new webapp in a library',\n      inputSchema: {\n        libraryId: z.string().describe('The ID of the library'),\n        name: z.string().describe('Name of the webapp'),\n        folderId: z.string().optional().describe('Folder ID to place the webapp in'),\n      }\n    },\n    {\n      name: 'create-whiteboard',\n      description: 'Create a new whiteboard in a library',\n      inputSchema: {\n        libraryId: z.string().describe('The ID of the library'),\n        name: z.string().describe('Name of the whiteboard'),\n        folderId: z.string().optional().describe('Folder ID to place the whiteboard in'),\n      }\n    }\n  ];\n}\n\n/**\n * Execute a library management tool\n * \n * @param {string} toolName - Name of the tool to execute\n * @param {any} params - Tool parameters\n * @param {DigitalSambaApiClient} apiClient - API client instance\n * @returns {Promise<any>} Tool execution result\n */\nexport async function executeLibraryTool(\n  toolName: string,\n  params: any,\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  switch (toolName) {\n    // Library CRUD\n    case 'create-library':\n      return handleCreateLibrary(params, apiClient);\n    case 'update-library':\n      return handleUpdateLibrary(params, apiClient);\n    case 'delete-library':\n      return handleDeleteLibrary(params, apiClient);\n    \n    // Folder Management\n    case 'create-library-folder':\n      return handleCreateLibraryFolder(params, apiClient);\n    case 'update-library-folder':\n      return handleUpdateLibraryFolder(params, apiClient);\n    case 'delete-library-folder':\n      return handleDeleteLibraryFolder(params, apiClient);\n    \n    // File Management\n    case 'create-library-file':\n      return handleCreateLibraryFile(params, apiClient);\n    case 'update-library-file':\n      return handleUpdateLibraryFile(params, apiClient);\n    case 'delete-library-file':\n      return handleDeleteLibraryFile(params, apiClient);\n    case 'get-file-links':\n      return handleGetFileLinks(params, apiClient);\n    \n    // Webapp and Whiteboard Creation\n    case 'create-webapp':\n      return handleCreateWebapp(params, apiClient);\n    case 'create-whiteboard':\n      return handleCreateWhiteboard(params, apiClient);\n    \n    default:\n      throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${toolName}`);\n  }\n}\n\n/**\n * Handle create library\n */\nasync function handleCreateLibrary(\n  params: { name?: string; externalId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { name, externalId } = params;\n  \n  if (!externalId || externalId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'External ID is required to create a library.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Creating library', { name, externalId });\n  \n  try {\n    const result = await apiClient.createLibrary({\n      name,\n      external_id: externalId\n    });\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully created library \"${result.name || externalId}\" with ID: ${result.id}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error creating library', { \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Error creating library: ${error instanceof Error ? error.message : String(error)}`\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle update library\n */\nasync function handleUpdateLibrary(\n  params: { libraryId: string; name?: string; externalId?: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { libraryId, name, externalId } = params;\n  \n  if (!libraryId || libraryId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Library ID is required to update a library.'\n      }],\n      isError: true,\n    };\n  }\n  \n  const updates: any = {};\n  if (name !== undefined) updates.name = name;\n  if (externalId !== undefined) updates.external_id = externalId;\n  \n  if (Object.keys(updates).length === 0) {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'No updates provided for the library.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Updating library', { libraryId, updates });\n  \n  try {\n    const result = await apiClient.updateLibrary(libraryId, updates);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully updated library ${libraryId}. Updated fields: ${Object.keys(updates).join(', ')}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error updating library', { \n      libraryId,\n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error updating library: ${errorMessage}`;\n    \n    if (errorMessage.includes('404') || errorMessage.includes('not found')) {\n      displayMessage = `Library with ID ${libraryId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle delete library\n */\nasync function handleDeleteLibrary(\n  params: { libraryId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { libraryId } = params;\n  \n  if (!libraryId || libraryId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Library ID is required to delete a library.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting library', { libraryId });\n  \n  try {\n    await apiClient.deleteLibrary(libraryId);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted library ${libraryId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting library', { \n      libraryId,\n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error deleting library: ${errorMessage}`;\n    \n    if (errorMessage.includes('404') || errorMessage.includes('not found')) {\n      displayMessage = `Library with ID ${libraryId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle create library folder\n */\nasync function handleCreateLibraryFolder(\n  params: { libraryId: string; name?: string; parentId?: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { libraryId, name, parentId } = params;\n  \n  if (!libraryId || libraryId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Library ID is required to create a folder.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Creating library folder', { libraryId, name, parentId });\n  \n  try {\n    const folderData: any = {};\n    if (name !== undefined) folderData.name = name;\n    if (parentId !== undefined) folderData.parent_id = parentId;\n    \n    const result = await apiClient.createLibraryFolder(libraryId, folderData);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully created folder in library ${libraryId}. Folder ID: ${result.id}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error creating library folder', { \n      libraryId,\n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error creating folder: ${errorMessage}`;\n    \n    if (errorMessage.includes('404') || errorMessage.includes('Library not found')) {\n      displayMessage = `Library with ID ${libraryId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle update library folder\n */\nasync function handleUpdateLibraryFolder(\n  params: { libraryId: string; folderId: string; name?: string; parentId?: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { libraryId, folderId, name, parentId } = params;\n  \n  if (!libraryId || libraryId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Library ID is required to update a folder.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!folderId || folderId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Folder ID is required to update a folder.'\n      }],\n      isError: true,\n    };\n  }\n  \n  const updates: any = {};\n  if (name !== undefined) updates.name = name;\n  if (parentId !== undefined) updates.parent_id = parentId;\n  \n  if (Object.keys(updates).length === 0) {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'No updates provided for the folder.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Updating library folder', { libraryId, folderId, updates });\n  \n  try {\n    await apiClient.updateLibraryFolder(libraryId, folderId, updates);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully updated folder ${folderId}. Updated fields: ${Object.keys(updates).join(', ')}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error updating library folder', { \n      libraryId,\n      folderId,\n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error updating folder: ${errorMessage}`;\n    \n    if (errorMessage.includes('404') || errorMessage.includes('not found')) {\n      displayMessage = `Folder with ID ${folderId} not found in library ${libraryId}`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle delete library folder\n */\nasync function handleDeleteLibraryFolder(\n  params: { libraryId: string; folderId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { libraryId, folderId } = params;\n  \n  if (!libraryId || libraryId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Library ID is required to delete a folder.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!folderId || folderId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Folder ID is required to delete a folder.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting library folder', { libraryId, folderId });\n  \n  try {\n    await apiClient.deleteLibraryFolder(libraryId, folderId);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted folder ${folderId} from library ${libraryId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting library folder', { \n      libraryId,\n      folderId,\n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error deleting folder: ${errorMessage}`;\n    \n    if (errorMessage.includes('404') || errorMessage.includes('not found')) {\n      displayMessage = `Folder with ID ${folderId} not found in library ${libraryId}`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle create library file\n */\nasync function handleCreateLibraryFile(\n  params: { libraryId: string; name: string; folderId?: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { libraryId, name, folderId } = params;\n  \n  if (!libraryId || libraryId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Library ID is required to create a file.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!name || name.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'File name is required.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Creating library file', { libraryId, name, folderId });\n  \n  try {\n    const fileData: any = { name };\n    if (folderId !== undefined) fileData.folder_id = folderId;\n    \n    const result = await apiClient.createLibraryFile(libraryId, fileData);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully created file \"${name}\" in library ${libraryId}.\\n` +\n              `File ID: ${result.file_id}\\n` +\n              `Upload URL: ${result.external_storage_url}\\n` +\n              `Upload Token: ${result.token}\\n` +\n              `Token expires at: ${new Date(result.expiration_timestamp * 1000).toISOString()}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error creating library file', { \n      libraryId,\n      name,\n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error creating file: ${errorMessage}`;\n    \n    if (errorMessage.includes('404') || errorMessage.includes('Library not found')) {\n      displayMessage = `Library with ID ${libraryId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle update library file\n */\nasync function handleUpdateLibraryFile(\n  params: { libraryId: string; fileId: string; name?: string; folderId?: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { libraryId, fileId, name, folderId } = params;\n  \n  if (!libraryId || libraryId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Library ID is required to update a file.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!fileId || fileId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'File ID is required to update a file.'\n      }],\n      isError: true,\n    };\n  }\n  \n  const updates: any = {};\n  if (name !== undefined) updates.name = name;\n  if (folderId !== undefined) updates.folder_id = folderId;\n  \n  if (Object.keys(updates).length === 0) {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'No updates provided for the file.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Updating library file', { libraryId, fileId, updates });\n  \n  try {\n    await apiClient.updateLibraryFile(libraryId, fileId, updates);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully updated file ${fileId}. Updated fields: ${Object.keys(updates).join(', ')}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error updating library file', { \n      libraryId,\n      fileId,\n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error updating file: ${errorMessage}`;\n    \n    if (errorMessage.includes('404') || errorMessage.includes('not found')) {\n      displayMessage = `File with ID ${fileId} not found in library ${libraryId}`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle delete library file\n */\nasync function handleDeleteLibraryFile(\n  params: { libraryId: string; fileId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { libraryId, fileId } = params;\n  \n  if (!libraryId || libraryId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Library ID is required to delete a file.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!fileId || fileId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'File ID is required to delete a file.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting library file', { libraryId, fileId });\n  \n  try {\n    await apiClient.deleteLibraryFile(libraryId, fileId);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted file ${fileId} from library ${libraryId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting library file', { \n      libraryId,\n      fileId,\n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error deleting file: ${errorMessage}`;\n    \n    if (errorMessage.includes('404') || errorMessage.includes('not found')) {\n      displayMessage = `File with ID ${fileId} not found in library ${libraryId}`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle get file links\n */\nasync function handleGetFileLinks(\n  params: { libraryId: string; fileId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { libraryId, fileId } = params;\n  \n  if (!libraryId || libraryId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Library ID is required to get file links.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!fileId || fileId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'File ID is required to get file links.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Getting file links', { libraryId, fileId });\n  \n  try {\n    const result = await apiClient.getFileLinks(libraryId, fileId);\n    \n    let message = `File links for ${fileId}:\\n`;\n    if (result.pages && result.pages.length > 0) {\n      result.pages.forEach((page, index) => {\n        message += `\\nPage ${index + 1}:\\n`;\n        message += `  View URL: ${page.url}\\n`;\n        message += `  Thumbnail URL: ${page.thumbnail_url}`;\n      });\n    } else {\n      message += 'No pages available for this file.';\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: message\n      }],\n    };\n  } catch (error) {\n    logger.error('Error getting file links', { \n      libraryId,\n      fileId,\n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error getting file links: ${errorMessage}`;\n    \n    if (errorMessage.includes('404') || errorMessage.includes('not found')) {\n      displayMessage = `File with ID ${fileId} not found in library ${libraryId}`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle create webapp\n */\nasync function handleCreateWebapp(\n  params: { libraryId: string; name: string; folderId?: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { libraryId, name, folderId } = params;\n  \n  if (!libraryId || libraryId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Library ID is required to create a webapp.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!name || name.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Webapp name is required.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Creating webapp', { libraryId, name, folderId });\n  \n  try {\n    const webappData: any = { name };\n    if (folderId !== undefined) webappData.folder_id = folderId;\n    \n    const result = await apiClient.createWebapp(libraryId, webappData);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully created webapp \"${name}\" in library ${libraryId}.\\n` +\n              `Webapp ID: ${result.file_id}\\n` +\n              `Upload URL: ${result.external_storage_url}\\n` +\n              `Upload Token: ${result.token}\\n` +\n              `Token expires at: ${new Date(result.expiration_timestamp * 1000).toISOString()}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error creating webapp', { \n      libraryId,\n      name,\n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error creating webapp: ${errorMessage}`;\n    \n    if (errorMessage.includes('404') || errorMessage.includes('Library not found')) {\n      displayMessage = `Library with ID ${libraryId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle create whiteboard\n */\nasync function handleCreateWhiteboard(\n  params: { libraryId: string; name: string; folderId?: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { libraryId, name, folderId } = params;\n  \n  if (!libraryId || libraryId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Library ID is required to create a whiteboard.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!name || name.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Whiteboard name is required.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Creating whiteboard', { libraryId, name, folderId });\n  \n  try {\n    const whiteboardData: any = { name };\n    if (folderId !== undefined) whiteboardData.folder_id = folderId;\n    \n    const result = await apiClient.createWhiteboard(libraryId, whiteboardData);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully created whiteboard \"${name}\" in library ${libraryId}.\\n` +\n              `Whiteboard ID: ${result.file_id}\\n` +\n              `Upload URL: ${result.external_storage_url}\\n` +\n              `Upload Token: ${result.token}\\n` +\n              `Token expires at: ${new Date(result.expiration_timestamp * 1000).toISOString()}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error creating whiteboard', { \n      libraryId,\n      name,\n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error creating whiteboard: ${errorMessage}`;\n    \n    if (errorMessage.includes('404') || errorMessage.includes('Library not found')) {\n      displayMessage = `Library with ID ${libraryId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/tools/live-session-controls/index.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 43,
          "column": 16,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 43,
          "endColumn": 19,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1317,
                  1320
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1317,
                  1320
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 108,
          "column": 11,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 108,
          "endColumn": 14,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  3628,
                  3631
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  3628,
                  3631
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 110,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 110,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  3680,
                  3683
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  3680,
                  3683
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 131,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 131,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  4351,
                  4354
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  4351,
                  4354
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 193,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 193,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  6201,
                  6204
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  6201,
                  6204
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 254,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 254,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  7824,
                  7827
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  7824,
                  7827
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 327,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 327,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  9643,
                  9646
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  9643,
                  9646
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 7,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - Live Session Control Tools\n * \n * This module implements tools for real-time control of live Digital Samba sessions.\n * It provides MCP tools for managing active sessions including transcription and\n * phone participant integration.\n * \n * Tools provided:\n * - start-transcription: Start transcription for a session\n * - stop-transcription: Stop transcription for a session\n * - phone-participants-joined: Register phone participants joining\n * - phone-participants-left: Register phone participants leaving\n * \n * Note: Recording controls (start/stop) are in the recording-management module\n * Note: Session termination (end-session) is in the session-management module\n * \n * @module tools/live-session-controls\n * @author Digital Samba Team\n * @version 1.0.0\n */\n\n// External dependencies\nimport { z } from 'zod';\n\n// MCP SDK imports\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { \n  ErrorCode, \n  McpError\n} from '@modelcontextprotocol/sdk/types.js';\n\n// Local modules\nimport { getApiKeyFromRequest } from '../../auth.js';\nimport { DigitalSambaApiClient } from '../../digital-samba-api.js';\nimport logger from '../../logger.js';\n\n/**\n * Tool definition interface\n */\ninterface ToolDefinition {\n  name: string;\n  description: string;\n  inputSchema: any;\n}\n\n/**\n * Register live session control tools with the MCP SDK\n * \n * This function returns an array of tool definitions that can be registered\n * with the MCP server. It follows the modular pattern where tools are defined\n * here and registered in the main index.ts file.\n * \n * @returns {ToolDefinition[]} Array of tool definitions\n */\nexport function registerLiveSessionTools(): ToolDefinition[] {\n  return [\n    {\n      name: 'start-transcription',\n      description: 'Start transcription for a live session in a room',\n      inputSchema: {\n        roomId: z.string().describe('The ID of the room to start transcription for'),\n      }\n    },\n    {\n      name: 'stop-transcription',\n      description: 'Stop transcription for a live session in a room',\n      inputSchema: {\n        roomId: z.string().describe('The ID of the room to stop transcription for'),\n      }\n    },\n    {\n      name: 'phone-participants-joined',\n      description: 'Register phone participants joining a room',\n      inputSchema: {\n        roomId: z.string().describe('The ID of the room'),\n        participants: z.array(z.object({\n          call_id: z.string().describe('Unique identifier for the phone call'),\n          name: z.string().optional().describe('Name of the participant'),\n          caller_number: z.string().optional().describe('Phone number of the participant'),\n          external_id: z.string().optional().describe('External identifier for the participant')\n        })).describe('Array of phone participants joining')\n      }\n    },\n    {\n      name: 'phone-participants-left',\n      description: 'Register phone participants leaving a room',\n      inputSchema: {\n        roomId: z.string().describe('The ID of the room'),\n        callIds: z.array(z.string()).describe('Array of call IDs for participants leaving')\n      }\n    }\n  ];\n}\n\n/**\n * Execute a live session control tool\n * \n * This function handles the execution of live session control tools.\n * It's called by the main server when a tool is invoked.\n * \n * @param {string} toolName - Name of the tool to execute\n * @param {any} params - Tool parameters\n * @param {DigitalSambaApiClient} apiClient - API client instance\n * @returns {Promise<any>} Tool execution result\n */\nexport async function executeLiveSessionTool(\n  toolName: string,\n  params: any,\n  _apiClient: DigitalSambaApiClient\n): Promise<any> {\n  switch (toolName) {\n    case 'start-transcription':\n      return handleStartTranscription(params, _apiClient);\n    case 'stop-transcription':\n      return handleStopTranscription(params, _apiClient);\n    case 'phone-participants-joined':\n      return handlePhoneParticipantsJoined(params, _apiClient);\n    case 'phone-participants-left':\n      return handlePhoneParticipantsLeft(params, _apiClient);\n    default:\n      throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${toolName}`);\n  }\n}\n\n/**\n * Handle start transcription tool\n */\nasync function handleStartTranscription(\n  params: { roomId: string },\n  _apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { roomId } = params;\n  \n  if (!roomId || roomId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Room ID is required to start transcription.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Starting transcription', { roomId });\n  \n  try {\n    // Note: The Digital Samba API might not have direct transcription endpoints yet\n    // This is a placeholder implementation that would need to be updated when the API is available\n    // For now, we'll simulate the expected behavior\n    \n    // In a real implementation, this would be:\n    // await apiClient.startTranscription(roomId);\n    \n    logger.warn('Transcription API endpoint not yet available in Digital Samba API');\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Transcription start requested for room ${roomId}. Note: This feature is pending Digital Samba API support.`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error starting transcription', { \n      roomId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error starting transcription: ${errorMessage}`;\n    \n    if (errorMessage.includes('Room not found') || errorMessage.includes('404')) {\n      displayMessage = `Room with ID ${roomId} not found`;\n    } else if (errorMessage.includes('Already transcribing')) {\n      displayMessage = `Transcription already in progress for room ${roomId}`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle stop transcription tool\n */\nasync function handleStopTranscription(\n  params: { roomId: string },\n  _apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { roomId } = params;\n  \n  if (!roomId || roomId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Room ID is required to stop transcription.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Stopping transcription', { roomId });\n  \n  try {\n    // Note: The Digital Samba API might not have direct transcription endpoints yet\n    // This is a placeholder implementation that would need to be updated when the API is available\n    // For now, we'll simulate the expected behavior\n    \n    // In a real implementation, this would be:\n    // await apiClient.stopTranscription(roomId);\n    \n    logger.warn('Transcription API endpoint not yet available in Digital Samba API');\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Transcription stop requested for room ${roomId}. Note: This feature is pending Digital Samba API support.`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error stopping transcription', { \n      roomId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Error stopping transcription: ${error instanceof Error ? error.message : String(error)}`\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle phone participants joined tool\n */\nasync function handlePhoneParticipantsJoined(\n  params: { \n    roomId: string;\n    participants: Array<{\n      call_id: string;\n      name?: string;\n      caller_number?: string;\n      external_id?: string;\n    }>;\n  },\n  _apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { roomId, participants } = params;\n  \n  if (!roomId || roomId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Room ID is required for phone participants.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!participants || participants.length === 0) {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'At least one participant is required.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Registering phone participants joined', { \n    roomId, \n    participantCount: participants.length \n  });\n  \n  try {\n    await _apiClient.phoneParticipantsJoined(roomId, participants);\n    \n    const participantNames = participants\n      .map(p => p.name || p.caller_number || p.call_id)\n      .join(', ');\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully registered ${participants.length} phone participant(s) joining room ${roomId}: ${participantNames}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error registering phone participants joined', { \n      roomId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error registering phone participants: ${errorMessage}`;\n    \n    if (errorMessage.includes('Room not found') || errorMessage.includes('404')) {\n      displayMessage = `Room with ID ${roomId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle phone participants left tool\n */\nasync function handlePhoneParticipantsLeft(\n  params: { \n    roomId: string;\n    callIds: string[];\n  },\n  _apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { roomId, callIds } = params;\n  \n  if (!roomId || roomId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Room ID is required for phone participants.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!callIds || callIds.length === 0) {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'At least one call ID is required.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Registering phone participants left', { \n    roomId, \n    callIdCount: callIds.length \n  });\n  \n  try {\n    await _apiClient.phoneParticipantsLeft(roomId, callIds);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully registered ${callIds.length} phone participant(s) leaving room ${roomId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error registering phone participants left', { \n      roomId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error registering phone participants leaving: ${errorMessage}`;\n    \n    if (errorMessage.includes('Room not found') || errorMessage.includes('404')) {\n      displayMessage = `Room with ID ${roomId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Set up live session control tools for the MCP server (legacy function)\n * \n * This function is kept for backward compatibility but delegates to the\n * modular registration system.\n * \n * @deprecated Use registerLiveSessionTools() and executeLiveSessionTool() instead\n * @param {McpServer} server - The MCP server instance\n * @param {string} apiUrl - Base URL for the Digital Samba API\n */\nexport function setupLiveSessionTools(server: McpServer, apiUrl: string): void {\n  logger.info('Setting up live session control tools');\n  \n  const tools = registerLiveSessionTools();\n  \n  tools.forEach(tool => {\n    server.tool(\n      tool.name,\n      tool.inputSchema,\n      async (params, request) => {\n        const apiKey = getApiKeyFromRequest(request);\n        if (!apiKey) {\n          return {\n            content: [{ \n              type: 'text', \n              text: 'No API key found. Please include an Authorization header with a Bearer token.'\n            }],\n            isError: true,\n          };\n        }\n        \n        const apiClient = new DigitalSambaApiClient(apiKey, apiUrl);\n        return executeLiveSessionTool(tool.name, params, apiClient);\n      }\n    );\n  });\n  \n  logger.info('Live session control tools set up successfully');\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/tools/poll-management/index.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'McpServer' is defined but never used.",
          "line": 24,
          "column": 10,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 24,
          "endColumn": 19
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 41,
          "column": 16,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 41,
          "endColumn": 19,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1201,
                  1204
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1201,
                  1204
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 128,
          "column": 11,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 128,
          "endColumn": 14,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  4366,
                  4369
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  4366,
                  4369
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 130,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 130,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  4417,
                  4420
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  4417,
                  4420
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 162,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 162,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  5341,
                  5344
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  5341,
                  5344
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 251,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 251,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  7444,
                  7447
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  7444,
                  7447
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 290,
          "column": 26,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 290,
          "endColumn": 29,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  8332,
                  8335
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  8332,
                  8335
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 335,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 335,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  9553,
                  9556
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  9553,
                  9556
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 398,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 398,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  10982,
                  10985
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  10982,
                  10985
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 451,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 451,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  12267,
                  12270
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  12267,
                  12270
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 522,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 522,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  14059,
                  14062
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  14059,
                  14062
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 1,
      "fatalErrorCount": 0,
      "warningCount": 10,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - Poll Management Tools\n * \n * This module implements tools for managing polls within Digital Samba sessions.\n * It provides MCP tools for creating, updating, deleting, and managing poll results.\n * \n * Tools provided:\n * - create-poll: Create a new poll in a session\n * - update-poll: Update an existing poll\n * - delete-poll: Delete a specific poll\n * - delete-session-polls: Delete all polls for a session\n * - delete-room-polls: Delete all polls for all sessions in a room\n * - publish-poll-results: Publish poll results to participants\n * \n * @module tools/poll-management\n * @author Digital Samba Team\n * @version 1.0.0\n */\n\n// External dependencies\nimport { z } from 'zod';\n\n// MCP SDK imports\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { \n  ErrorCode, \n  McpError\n} from '@modelcontextprotocol/sdk/types.js';\n\n// Local modules\n// import { getApiKeyFromRequest } from '../../auth.js'; // Removed: unused\nimport { DigitalSambaApiClient } from '../../digital-samba-api.js';\nimport logger from '../../logger.js';\n\n/**\n * Tool definition interface\n */\ninterface ToolDefinition {\n  name: string;\n  description: string;\n  inputSchema: any;\n}\n\n/**\n * Poll option schema\n */\nconst pollOptionSchema = z.object({\n  text: z.string().describe('The text of the poll option'),\n  id: z.string().optional().describe('Optional ID for the option'),\n});\n\n/**\n * Register poll management tools with the MCP SDK\n * \n * @returns {ToolDefinition[]} Array of tool definitions\n */\nexport function registerPollTools(): ToolDefinition[] {\n  return [\n    {\n      name: 'create-poll',\n      description: 'Create a new poll in a room',\n      inputSchema: {\n        roomId: z.string().describe('The ID of the room to create the poll in'),\n        question: z.string().describe('The poll question'),\n        options: z.array(pollOptionSchema).min(2).describe('Array of poll options (minimum 2)'),\n        type: z.enum(['single', 'multiple']).optional().describe('Poll type: single choice or multiple choice'),\n        anonymous: z.boolean().optional().describe('Whether the poll is anonymous'),\n        showResults: z.boolean().optional().describe('Whether to show results to participants'),\n      }\n    },\n    {\n      name: 'update-poll',\n      description: 'Update an existing poll',\n      inputSchema: {\n        roomId: z.string().describe('The ID of the room containing the poll'),\n        pollId: z.string().describe('The ID of the poll to update'),\n        question: z.string().optional().describe('Updated poll question'),\n        options: z.array(pollOptionSchema).optional().describe('Updated poll options'),\n        type: z.enum(['single', 'multiple']).optional().describe('Updated poll type'),\n        anonymous: z.boolean().optional().describe('Updated anonymous setting'),\n        showResults: z.boolean().optional().describe('Updated show results setting'),\n      }\n    },\n    {\n      name: 'delete-poll',\n      description: 'Delete a specific poll',\n      inputSchema: {\n        roomId: z.string().describe('The ID of the room containing the poll'),\n        pollId: z.string().describe('The ID of the poll to delete'),\n      }\n    },\n    {\n      name: 'delete-session-polls',\n      description: 'Delete all polls for a specific session',\n      inputSchema: {\n        sessionId: z.string().describe('The ID of the session to delete polls from'),\n      }\n    },\n    {\n      name: 'delete-room-polls',\n      description: 'Delete all polls for all sessions in a room',\n      inputSchema: {\n        roomId: z.string().describe('The ID of the room to delete polls from'),\n      }\n    },\n    {\n      name: 'publish-poll-results',\n      description: 'Publish poll results to participants',\n      inputSchema: {\n        roomId: z.string().describe('The ID of the room containing the poll'),\n        pollId: z.string().describe('The ID of the poll to publish results for'),\n        sessionId: z.string().optional().describe('The ID of the specific session (optional)'),\n      }\n    }\n  ];\n}\n\n/**\n * Execute a poll management tool\n * \n * @param {string} toolName - Name of the tool to execute\n * @param {any} params - Tool parameters\n * @param {DigitalSambaApiClient} apiClient - API client instance\n * @returns {Promise<any>} Tool execution result\n */\nexport async function executePollTool(\n  toolName: string,\n  params: any,\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  switch (toolName) {\n    case 'create-poll':\n      return handleCreatePoll(params, apiClient);\n    case 'update-poll':\n      return handleUpdatePoll(params, apiClient);\n    case 'delete-poll':\n      return handleDeletePoll(params, apiClient);\n    case 'delete-session-polls':\n      return handleDeleteSessionPolls(params, apiClient);\n    case 'delete-room-polls':\n      return handleDeleteRoomPolls(params, apiClient);\n    case 'publish-poll-results':\n      return handlePublishPollResults(params, apiClient);\n    default:\n      throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${toolName}`);\n  }\n}\n\n/**\n * Handle create poll\n */\nasync function handleCreatePoll(\n  params: {\n    roomId: string;\n    question: string;\n    options: Array<{ text: string; id?: string }>;\n    type?: 'single' | 'multiple';\n    anonymous?: boolean;\n    showResults?: boolean;\n  },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { roomId, question, options, type = 'single', anonymous = false, showResults = true } = params;\n  \n  if (!roomId || roomId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Room ID is required to create a poll.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!question || question.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Poll question is required.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!options || options.length < 2) {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'At least 2 poll options are required.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Creating poll', { roomId, question, optionCount: options.length });\n  \n  try {\n    const pollData = {\n      question,\n      options,\n      type,\n      anonymous,\n      show_results: showResults,\n    };\n    \n    const result = await apiClient.createPoll(roomId, pollData);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully created poll \"${question}\" with ${options.length} options in room ${roomId}. Poll ID: ${result.id}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error creating poll', { \n      roomId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error creating poll: ${errorMessage}`;\n    \n    if (errorMessage.includes('Room not found') || errorMessage.includes('404')) {\n      displayMessage = `Room with ID ${roomId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle update poll\n */\nasync function handleUpdatePoll(\n  params: {\n    roomId: string;\n    pollId: string;\n    question?: string;\n    options?: Array<{ text: string; id?: string }>;\n    type?: 'single' | 'multiple';\n    anonymous?: boolean;\n    showResults?: boolean;\n  },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { roomId, pollId, ...updateData } = params;\n  \n  if (!roomId || roomId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Room ID is required to update a poll.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!pollId || pollId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Poll ID is required to update a poll.'\n      }],\n      isError: true,\n    };\n  }\n  \n  // Check if there's anything to update\n  const hasUpdates = Object.keys(updateData).length > 0;\n  if (!hasUpdates) {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'No updates provided for the poll.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Updating poll', { pollId, updates: Object.keys(updateData) });\n  \n  try {\n    // Transform showResults to show_results for API\n    const apiUpdateData: any = { ...updateData };\n    if ('showResults' in apiUpdateData) {\n      apiUpdateData.show_results = apiUpdateData.showResults;\n      delete apiUpdateData.showResults;\n    }\n    \n    await apiClient.updatePoll(roomId, pollId, apiUpdateData);\n    \n    const updateSummary = Object.keys(updateData).join(', ');\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully updated poll ${pollId}. Updated fields: ${updateSummary}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error updating poll', { \n      pollId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error updating poll: ${errorMessage}`;\n    \n    if (errorMessage.includes('Poll not found') || errorMessage.includes('404')) {\n      displayMessage = `Poll with ID ${pollId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle delete poll\n */\nasync function handleDeletePoll(\n  params: { roomId: string; pollId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { roomId, pollId } = params;\n  \n  if (!roomId || roomId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Room ID is required to delete a poll.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!pollId || pollId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Poll ID is required to delete a poll.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting poll', { roomId, pollId });\n  \n  try {\n    await apiClient.deletePoll(roomId, pollId);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted poll ${pollId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting poll', { \n      pollId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error deleting poll: ${errorMessage}`;\n    \n    if (errorMessage.includes('Poll not found') || errorMessage.includes('404')) {\n      displayMessage = `Poll with ID ${pollId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle delete session polls\n */\nasync function handleDeleteSessionPolls(\n  params: { sessionId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { sessionId } = params;\n  \n  if (!sessionId || sessionId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Session ID is required to delete polls.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting session polls', { sessionId });\n  \n  try {\n    await apiClient.deleteSessionPolls(sessionId);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted all polls for session ${sessionId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting session polls', { \n      sessionId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error deleting session polls: ${errorMessage}`;\n    \n    if (errorMessage.includes('Session not found') || errorMessage.includes('404')) {\n      displayMessage = `Session with ID ${sessionId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle delete room polls\n */\nasync function handleDeleteRoomPolls(\n  params: { roomId: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { roomId } = params;\n  \n  if (!roomId || roomId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Room ID is required to delete polls.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Deleting room polls', { roomId });\n  \n  try {\n    // Get all sessions for the room\n    const sessionsResponse = await apiClient.listSessions({ room_id: roomId });\n    const sessions = sessionsResponse.data;\n    \n    if (!sessions || sessions.length === 0) {\n      return {\n        content: [{ \n          type: 'text', \n          text: `No sessions found for room ${roomId}`\n        }],\n      };\n    }\n    \n    // Delete polls for each session\n    let deletedCount = 0;\n    for (const session of sessions) {\n      try {\n        await apiClient.deleteSessionPolls(session.id);\n        deletedCount++;\n      } catch (error) {\n        logger.warn('Failed to delete polls for session', { \n          sessionId: session.id, \n          error: error instanceof Error ? error.message : String(error) \n        });\n      }\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully deleted polls from ${deletedCount} sessions in room ${roomId}`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error deleting room polls', { \n      roomId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Error deleting room polls: ${error instanceof Error ? error.message : String(error)}`\n      }],\n      isError: true,\n    };\n  }\n}\n\n/**\n * Handle publish poll results\n */\nasync function handlePublishPollResults(\n  params: { roomId: string; pollId: string; sessionId?: string },\n  apiClient: DigitalSambaApiClient\n): Promise<any> {\n  const { roomId, pollId, sessionId } = params;\n  \n  if (!roomId || roomId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Room ID is required to publish results.'\n      }],\n      isError: true,\n    };\n  }\n  \n  if (!pollId || pollId.trim() === '') {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'Poll ID is required to publish results.'\n      }],\n      isError: true,\n    };\n  }\n  \n  logger.info('Publishing poll results', { roomId, pollId, sessionId });\n  \n  try {\n    // The API method expects sessionId as a required parameter\n    // If not provided, we'll need to get the current session or return an error\n    if (!sessionId) {\n      return {\n        content: [{ \n          type: 'text', \n          text: 'Session ID is required to publish poll results. Please provide the session ID.'\n        }],\n        isError: true,\n      };\n    }\n    \n    await apiClient.publishPollResults(pollId, sessionId);\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: `Successfully published results for poll ${pollId} in room ${roomId} (session ${sessionId})`\n      }],\n    };\n  } catch (error) {\n    logger.error('Error publishing poll results', { \n      roomId,\n      pollId, \n      sessionId, \n      error: error instanceof Error ? error.message : String(error) \n    });\n    \n    const errorMessage = error instanceof Error ? error.message : String(error);\n    let displayMessage = `Error publishing poll results: ${errorMessage}`;\n    \n    if (errorMessage.includes('Poll not found') || errorMessage.includes('404')) {\n      displayMessage = `Poll with ID ${pollId} not found`;\n    } else if (errorMessage.includes('Session not found')) {\n      displayMessage = `Session with ID ${sessionId} not found`;\n    } else if (errorMessage.includes('Room not found')) {\n      displayMessage = `Room with ID ${roomId} not found`;\n    }\n    \n    return {\n      content: [{ \n        type: 'text', \n        text: displayMessage\n      }],\n      isError: true,\n    };\n  }\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/tools/recording-management/index.ts",
      "messages": [],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/tools/room-management/index.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 161,
          "column": 9,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 161,
          "endColumn": 12,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  4275,
                  4278
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  4275,
                  4278
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 162,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 162,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  4291,
                  4294
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  4291,
                  4294
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 165,
          "column": 16,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 165,
          "endColumn": 19,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  4344,
                  4347
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  4344,
                  4347
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 171,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 171,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  4518,
                  4521
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  4518,
                  4521
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 4,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Room Management Tools Module\n * \n * This module provides room management tools for the Digital Samba MCP Server.\n * It implements tools for creating, updating, deleting rooms and generating tokens.\n * \n * @module tools/room-management\n */\n\nimport { Tool } from '@modelcontextprotocol/sdk/types.js';\n// import { z } from 'zod'; // Removed: unused\nimport { DigitalSambaApiClient } from '../../digital-samba-api.js';\nimport { EnhancedDigitalSambaApiClient } from '../../digital-samba-api-enhanced.js';\nimport { getApiKeyFromRequest } from '../../auth.js';\nimport logger from '../../logger.js';\n\n/**\n * Register all room management tools\n * \n * @returns Array of MCP Tool definitions\n */\nexport function registerRoomTools(): Tool[] {\n  return [\n    {\n      name: 'create-room',\n      description: 'Create a new room with specified settings',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          name: {\n            type: 'string',\n            minLength: 3,\n            maxLength: 100,\n            description: 'Room name'\n          },\n          description: {\n            type: 'string',\n            maxLength: 500,\n            description: 'Room description'\n          },\n          friendly_url: {\n            type: 'string',\n            minLength: 3,\n            maxLength: 32,\n            description: 'Friendly URL for the room'\n          },\n          privacy: {\n            type: 'string',\n            enum: ['public', 'private'],\n            default: 'public',\n            description: 'Room privacy setting'\n          },\n          max_participants: {\n            type: 'number',\n            minimum: 2,\n            maximum: 2000,\n            description: 'Maximum number of participants'\n          }\n        },\n        required: []\n      }\n    },\n    {\n      name: 'update-room',\n      description: 'Update an existing room',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          roomId: {\n            type: 'string',\n            description: 'Room ID (required)'\n          },\n          name: {\n            type: 'string',\n            minLength: 3,\n            maxLength: 100,\n            description: 'Room name'\n          },\n          description: {\n            type: 'string',\n            maxLength: 500,\n            description: 'Room description'\n          },\n          friendly_url: {\n            type: 'string',\n            minLength: 3,\n            maxLength: 32,\n            description: 'Friendly URL for the room'\n          },\n          privacy: {\n            type: 'string',\n            enum: ['public', 'private'],\n            description: 'Room privacy setting'\n          },\n          max_participants: {\n            type: 'number',\n            minimum: 2,\n            maximum: 2000,\n            description: 'Maximum number of participants'\n          }\n        },\n        required: ['roomId']\n      }\n    },\n    {\n      name: 'delete-room',\n      description: 'Delete a room',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          roomId: {\n            type: 'string',\n            description: 'Room ID (required)'\n          }\n        },\n        required: ['roomId']\n      }\n    },\n    {\n      name: 'generate-token',\n      description: 'Generate an access token for a room',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          roomId: {\n            type: 'string',\n            description: 'Room ID (required)'\n          },\n          userName: {\n            type: 'string',\n            minLength: 1,\n            maxLength: 100,\n            description: 'User name for the token'\n          },\n          role: {\n            type: 'string',\n            description: 'User role (e.g., moderator, participant)'\n          },\n          externalId: {\n            type: 'string',\n            description: 'External user ID'\n          }\n        },\n        required: ['roomId']\n      }\n    }\n  ];\n}\n\n/**\n * Execute a room management tool\n * \n * @param toolName - The name of the tool to execute\n * @param args - The tool arguments\n * @param request - The MCP request object for authentication\n * @param options - Server options including API configuration\n * @returns The tool execution result\n */\nexport async function executeRoomTool(\n  toolName: string,\n  args: any,\n  request: any,\n  options: {\n    apiUrl: string;\n    apiCache?: any;\n    enableConnectionManagement?: boolean;\n    enableTokenManagement?: boolean;\n    enableResourceOptimization?: boolean;\n    connectionPoolSize?: number;\n  }\n): Promise<any> {\n  const { apiUrl, apiCache, enableConnectionManagement, enableTokenManagement, enableResourceOptimization, connectionPoolSize } = options;\n  \n  // Get API key from session context\n  const apiKey = getApiKeyFromRequest(request);\n  if (!apiKey) {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'No API key found. Please include an Authorization header with a Bearer token.'\n      }],\n      isError: true,\n    };\n  }\n\n  // Create API client with the provided key\n  logger.debug('Creating API client with key', { \n    apiKeyLength: apiKey ? apiKey.length : 0,\n    apiUrl\n  });\n  \n  let client: DigitalSambaApiClient | EnhancedDigitalSambaApiClient;\n  if (enableConnectionManagement || enableTokenManagement || enableResourceOptimization) {\n    // Use enhanced API client\n    logger.debug('Using enhanced API client with additional features enabled');\n    client = new EnhancedDigitalSambaApiClient(\n      apiKey,\n      apiUrl,\n      apiCache,\n      {\n        enableConnectionManagement,\n        enableTokenManagement,\n        enableResourceOptimization,\n        connectionPoolSize\n      }\n    );\n  } else {\n    // Use standard API client\n    client = new DigitalSambaApiClient(apiKey, apiUrl, apiCache);\n  }\n\n  switch (toolName) {\n    case 'create-room': {\n      const { name, description, friendly_url, privacy, max_participants } = args;\n      \n      logger.info('Creating room', { \n        roomName: name, \n        privacy\n      });\n      \n      try {\n        // Create room settings object\n        const roomSettings = {\n          name: name || 'Test Room',  // Ensure we have a name\n          description,\n          friendly_url,\n          privacy: privacy || 'public',\n          max_participants,\n        };\n        \n        // Create room\n        const room = await client.createRoom(roomSettings);\n        logger.info('Room created successfully', { roomId: room.id });\n        \n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Room created successfully!\\n\\n${JSON.stringify(room, null, 2)}`,\n            },\n          ],\n        };\n      } catch (error) {\n        logger.error('Error creating room', { \n          error: error instanceof Error ? error.message : String(error) \n        });\n        \n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error creating room: ${error instanceof Error ? error.message : String(error)}`,\n            },\n          ],\n          isError: true,\n        };\n      }\n    }\n\n    case 'update-room': {\n      const { roomId, name, description, friendly_url, privacy, max_participants } = args;\n      \n      if (!roomId) {\n        return {\n          content: [{ type: 'text', text: 'Room ID is required.' }],\n          isError: true,\n        };\n      }\n      \n      logger.info('Updating room', { \n        roomId, \n        name, \n        privacy\n      });\n      \n      try {\n        // Create room settings object\n        const roomSettings = {\n          name,\n          description,\n          friendly_url,\n          privacy,\n          max_participants,\n        };\n        \n        // Update room\n        const room = await client.updateRoom(roomId, roomSettings);\n        logger.info('Room updated successfully', { roomId: room.id });\n        \n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Room updated successfully!\\n\\n${JSON.stringify(room, null, 2)}`,\n            },\n          ],\n        };\n      } catch (error) {\n        logger.error('Error updating room', { \n          roomId,\n          error: error instanceof Error ? error.message : String(error) \n        });\n        \n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error updating room: ${error instanceof Error ? error.message : String(error)}`,\n            },\n          ],\n          isError: true,\n        };\n      }\n    }\n\n    case 'delete-room': {\n      const { roomId } = args;\n      \n      if (!roomId) {\n        return {\n          content: [{ type: 'text', text: 'Room ID is required.' }],\n          isError: true,\n        };\n      }\n      \n      logger.info('Deleting room', { roomId });\n      \n      try {\n        // Delete room\n        await client.deleteRoom(roomId);\n        logger.info('Room deleted successfully', { roomId });\n        \n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Room ${roomId} deleted successfully!`,\n            },\n          ],\n        };\n      } catch (error) {\n        logger.error('Error deleting room', { \n          roomId,\n          error: error instanceof Error ? error.message : String(error) \n        });\n        \n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error deleting room: ${error instanceof Error ? error.message : String(error)}`,\n            },\n          ],\n          isError: true,\n        };\n      }\n    }\n\n    case 'generate-token': {\n      const { roomId, userName, role, externalId } = args;\n      \n      logger.info('Generating room token', { \n        roomId, \n        userName, \n        role\n      });\n      \n      try {\n        // Generate token options\n        const tokenOptions = {\n          u: userName || undefined,\n          role: role || undefined,\n          ud: externalId || undefined,\n        };\n        \n        // Generate token - use token refresh if enabled\n        let token;\n        if (enableTokenManagement && client instanceof EnhancedDigitalSambaApiClient && request.sessionId) {\n          // Use token refresh\n          token = await client.generateRoomTokenWithRefresh(roomId, tokenOptions, request.sessionId);\n          logger.info('Generated token with auto-refresh', { roomId, expiresAt: token.expiresAt });\n        } else {\n          // Standard token generation\n          token = await client.generateRoomToken(roomId, tokenOptions);  \n        }\n        logger.info('Token generated successfully', { roomId });\n        \n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Token generated successfully!\\n\\n${JSON.stringify(token, null, 2)}`,\n            },\n          ],\n        };\n      } catch (error) {\n        logger.error('Error generating token', { \n          roomId, \n          error: error instanceof Error ? error.message : String(error) \n        });\n        \n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error generating token: ${error instanceof Error ? error.message : String(error)}`,\n            },\n          ],\n          isError: true,\n        };\n      }\n    }\n\n    default:\n      throw new Error(`Unknown room tool: ${toolName}`);\n  }\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/tools/session-management/index.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 163,
          "column": 9,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 163,
          "endColumn": 12,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  4437,
                  4440
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  4437,
                  4440
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 165,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 165,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  4489,
                  4492
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  4489,
                  4492
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 166,
          "column": 12,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 166,
          "endColumn": 15,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  4504,
                  4507
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  4504,
                  4507
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 3,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Session Management Tools Module\n * \n * This module provides comprehensive session management tools for the Digital Samba MCP Server.\n * It implements session-related tools for managing room sessions, deleting session data,\n * and performing session operations.\n * \n * @module tools/session-management\n */\n\nimport { Tool } from '@modelcontextprotocol/sdk/types.js';\n// import { z } from 'zod'; // Removed: unused\nimport { DigitalSambaApiClient } from '../../digital-samba-api.js';\nimport { getApiKeyFromRequest } from '../../auth.js';\nimport logger from '../../logger.js';\n\n/**\n * Register all session management tools\n * \n * @returns Array of MCP Tool definitions\n */\nexport function registerSessionTools(): Tool[] {\n  return [\n    {\n      name: 'get-all-room-sessions',\n      description: 'Get all sessions for a specific room with optional filters',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          roomId: {\n            type: 'string',\n            description: 'Room ID (required)'\n          },\n          limit: {\n            type: 'number',\n            minimum: 1,\n            maximum: 1000,\n            description: 'Number of results to return'\n          },\n          offset: {\n            type: 'number',\n            minimum: 0,\n            description: 'Number of results to skip'\n          },\n          order: {\n            type: 'string',\n            enum: ['asc', 'desc'],\n            description: 'Sort order'\n          },\n          dateStart: {\n            type: 'string',\n            description: 'Start date in YYYY-MM-DD format'\n          },\n          dateEnd: {\n            type: 'string',\n            description: 'End date in YYYY-MM-DD format'\n          },\n          live: {\n            type: 'boolean',\n            description: 'Filter for live sessions only'\n          }\n        },\n        required: ['roomId']\n      }\n    },\n    {\n      name: 'hard-delete-session-resources',\n      description: 'Permanently delete all stored resource data for a session',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          sessionId: {\n            type: 'string',\n            description: 'Session ID (required)'\n          }\n        },\n        required: ['sessionId']\n      }\n    },\n    {\n      name: 'bulk-delete-session-data',\n      description: 'Delete multiple types of session data in a single operation',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          sessionId: {\n            type: 'string',\n            description: 'Session ID (required)'\n          },\n          dataTypes: {\n            type: 'array',\n            items: {\n              type: 'string',\n              enum: ['chat', 'questions', 'summaries', 'transcripts', 'polls', 'recordings', 'resources']\n            },\n            minItems: 1,\n            description: 'Types of data to delete'\n          }\n        },\n        required: ['sessionId', 'dataTypes']\n      }\n    },\n    {\n      name: 'get-session-summary',\n      description: 'Get a comprehensive summary of a session',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          sessionId: {\n            type: 'string',\n            description: 'Session ID (required)'\n          }\n        },\n        required: ['sessionId']\n      }\n    },\n    {\n      name: 'end-session',\n      description: 'End a live session',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          sessionId: {\n            type: 'string',\n            description: 'Session ID (required)'\n          }\n        },\n        required: ['sessionId']\n      }\n    },\n    {\n      name: 'get-session-statistics',\n      description: 'Get detailed statistics for a session',\n      inputSchema: {\n        type: 'object',\n        properties: {\n          sessionId: {\n            type: 'string',\n            description: 'Session ID (required)'\n          },\n          metrics: {\n            type: 'string',\n            description: 'Specific metrics to retrieve (optional)'\n          }\n        },\n        required: ['sessionId']\n      }\n    }\n  ];\n}\n\n/**\n * Execute a session management tool\n * \n * @param toolName - The name of the tool to execute\n * @param args - The tool arguments\n * @param apiClient - The Digital Samba API client instance\n * @param request - The MCP request object for authentication\n * @returns The tool execution result\n */\nexport async function executeSessionTool(\n  toolName: string,\n  args: any,\n  apiClient: DigitalSambaApiClient,\n  request: any\n): Promise<any> {\n  const apiKey = getApiKeyFromRequest(request);\n  if (!apiKey) {\n    return {\n      content: [{ \n        type: 'text', \n        text: 'No API key found. Please include an Authorization header with a Bearer token.'\n      }],\n      isError: true,\n    };\n  }\n\n  switch (toolName) {\n    case 'get-all-room-sessions': {\n      logger.info('Getting all room sessions', { roomId: args.roomId, limit: args.limit, offset: args.offset });\n      \n      try {\n        const sessionParams = {\n          limit: args.limit,\n          offset: args.offset,\n          order: args.order,\n          date_start: args.dateStart,\n          date_end: args.dateEnd,\n          live: args.live\n        };\n        \n        const sessions = await apiClient.listRoomSessions(args.roomId, sessionParams);\n        \n        return {\n          content: [{\n            type: 'text',\n            text: JSON.stringify({\n              sessions: sessions.data,\n              total_count: sessions.total_count,\n              pagination: {\n                limit: args.limit || 50,\n                offset: args.offset || 0,\n                total: sessions.total_count\n              }\n            }, null, 2),\n          }],\n        };\n      } catch (error) {\n        logger.error('Error getting room sessions', { \n          roomId: args.roomId,\n          error: error instanceof Error ? error.message : String(error) \n        });\n        \n        return {\n          content: [{\n            type: 'text',\n            text: `Error getting room sessions: ${error instanceof Error ? error.message : String(error)}`,\n          }],\n          isError: true,\n        };\n      }\n    }\n\n    case 'hard-delete-session-resources': {\n      logger.info('Hard deleting all session resources', { sessionId: args.sessionId });\n      \n      try {\n        await apiClient.deleteSessionData(args.sessionId, 'resources');\n        \n        return {\n          content: [{\n            type: 'text',\n            text: `Successfully hard deleted all stored resource data for session ${args.sessionId}`,\n          }],\n        };\n      } catch (error) {\n        logger.error('Error hard deleting session resources', { \n          sessionId: args.sessionId,\n          error: error instanceof Error ? error.message : String(error) \n        });\n        \n        return {\n          content: [{\n            type: 'text',\n            text: `Error hard deleting session resources: ${error instanceof Error ? error.message : String(error)}`,\n          }],\n          isError: true,\n        };\n      }\n    }\n\n    case 'bulk-delete-session-data': {\n      logger.info('Bulk deleting session data', { sessionId: args.sessionId, dataTypes: args.dataTypes });\n      \n      try {\n        const results = [];\n        const errors = [];\n        \n        // Delete each data type\n        for (const dataType of args.dataTypes) {\n          try {\n            await apiClient.deleteSessionData(args.sessionId, dataType);\n            results.push(` Successfully deleted ${dataType}`);\n            logger.info(`Deleted session ${dataType}`, { sessionId: args.sessionId, dataType });\n          } catch (error) {\n            const errorMsg = ` Failed to delete ${dataType}: ${error instanceof Error ? error.message : String(error)}`;\n            errors.push(errorMsg);\n            logger.error(`Failed to delete session ${dataType}`, { \n              sessionId: args.sessionId, \n              dataType, \n              error: error instanceof Error ? error.message : String(error) \n            });\n          }\n        }\n        \n        const summary = {\n          sessionId: args.sessionId,\n          requested: args.dataTypes,\n          results: results,\n          errors: errors,\n          success: errors.length === 0\n        };\n        \n        return {\n          content: [{\n            type: 'text',\n            text: JSON.stringify(summary, null, 2),\n          }],\n          isError: errors.length > 0,\n        };\n      } catch (error) {\n        logger.error('Error in bulk delete session data', { \n          sessionId: args.sessionId,\n          dataTypes: args.dataTypes,\n          error: error instanceof Error ? error.message : String(error) \n        });\n        \n        return {\n          content: [{\n            type: 'text',\n            text: `Error in bulk delete operation: ${error instanceof Error ? error.message : String(error)}`,\n          }],\n          isError: true,\n        };\n      }\n    }\n\n    case 'get-session-summary': {\n      logger.info('Getting session summary', { sessionId: args.sessionId });\n      \n      try {\n        const summary = await apiClient.getSessionSummary(args.sessionId);\n        \n        return {\n          content: [{\n            type: 'text',\n            text: JSON.stringify(summary, null, 2),\n          }],\n        };\n      } catch (error) {\n        logger.error('Error getting session summary', { \n          sessionId: args.sessionId,\n          error: error instanceof Error ? error.message : String(error) \n        });\n        \n        return {\n          content: [{\n            type: 'text',\n            text: `Error getting session summary: ${error instanceof Error ? error.message : String(error)}`,\n          }],\n          isError: true,\n        };\n      }\n    }\n\n    case 'end-session': {\n      logger.info('Ending session', { sessionId: args.sessionId });\n      \n      try {\n        await apiClient.endSession(args.sessionId);\n        \n        return {\n          content: [{\n            type: 'text',\n            text: `Successfully ended session ${args.sessionId}`,\n          }],\n        };\n      } catch (error) {\n        logger.error('Error ending session', { \n          sessionId: args.sessionId,\n          error: error instanceof Error ? error.message : String(error) \n        });\n        \n        return {\n          content: [{\n            type: 'text',\n            text: `Error ending session: ${error instanceof Error ? error.message : String(error)}`,\n          }],\n          isError: true,\n        };\n      }\n    }\n\n    case 'get-session-statistics': {\n      logger.info('Getting session statistics', { sessionId: args.sessionId, metrics: args.metrics });\n      \n      try {\n        const statistics = await apiClient.getSessionStatistics(args.sessionId, args.metrics);\n        \n        return {\n          content: [{\n            type: 'text',\n            text: JSON.stringify(statistics, null, 2),\n          }],\n        };\n      } catch (error) {\n        logger.error('Error getting session statistics', { \n          sessionId: args.sessionId,\n          error: error instanceof Error ? error.message : String(error) \n        });\n        \n        return {\n          content: [{\n            type: 'text',\n            text: `Error getting session statistics: ${error instanceof Error ? error.message : String(error)}`,\n          }],\n          isError: true,\n        };\n      }\n    }\n\n    default:\n      throw new Error(`Unknown session tool: ${toolName}`);\n  }\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/tools/webhook-management/index.ts",
      "messages": [],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/transports/http-transport.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 57,
          "column": 82,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 57,
          "endColumn": 85,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  2147,
                  2150
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  2147,
                  2150
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 89,
          "column": 77,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 89,
          "endColumn": 80,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  3144,
                  3147
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  3144,
                  3147
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 2,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - HTTP Transport\n * \n * This module provides the HTTP transport implementation for the Digital Samba MCP Server.\n * It's designed for web applications, API integrations, and scenarios where full server\n * features like webhooks, metrics, and health checks are needed.\n * \n * @module http-transport\n * @author Digital Samba Team\n * @version 1.0.0\n */\n\nimport { createServer, startServer, ServerOptions } from '../index.js';\nimport logger from '../logger.js';\n\n/**\n * Configuration options specific to HTTP transport\n */\nexport interface HttpTransportOptions extends Partial<ServerOptions> {\n  /** Port to run the HTTP server on */\n  port?: number;\n  /** Enable all advanced features by default for HTTP mode */\n  enableAdvancedFeatures?: boolean;\n}\n\n/**\n * Default configuration for HTTP transport\n * \n * HTTP mode enables all advanced features since it's designed for\n * production web environments where these features are valuable.\n */\nconst DEFAULT_HTTP_OPTIONS: Partial<ServerOptions> = {\n  enableSilentMode: false,\n  enableConnectionManagement: true,    // Enable for production stability\n  enableTokenManagement: true,         // Enable for token refresh\n  enableResourceOptimization: true,    // Enable for performance\n  enableCircuitBreaker: true,          // Enable for resilience\n  enableGracefulDegradation: true,     // Enable for fault tolerance\n  enableMetrics: true,                 // Enable for monitoring\n  enableCache: true,                   // Enable for performance\n  cacheTtl: 300000,                    // 5 minutes\n  enableRateLimiting: true,            // Enable for protection\n  rateLimitRequestsPerMinute: 60,      // Reasonable default\n  logLevel: 'info',\n  port: 4521\n};\n\n/**\n * Run the Digital Samba MCP Server with HTTP transport\n * \n * This function sets up the server optimized for HTTP communication,\n * with full features enabled for production web environments.\n * \n * @param options - Configuration options for the HTTP transport\n * @returns Promise that resolves to the HTTP server instance\n */\nexport async function runHttpServer(options: HttpTransportOptions = {}): Promise<any> {\n  const {\n    enableAdvancedFeatures = true,\n    ...serverOptions\n  } = options;\n\n  logger.info('Starting Digital Samba MCP Server (HTTP mode)', {\n    port: options.port || DEFAULT_HTTP_OPTIONS.port,\n    enableAdvancedFeatures\n  });\n\n  // Merge HTTP-specific options with provided options\n  const mergedOptions: Partial<ServerOptions> = enableAdvancedFeatures \n    ? { ...DEFAULT_HTTP_OPTIONS, ...serverOptions }\n    : { ...serverOptions };\n\n  // Use the main startServer function which handles HTTP transport\n  const httpServer = startServer(mergedOptions);\n  \n  logger.info('HTTP server started successfully');\n  return httpServer;\n}\n\n/**\n * Create HTTP server configuration without starting it\n * \n * This is useful for testing or when you need to customize the server\n * setup before starting it.\n * \n * @param options - Configuration options for the HTTP transport\n * @returns Server configuration object\n */\nexport function createHttpServerConfig(options: HttpTransportOptions = {}): any {\n  const {\n    enableAdvancedFeatures = true,\n    ...serverOptions\n  } = options;\n\n  // Merge HTTP-specific options with provided options\n  const mergedOptions: Partial<ServerOptions> = enableAdvancedFeatures \n    ? { ...DEFAULT_HTTP_OPTIONS, ...serverOptions }\n    : { ...serverOptions };\n\n  return createServer(mergedOptions);\n}\n\n/**\n * Validate HTTP transport configuration\n */\nexport function validateHttpConfig(options: HttpTransportOptions): void {\n  if (options.port && (options.port < 1 || options.port > 65535)) {\n    throw new Error('Port must be between 1 and 65535');\n  }\n  \n  if (options.rateLimitRequestsPerMinute && options.rateLimitRequestsPerMinute < 1) {\n    throw new Error('Rate limit must be at least 1 request per minute');\n  }\n  \n  logger.debug('HTTP transport configuration validated');\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/transports/stdio-transport.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'_originalConsole' is assigned a value but never used.",
          "line": 106,
          "column": 9,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 106,
          "endColumn": 25
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 114,
          "column": 27,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 114,
          "endColumn": 30,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  3647,
                  3650
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  3647,
                  3650
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 115,
          "column": 28,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 115,
          "endColumn": 31,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  3735,
                  3738
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  3735,
                  3738
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 116,
          "column": 28,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 116,
          "endColumn": 31,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  3824,
                  3827
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  3824,
                  3827
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 117,
          "column": 29,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 117,
          "endColumn": 32,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  3914,
                  3917
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  3914,
                  3917
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 1,
      "fatalErrorCount": 0,
      "warningCount": 4,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - STDIO Transport\n * \n * This module provides the STDIO transport implementation for the Digital Samba MCP Server.\n * It's specifically designed for Claude Desktop integration and other applications that\n * communicate via standard input/output using the JSON-RPC protocol.\n * \n * @module stdio-transport\n * @author Digital Samba Team\n * @version 1.0.0\n */\n\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport { createServer, ServerOptions } from '../index.js';\nimport logger from '../logger.js';\n\n/**\n * Configuration options specific to STDIO transport\n */\nexport interface StdioTransportOptions {\n  /** API key for Digital Samba API (required for STDIO mode) */\n  apiKey: string;\n  /** Base URL for Digital Samba API */\n  apiUrl?: string;\n  /** Additional server options */\n  serverOptions?: Partial<ServerOptions>;\n}\n\n/**\n * Default configuration for STDIO transport\n * \n * STDIO mode prioritizes fast startup and minimal overhead, so we disable\n * advanced features that are more suited for long-running HTTP servers.\n */\nconst DEFAULT_STDIO_OPTIONS: Partial<ServerOptions> = {\n  enableSilentMode: true,\n  enableConnectionManagement: false,  // Disable for faster startup\n  enableTokenManagement: false,       // Disable for faster startup  \n  enableResourceOptimization: false,  // Disable for faster startup\n  enableCircuitBreaker: false,        // HTTP-focused feature\n  enableGracefulDegradation: false,   // HTTP-focused feature\n  enableMetrics: false,               // HTTP-focused feature\n  enableCache: true,                  // Keep for performance\n  cacheTtl: 300000,                   // 5 minutes\n  logLevel: 'info'\n};\n\n/**\n * Run the Digital Samba MCP Server with STDIO transport\n * \n * This function sets up the server optimized for STDIO communication,\n * typically used by Claude Desktop and other MCP clients.\n * \n * @param options - Configuration options for the STDIO transport\n * @returns Promise that resolves when the server is connected\n */\nexport async function runStdioServer(options: StdioTransportOptions): Promise<void> {\n  const {\n    apiKey,\n    apiUrl = 'https://api.digitalsamba.com/api/v1',\n    serverOptions = {}\n  } = options;\n\n  // Redirect console output to stderr to avoid interfering with JSON-RPC\n  setupConsoleRedirection();\n\n  logger.info('Starting Digital Samba MCP Server (STDIO mode)', {\n    apiUrl,\n    hasApiKey: !!apiKey\n  });\n\n  // Merge STDIO-specific options with provided options\n  const mergedOptions: Partial<ServerOptions> = {\n    ...DEFAULT_STDIO_OPTIONS,\n    ...serverOptions,\n    apiKey,\n    apiUrl\n  };\n\n  // Create server using the main createServer function\n  const serverConfig = createServer(mergedOptions);\n  const { server } = serverConfig;\n\n  // Create STDIO transport\n  const transport = new StdioServerTransport();\n  \n  // Connect server to transport\n  try {\n    await server.connect(transport);\n    logger.info('MCP server connected successfully via STDIO transport');\n  } catch (error) {\n    logger.error('Failed to connect STDIO transport', { \n      error: error instanceof Error ? error.message : String(error) \n    });\n    throw error;\n  }\n}\n\n/**\n * Set up console redirection for STDIO mode\n * \n * In STDIO mode, stdout is used for JSON-RPC communication, so all\n * console output must be redirected to stderr to avoid protocol conflicts.\n */\nfunction setupConsoleRedirection(): void {\n  const _originalConsole = {\n    log: console.log,\n    info: console.info,\n    warn: console.warn,\n    debug: console.debug\n  };\n\n  // Redirect all console output to stderr with prefixes\n  console.log = (...args: any[]) => process.stderr.write(`[LOG] ${args.join(' ')}\\n`);\n  console.info = (...args: any[]) => process.stderr.write(`[INFO] ${args.join(' ')}\\n`);\n  console.warn = (...args: any[]) => process.stderr.write(`[WARN] ${args.join(' ')}\\n`);\n  console.debug = (...args: any[]) => process.stderr.write(`[DEBUG] ${args.join(' ')}\\n`);\n  \n  // Keep console.error as it already goes to stderr\n  // console.error is not modified\n}\n\n/**\n * Validate STDIO transport configuration\n */\nexport function validateStdioConfig(options: StdioTransportOptions): void {\n  if (!options.apiKey) {\n    throw new Error('API key is required for STDIO transport');\n  }\n  \n  if (!options.apiUrl) {\n    throw new Error('API URL is required for STDIO transport');\n  }\n  \n  logger.debug('STDIO transport configuration validated');\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/webhooks.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'WebhookEventType' is defined but never used.",
          "line": 23,
          "column": 3,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 23,
          "endColumn": 19
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'WebhookPayload' is defined but never used.",
          "line": 24,
          "column": 3,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 24,
          "endColumn": 17
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'WebhookConfig' is defined but never used.",
          "line": 25,
          "column": 3,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 25,
          "endColumn": 16
        },
        {
          "ruleId": "@typescript-eslint/no-unused-vars",
          "severity": 2,
          "message": "'WebhookEventHandler' is defined but never used.",
          "line": 26,
          "column": 3,
          "nodeType": null,
          "messageId": "unusedVar",
          "endLine": 26,
          "endColumn": 22
        }
      ],
      "suppressedMessages": [],
      "errorCount": 4,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - Webhook Functionality (Modular)\n * \n * This module implements webhook functionality for the Digital Samba MCP Server.\n * It provides capabilities for webhook registration, management, and event handling\n * through the MCP interface, exposing the Digital Samba webhook API to MCP clients.\n * \n * This is a consolidated entry point that imports from the new modular structure:\n * - Core Service: src/webhooks/webhook-service.ts\n * - Types: src/webhooks/webhook-types.ts\n * - Tools: src/tools/webhook-management/\n * \n * @module webhooks\n * @author Digital Samba Team\n * @version 1.0.0\n */\n\n// MCP SDK imports\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\n\n// Local modules - modular structure\nimport {\n  WebhookEventType,\n  WebhookPayload,\n  WebhookConfig,\n  WebhookEventHandler\n} from './webhooks/webhook-types.js';\n\nimport { WebhookService } from './webhooks/webhook-service.js';\nimport { setupWebhookManagementTools } from './tools/webhook-management/index.js';\nimport logger from './logger.js';\n\n// Re-export types and service for backward compatibility\nexport { WebhookEventType } from './webhooks/webhook-types.js';\nexport type { WebhookPayload, WebhookConfig, WebhookEventHandler } from './webhooks/webhook-types.js';\nexport { WebhookService } from './webhooks/webhook-service.js';\n\n/**\n * Set up webhook tools for the MCP server\n * \n * This function registers all webhook-related tools with the MCP server.\n * It delegates to the modular webhook management tools setup function.\n * \n * @param {McpServer} server - The MCP server instance\n * @param {WebhookService} webhookService - The webhook service instance\n * @param {string} apiBaseUrl - Base URL for the Digital Samba API\n * @returns {void}\n * \n * @example\n * // Register webhook tools with the MCP server\n * const webhookService = new WebhookService(mcpServer, { endpoint: '/webhooks' });\n * setupWebhookTools(mcpServer, webhookService, 'https://api.digitalsamba.com/api/v1');\n */\nexport function setupWebhookTools(\n  server: McpServer, \n  webhookService: WebhookService,\n  apiBaseUrl: string\n): void {\n  logger.info('Setting up webhook tools with modular structure');\n  \n  // Delegate to the modular webhook management tools\n  setupWebhookManagementTools(server, webhookService, apiBaseUrl);\n  \n  logger.info('Webhook tools set up successfully');\n}\n\n// Export default for backward compatibility\nexport default WebhookService;",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/webhooks/index.ts",
      "messages": [],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 0,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/webhooks/webhook-service.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 324,
          "column": 42,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 324,
          "endColumn": 45,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  10842,
                  10845
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  10842,
                  10845
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 385,
          "column": 64,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 385,
          "endColumn": 67,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  13177,
                  13180
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  13177,
                  13180
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 551,
          "column": 42,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 551,
          "endColumn": 45,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  18324,
                  18327
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  18324,
                  18327
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        },
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 657,
          "column": 42,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 657,
          "endColumn": 45,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  21984,
                  21987
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  21984,
                  21987
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 4,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - Webhook Service\n * \n * This module implements the core webhook service for handling Digital Samba\n * webhook events. It provides functionality for receiving, processing, and\n * propagating webhook events from the Digital Samba API to MCP clients.\n * \n * @module webhooks/webhook-service\n * @author Digital Samba Team\n * @version 1.0.0\n */\n\n// Node.js built-in modules\nimport crypto from 'crypto';\n\n// External dependencies\nimport express, { Request, Response } from 'express';\n\n// MCP SDK imports\nimport { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\n\n// Local modules\n// import { getApiKeyFromRequest } from '../auth.js'; // Removed: unused\nimport { DigitalSambaApiClient } from '../digital-samba-api.js';\nimport {\n  ApiRequestError,\n  ApiResponseError,\n  AuthenticationError,\n  ConfigurationError,\n  ResourceNotFoundError,\n  ValidationError\n} from '../errors.js';\nimport logger from '../logger.js';\n\n// Import webhook types\nimport {\n  WebhookEventType,\n  WebhookPayload,\n  WebhookConfig,\n  WebhookEventHandler\n} from './webhook-types.js';\n\n/**\n * Webhook service for handling Digital Samba events\n * \n * This class provides the core functionality for receiving, processing, and\n * propagating webhook events from the Digital Samba API. It manages event\n * handlers, signature verification, and client notifications.\n * \n * @class\n * @example\n * const webhookService = new WebhookService(mcpServer, {\n *   secret: process.env.WEBHOOK_SECRET,\n *   endpoint: '/webhooks/digitalsamba'\n * });\n * \n * // Register an event handler\n * webhookService.on(WebhookEventType.RECORDING_READY, async (payload) => {\n *   logger.info('Recording is ready:', payload.data.id);\n * });\n * \n * // Register the webhook endpoint with Express\n * webhookService.registerWebhookEndpoint(app);\n */\nexport class WebhookService {\n  private server: McpServer;\n  private config: WebhookConfig;\n  private eventHandlers: Map<WebhookEventType, WebhookEventHandler[]> = new Map();\n  \n  /**\n   * Create a new webhook service\n   * \n   * @constructor\n   * @param {McpServer} server - The MCP server instance for notifications\n   * @param {WebhookConfig} config - Configuration for the webhook service\n   * @param {string} [config.secret] - Secret for verifying webhook signatures\n   * @param {string} config.endpoint - HTTP endpoint path for receiving webhooks\n   */\n  constructor(server: McpServer, config: WebhookConfig) {\n    this.server = server;\n    this.config = config;\n    \n    // Initialize event handlers map with empty arrays for each event type\n    Object.values(WebhookEventType).forEach(eventType => {\n      this.eventHandlers.set(eventType as WebhookEventType, []);\n    });\n  }\n  \n  /**\n   * Register the webhook endpoint with the Express app\n   * \n   * This method sets up the HTTP route that will receive webhook events from\n   * the Digital Samba API and process them through the webhook service.\n   * \n   * @param {express.Application} app - Express application instance\n   * @returns {void}\n   */\n  public registerWebhookEndpoint(app: express.Application): void {\n    logger.info(`Registering webhook endpoint at ${this.config.endpoint}`);\n    \n    app.post(this.config.endpoint, this.handleWebhookRequest.bind(this));\n  }\n  \n  /**\n   * Handle incoming webhook requests\n   * \n   * This method processes HTTP requests to the webhook endpoint. It verifies\n   * signatures if a secret is configured, validates the payload, and triggers\n   * event processing.\n   * \n   * @private\n   * @param {Request} req - Express request object\n   * @param {Response} res - Express response object\n   * @returns {Promise<void>}\n   */\n  private async handleWebhookRequest(req: Request, res: Response): Promise<void> {\n    try {\n      logger.debug('Received webhook request', {\n        contentLength: req.headers['content-length'],\n        contentType: req.headers['content-type']\n      });\n      \n      // Verify webhook signature if secret is configured\n      if (this.config.secret) {\n        const signature = req.headers['x-digitalsamba-signature'] as string;\n        if (!signature) {\n          const error = new AuthenticationError('Missing webhook signature');\n          logger.warn(error.message);\n          res.status(401).json({ error: error.message });\n          return;\n        }\n        \n        if (!this.verifySignature(req, signature)) {\n          const error = new AuthenticationError('Invalid webhook signature');\n          logger.warn(error.message);\n          res.status(401).json({ error: error.message });\n          return;\n        }\n      }\n      \n      // Parse webhook payload\n      const payload = req.body as WebhookPayload;\n      if (!payload || !payload.event) {\n        const error = new ValidationError('Invalid webhook payload', {\n          validationErrors: {\n            'payload': 'Webhook payload must contain an event property'\n          }\n        });\n        logger.warn(error.message, { payload });\n        res.status(400).json({ \n          error: error.message,\n          details: error.validationErrors\n        });\n        return;\n      }\n      \n      logger.info(`Processing webhook event: ${payload.event}`, {\n        event: payload.event,\n        timestamp: payload.timestamp\n      });\n      \n      // Process the webhook event\n      await this.processWebhookEvent(payload);\n      \n      // Respond with success\n      res.status(200).json({ status: 'ok' });\n    } catch (error) {\n      logger.error('Error processing webhook', {\n        error: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined\n      });\n      \n      // Respond with appropriate status code based on error type\n      if (!res.headersSent) {\n        if (error instanceof AuthenticationError) {\n          res.status(401).json({ error: error.message });\n        }\n        else if (error instanceof ValidationError) {\n          res.status(400).json({ \n            error: error.message,\n            details: error.validationErrors\n          });\n        }\n        else if (error instanceof ApiResponseError) {\n          res.status(error.statusCode).json({\n            error: error.message,\n            apiError: error.apiErrorMessage,\n            details: error.apiErrorData\n          });\n        }\n        else if (error instanceof ResourceNotFoundError) {\n          res.status(404).json({\n            error: error.message,\n            resourceType: error.resourceType,\n            resourceId: error.resourceId\n          });\n        }\n        else {\n          // Default server error\n          res.status(500).json({ error: 'Internal server error' });\n        }\n      }\n    }\n  }\n  \n  /**\n   * Verify the webhook signature\n   * \n   * Uses HMAC-SHA256 to verify that the webhook was sent by Digital Samba\n   * and that the payload hasn't been tampered with.\n   * \n   * @private\n   * @param {Request} req - Express request object\n   * @param {string} signature - Signature from the X-DigitalSamba-Signature header\n   * @returns {boolean} True if signature is valid, false otherwise\n   */\n  private verifySignature(req: Request, signature: string): boolean {\n    if (!this.config.secret) {\n      return true; // No verification if no secret configured\n    }\n    \n    try {\n      // Create HMAC using the secret\n      const hmac = crypto.createHmac('sha256', this.config.secret);\n      \n      // Update with request body (as string)\n      const body = typeof req.body === 'string' \n        ? req.body \n        : JSON.stringify(req.body);\n      \n      hmac.update(body);\n      \n      // Get the digest\n      const calculatedSignature = hmac.digest('hex');\n      \n      // Compare with the provided signature\n      return crypto.timingSafeEqual(\n        Buffer.from(calculatedSignature, 'hex'),\n        Buffer.from(signature, 'hex')\n      );\n    } catch (error) {\n      logger.error('Error verifying webhook signature', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      \n      throw new AuthenticationError(`Error verifying webhook signature: ${error instanceof Error ? error.message : String(error)}`, {\n        cause: error instanceof Error ? error : undefined\n      });\n    }\n  }\n  \n  /**\n   * Process a webhook event\n   * \n   * Executes all registered handlers for the event type and notifies MCP clients.\n   * \n   * @private\n   * @param {WebhookPayload} payload - The webhook event payload\n   * @returns {Promise<void>}\n   */\n  private async processWebhookEvent(payload: WebhookPayload): Promise<void> {\n    const { event } = payload;\n    const handlers = this.eventHandlers.get(event as WebhookEventType);\n    \n    if (!handlers || handlers.length === 0) {\n      logger.debug(`No handlers registered for event: ${event}`);\n      return;\n    }\n    \n    logger.debug(`Executing ${handlers.length} handlers for event: ${event}`);\n    \n    // Execute all registered handlers\n    const promises = handlers.map(handler => handler(payload));\n    await Promise.all(promises);\n    \n    // Notify MCP clients about the event\n    await this.notifyMcpClients(payload);\n  }\n  \n  /**\n   * Register a handler for a specific event type\n   * \n   * Allows custom logic to be executed when specific webhook events are received.\n   * \n   * @public\n   * @param {WebhookEventType} event - The event type to listen for\n   * @param {WebhookEventHandler} handler - Function to execute when event occurs\n   * @returns {void}\n   * @example\n   * webhookService.on(WebhookEventType.RECORDING_READY, async (payload) => {\n   *   logger.info(`Recording ${payload.data.id} is ready for viewing`);\n   *   // Custom logic for when a recording is ready\n   * });\n   */\n  public on(event: WebhookEventType, handler: WebhookEventHandler): void {\n    const handlers = this.eventHandlers.get(event) || [];\n    handlers.push(handler);\n    this.eventHandlers.set(event, handlers);\n    \n    logger.debug(`Registered handler for event: ${event}`);\n  }\n  \n  /**\n   * Notify MCP clients about a webhook event\n   * \n   * Sends a notification to all connected MCP clients about the webhook event.\n   * This allows clients to receive real-time updates about Digital Samba events.\n   * \n   * @private\n   * @param {WebhookPayload} payload - The webhook event payload\n   * @returns {Promise<void>}\n   */\n  private async notifyMcpClients(payload: WebhookPayload): Promise<void> {\n    try {\n      logger.debug(`Notifying MCP clients about event: ${payload.event}`);\n      \n      // Create notification message based on event type\n      const notification = this.createNotificationForEvent(payload);\n      \n      // Send notification to all connected clients\n      // Note: Different versions of MCP SDK might have different notification methods\n      try {\n        // Use a type assertion to access potentially private properties\n        const mcpServer = this.server as any;\n        \n        // Try different methods for sending notifications based on SDK version\n        if (typeof mcpServer.notification === 'function') {\n          // Newer SDK version\n          await mcpServer.notification({\n            method: 'digitalsambaEvent',\n            params: notification\n          });\n          logger.debug('Sent notification using server.notification');\n        } \n        else if (mcpServer.server && typeof mcpServer.server.notification === 'function') {\n          // Older SDK version\n          await mcpServer.server.notification({\n            method: 'digitalsambaEvent',\n            params: notification\n          });\n          logger.debug('Sent notification using server.server.notification');\n        }\n        else {\n          // No notification method found\n          const error = new ConfigurationError('Unable to send notification: notification method not found');\n          logger.warn(error.message);\n          throw error;\n        }\n      } catch (notifyError) {\n        logger.error('Error during notification send', {\n          error: notifyError instanceof Error ? notifyError.message : String(notifyError)\n        });\n        \n        // Re-throw ConfigurationError as-is, wrap others in ApiRequestError\n        if (notifyError instanceof ConfigurationError) {\n          throw notifyError;\n        }\n        \n        throw new ApiRequestError(`Failed to send notification: ${notifyError instanceof Error ? notifyError.message : String(notifyError)}`, {\n          cause: notifyError instanceof Error ? notifyError : undefined\n        });\n      }\n      \n      logger.debug('Notification process completed');\n    } catch (error) {\n      logger.error('Error in notifyMcpClients', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      \n      // Re-throw the error to be handled by the caller\n      throw error;\n    }\n  }\n  \n  /**\n   * Create a notification object based on the event type\n   * \n   * Formats the webhook payload into a structured notification object\n   * based on the event type, extracting relevant fields for each event category.\n   * \n   * @private\n   * @param {WebhookPayload} payload - The webhook event payload\n   * @returns {Object} Formatted notification object\n   */\n  private createNotificationForEvent(payload: WebhookPayload): any {\n    const { event, data } = payload;\n    \n    // Create a base notification with common fields\n    const notification = {\n      event,\n      timestamp: payload.timestamp,\n      data: {}\n    };\n    \n    // Add specific fields based on event type\n    switch (event) {\n      case WebhookEventType.ROOM_CREATED:\n      case WebhookEventType.ROOM_UPDATED:\n      case WebhookEventType.ROOM_DELETED:\n        notification.data = {\n          roomId: data.id,\n          room: data\n        };\n        break;\n        \n      case WebhookEventType.SESSION_STARTED:\n      case WebhookEventType.SESSION_ENDED:\n        notification.data = {\n          sessionId: data.id,\n          roomId: data.room_id,\n          session: data\n        };\n        break;\n        \n      case WebhookEventType.PARTICIPANT_JOINED:\n      case WebhookEventType.PARTICIPANT_LEFT:\n        notification.data = {\n          participantId: data.id,\n          roomId: data.room_id,\n          sessionId: data.session_id,\n          participant: data\n        };\n        break;\n        \n      case WebhookEventType.RECORDING_STARTED:\n      case WebhookEventType.RECORDING_STOPPED:\n      case WebhookEventType.RECORDING_READY:\n        notification.data = {\n          recordingId: data.id,\n          roomId: data.room_id,\n          sessionId: data.session_id,\n          recording: data\n        };\n        break;\n        \n      case WebhookEventType.CHAT_MESSAGE:\n        notification.data = {\n          messageId: data.id,\n          roomId: data.room_id,\n          participantId: data.participant_id,\n          message: data\n        };\n        break;\n        \n      case WebhookEventType.POLL_CREATED:\n      case WebhookEventType.POLL_UPDATED:\n      case WebhookEventType.POLL_DELETED:\n        notification.data = {\n          pollId: data.id,\n          roomId: data.room_id,\n          poll: data\n        };\n        break;\n        \n      case WebhookEventType.QUESTION_ASKED:\n      case WebhookEventType.QUESTION_ANSWERED:\n        notification.data = {\n          questionId: data.id,\n          roomId: data.room_id,\n          participantId: data.participant_id,\n          question: data\n        };\n        break;\n        \n      default:\n        // For unknown events, include the entire data payload\n        notification.data = data;\n    }\n    \n    return notification;\n  }\n  \n  /**\n   * Register or update a webhook with Digital Samba API\n   * \n   * Creates a new webhook registration or updates an existing one with\n   * the Digital Samba API, specifying which events to subscribe to.\n   * \n   * @public\n   * @param {string} apiKey - Digital Samba API key\n   * @param {string} apiBaseUrl - Base URL for the Digital Samba API\n   * @param {string} webhookUrl - URL where webhook events should be sent\n   * @param {WebhookEventType[]} [eventTypes] - Event types to subscribe to (defaults to all)\n   * @returns {Promise<void>}\n   * @throws Will throw an error if the API request fails\n   */\n  public async registerWebhook(\n    apiKey: string, \n    apiBaseUrl: string,\n    webhookUrl: string,\n    eventTypes: WebhookEventType[] = Object.values(WebhookEventType) as WebhookEventType[]\n  ): Promise<void> {\n    try {\n      // Validate input parameters\n      if (!apiKey) {\n        throw new AuthenticationError('API key is required for webhook registration');\n      }\n      \n      if (!webhookUrl) {\n        throw new ValidationError('Webhook URL is required', {\n          validationErrors: { webhookUrl: 'Webhook URL cannot be empty' }\n        });\n      }\n      \n      if (!apiBaseUrl) {\n        throw new ValidationError('API base URL is required', {\n          validationErrors: { apiBaseUrl: 'API base URL cannot be empty' }\n        });\n      }\n      \n      logger.info('Registering webhook with Digital Samba API', {\n        webhookUrl,\n        eventCount: eventTypes.length\n      });\n      \n      // Create API client with the provided key\n      const client = new DigitalSambaApiClient(apiKey, apiBaseUrl);\n      \n      try {\n        // Get existing webhooks\n        const webhooks = await client.listWebhooks();\n        \n        // Check if a webhook already exists for this URL\n        const existingWebhook = webhooks.data.find(webhook => webhook.endpoint === webhookUrl);\n        \n        if (existingWebhook) {\n          // Update existing webhook\n          logger.info('Updating existing webhook', { webhookId: existingWebhook.id });\n          \n          await client.updateWebhook(existingWebhook.id, {\n            endpoint: webhookUrl,\n            events: eventTypes as unknown as string[],\n            name: 'MCP Server Webhook'\n          });\n        } else {\n          // Create new webhook\n          logger.info('Creating new webhook');\n          \n          await client.createWebhook({\n            endpoint: webhookUrl,\n            events: eventTypes as unknown as string[],\n            name: 'MCP Server Webhook'\n          });\n        }\n        \n        logger.info('Webhook registration successful');\n      } catch (error) {\n        // Handle API-specific errors\n        if (error instanceof Error) {\n          if ('statusCode' in error) {\n            const statusCode = (error as any).statusCode;\n            const errorMessage = error.message;\n            \n            if (statusCode === 401 || statusCode === 403) {\n              throw new AuthenticationError(`Authentication failed during webhook registration: ${errorMessage}`, {\n                cause: error\n              });\n            }\n            \n            if (statusCode === 404) {\n              throw new ResourceNotFoundError('Resource not found during webhook registration', {\n                resourceId: 'webhook',\n                resourceType: 'webhook',\n                cause: error\n              });\n            }\n            \n            throw new ApiResponseError(`API error during webhook registration`, {\n              statusCode,\n              apiErrorMessage: errorMessage,\n              cause: error\n            });\n          }\n        }\n        \n        // Default error handling\n        throw new ApiRequestError(`Error registering webhook: ${error instanceof Error ? error.message : String(error)}`, {\n          cause: error instanceof Error ? error : undefined\n        });\n      }\n    } catch (error) {\n      logger.error('Error registering webhook', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n  \n  /**\n   * Delete a webhook with Digital Samba API\n   * \n   * Deletes a webhook registration with the Digital Samba API based on the URL.\n   * \n   * @public\n   * @param {string} apiKey - Digital Samba API key\n   * @param {string} apiBaseUrl - Base URL for the Digital Samba API\n   * @param {string} webhookUrl - URL of the webhook to delete\n   * @returns {Promise<void>}\n   * @throws Will throw an error if the API request fails\n   */\n  public async deleteWebhook(\n    apiKey: string,\n    apiBaseUrl: string,\n    webhookUrl: string\n  ): Promise<void> {\n    try {\n      // Validate input parameters\n      if (!apiKey) {\n        throw new AuthenticationError('API key is required for webhook deletion');\n      }\n      \n      if (!webhookUrl) {\n        throw new ValidationError('Webhook URL is required', {\n          validationErrors: { webhookUrl: 'Webhook URL cannot be empty' }\n        });\n      }\n      \n      if (!apiBaseUrl) {\n        throw new ValidationError('API base URL is required', {\n          validationErrors: { apiBaseUrl: 'API base URL cannot be empty' }\n        });\n      }\n      \n      logger.info('Deleting webhook from Digital Samba API', { webhookUrl });\n      \n      // Create API client with the provided key\n      const client = new DigitalSambaApiClient(apiKey, apiBaseUrl);\n      \n      try {\n        // Get existing webhooks\n        const webhooks = await client.listWebhooks();\n        \n        // Find webhook for this URL\n        const existingWebhook = webhooks.data.find(webhook => webhook.endpoint === webhookUrl);\n        \n        if (existingWebhook) {\n          // Delete the webhook\n          logger.info('Deleting webhook', { webhookId: existingWebhook.id });\n          await client.deleteWebhook(existingWebhook.id);\n          logger.info('Webhook deletion successful');\n        } else {\n          logger.info('No webhook found for the specified URL');\n          throw new ResourceNotFoundError('No webhook found for the specified URL', {\n            resourceId: webhookUrl,\n            resourceType: 'webhook'\n          });\n        }\n      } catch (error) {\n        // Handle API-specific errors\n        if (error instanceof ResourceNotFoundError) {\n          // Re-throw ResourceNotFoundError\n          throw error;\n        }\n        \n        if (error instanceof Error) {\n          if ('statusCode' in error) {\n            const statusCode = (error as any).statusCode;\n            const errorMessage = error.message;\n            \n            if (statusCode === 401 || statusCode === 403) {\n              throw new AuthenticationError(`Authentication failed during webhook deletion: ${errorMessage}`, {\n                cause: error\n              });\n            }\n            \n            if (statusCode === 404) {\n              throw new ResourceNotFoundError('Webhook not found', {\n                resourceId: webhookUrl,\n                resourceType: 'webhook',\n                cause: error\n              });\n            }\n            \n            throw new ApiResponseError(`API error during webhook deletion`, {\n              statusCode,\n              apiErrorMessage: errorMessage,\n              cause: error\n            });\n          }\n        }\n        \n        // Default error handling\n        throw new ApiRequestError(`Error deleting webhook: ${error instanceof Error ? error.message : String(error)}`, {\n          cause: error instanceof Error ? error : undefined\n        });\n      }\n    } catch (error) {\n      logger.error('Error deleting webhook', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      throw error;\n    }\n  }\n}",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    },
    {
      "filePath": "/config/Documents/DS/projects/digital-samba-mcp-server/src/webhooks/webhook-types.ts",
      "messages": [
        {
          "ruleId": "@typescript-eslint/no-explicit-any",
          "severity": 1,
          "message": "Unexpected any. Specify a different type.",
          "line": 50,
          "column": 24,
          "nodeType": "TSAnyKeyword",
          "messageId": "unexpectedAny",
          "endLine": 50,
          "endColumn": 27,
          "suggestions": [
            {
              "messageId": "suggestUnknown",
              "fix": {
                "range": [
                  1285,
                  1288
                ],
                "text": "unknown"
              },
              "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
            },
            {
              "messageId": "suggestNever",
              "fix": {
                "range": [
                  1285,
                  1288
                ],
                "text": "never"
              },
              "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
            }
          ]
        }
      ],
      "suppressedMessages": [],
      "errorCount": 0,
      "fatalErrorCount": 0,
      "warningCount": 1,
      "fixableErrorCount": 0,
      "fixableWarningCount": 0,
      "source": "/**\n * Digital Samba MCP Server - Webhook Types and Interfaces\n * \n * This module defines all types, interfaces, and enums used throughout\n * the webhook system. It provides type definitions for webhook events,\n * payloads, configuration, and handlers.\n * \n * @module webhooks/webhook-types\n * @author Digital Samba Team\n * @version 1.0.0\n */\n\n// Define webhook event types\nexport enum WebhookEventType {\n  // Room events\n  ROOM_CREATED = 'room.created',\n  ROOM_UPDATED = 'room.updated',\n  ROOM_DELETED = 'room.deleted',\n  \n  // Session events\n  SESSION_STARTED = 'session.started',\n  SESSION_ENDED = 'session.ended',\n  \n  // Participant events\n  PARTICIPANT_JOINED = 'participant.joined',\n  PARTICIPANT_LEFT = 'participant.left',\n  \n  // Recording events\n  RECORDING_STARTED = 'recording.started',\n  RECORDING_STOPPED = 'recording.stopped',\n  RECORDING_READY = 'recording.ready',\n  \n  // Chat events\n  CHAT_MESSAGE = 'chat.message',\n  \n  // Poll events\n  POLL_CREATED = 'poll.created',\n  POLL_UPDATED = 'poll.updated',\n  POLL_DELETED = 'poll.deleted',\n  \n  // Q&A events\n  QUESTION_ASKED = 'qa.question',\n  QUESTION_ANSWERED = 'qa.answer',\n}\n\n// Define webhook payload interface\nexport interface WebhookPayload {\n  event: WebhookEventType;\n  timestamp: string;\n  data: Record<string, any>;\n}\n\n// Webhook configuration\nexport interface WebhookConfig {\n  secret?: string;  // For verifying webhook signatures\n  endpoint: string; // Endpoint path for receiving webhooks\n}\n\n// Webhook event handler type\nexport type WebhookEventHandler = (payload: WebhookPayload) => Promise<void>;",
      "usedDeprecatedRules": [
        {
          "ruleId": "no-extra-semi",
          "replacedBy": []
        },
        {
          "ruleId": "no-mixed-spaces-and-tabs",
          "replacedBy": []
        }
      ]
    }
  ]
}